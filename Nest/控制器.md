## 一、控制器是什么？它的核心作用
你可以把控制器想象成一个酒店的前台接待员。当客人（客户端，比如浏览器或移动端）提出需求时，前台会根据请求提供相应的服务，并把结果反馈给客人。控制器的作用也类似：

1. **接收请求**：监听来自客户端的 HTTP 请求，比如 GET、POST 等。
2. **处理逻辑**：根据请求类型，调用相应的业务逻辑（通常通过服务层实现）。
3. **返回响应**：将处理结果以 JSON、HTML 或其他格式返回给客户端。

在 NestJS 中，每个控制器通常专注于处理一类相关的业务逻辑。比如，一个 `CatsController` 可能专门负责管理猫咪相关的操作：获取猫咪列表、添加新猫咪、更新猫咪信息等。这样分工明确，代码结构清晰。

## 二、如何创建控制器？
在 NestJS 中，创建控制器非常简单，主要依赖 `@Controller()` 装饰器。以下是具体步骤：

### 1. 使用 `@Controller()` 装饰器
`@Controller()` 装饰器告诉 NestJS 这个类是一个控制器。你可以在装饰器中指定一个路径前缀，比如：

```typescript
import { Controller, Get } from '@nestjs/common';

@Controller('cats') // 路径前缀为 /cats
export class CatsController {
  @Get() // 处理 GET /cats 请求
  findAll() {
    return '获取所有猫咪';
  }
}
```

这里，`@Controller('cats')` 表示这个控制器处理的所有路由都会以 `/cats` 开头。比如，`@Get()` 装饰的方法会响应 `GET /cats` 请求。

### 2. 使用 Nest CLI 快速生成
如果你不想手动创建控制器，可以使用 Nest CLI 快速生成标准化的控制器文件：

```bash
nest generate controller cats
```

这条命令会自动生成：

+ `cats.controller.ts`（控制器文件）
+ `cats.controller.spec.ts`（测试文件）
+ 并将控制器注册到 `AppModule` 中

这样可以节省时间，确保代码结构符合 NestJS 的最佳实践。

### 3. 注册控制器
创建好控制器后，需要在模块中注册，通常在 `AppModule` 或某个功能模块中：

```typescript
import { Module } from '@nestjs/common';
import { CatsController } from './cats/cats.controller';

@Module({
  controllers: [CatsController], // 注册控制器
})
export class AppModule {}
```

## 三、路由系统：让控制器响应不同的请求
NestJS 的路由系统通过装饰器实现，简单而强大。以下是路由系统的核心要点：

### 1. 路由装饰器
NestJS 提供了多种路由装饰器，用于指定方法处理哪种 HTTP 请求：

+ `@Get()`：处理 GET 请求
+ `@Post()`：处理 POST 请求
+ `@Put()`：处理 PUT 请求
+ `@Delete()`：处理 DELETE 请求
+ `@Patch()`：处理 PATCH 请求

每个装饰器可以指定子路径。比如：

```typescript
@Controller('cats')
export class CatsController {
  @Get('list') // 响应 GET /cats/list
  findAll() {
    return '猫咪列表';
  }

  @Post() // 响应 POST /cats
  create() {
    return '创建新猫咪';
  }
}
```

**路径计算公式**：最终路径 = 控制器路径前缀（如 `/cats`） + 方法装饰器路径（如 `/list`）。

### 2. 方法名无关紧要
NestJS 只关心装饰器和路径，不关心方法名。你可以随意命名方法，比如 `findAll`、`getAllCats` 都可以，只要装饰器配置正确。

### 3. 路由顺序的重要性
路由的定义顺序会影响匹配结果。NestJS 会优先匹配静态路由（比如 `/cats/list`），再匹配动态路由（比如 `/cats/:id`）。因此，建议将具体路由放在动态路由之前：

```typescript
@Controller('cats')
export class CatsController {
  @Get('list') // 先定义静态路由
  findAll() {
    return '猫咪列表';
  }

  @Get(':id') // 再定义动态路由
  findOne() {
    return '单只猫咪';
  }
}
```

这样可以避免动态路由意外拦截静态路由的请求。

## 四、如何处理客户端请求和响应？
### 1. 获取请求信息
NestJS 提供了多种装饰器来获取请求的详细信息：

+ `@Body()`：获取 POST 请求的请求体
+ `@Query()`：获取 URL 查询参数（如 `?name=Tom`）
+ `@Param()`：获取路由参数（如 `/cats/123` 中的 `123`）
+ `@Headers()`：获取请求头
+ `@Ip()`：获取客户端 IP
+ `@Session()`：获取会话信息
+ `@Req()`：获取原始请求对象

**示例**：处理 POST 请求和请求体

首先，定义一个 DTO（数据传输对象）来规范请求体的数据结构：

```typescript
// create-cat.dto.ts
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}
```

然后在控制器中使用：

```typescript
import { Controller, Post, Body } from '@nestjs/common';
import { CreateCatDto } from './create-cat.dto';

@Controller('cats')
export class CatsController {
  @Post()
  create(@Body() createCatDto: CreateCatDto) {
    return `创建了一只猫咪：${createCatDto.name}, ${createCatDto.age} 岁`;
  }
}
```

**处理路由参数和查询参数**：

```typescript
@Controller('cats')
export class CatsController {
  @Get(':id')
  findOne(@Param('id') id: string) {
    return `获取 ID 为 ${id} 的猫咪`;
  }

  @Get()
  findByQuery(@Query('name') name: string) {
    return `查找名字为 ${name} 的猫咪`;
  }
}
```

### 2. 返回响应
NestJS 提供了两种返回响应的方式：

#### （1）标准方式（推荐）
直接返回数据，NestJS 会自动处理序列化、状态码和 Content-Type：

```typescript
@Get()
findAll() {
  return [{ name: 'Tom', age: 3 }]; // 自动转为 JSON，状态码 200
}

@Post()
create(@Body() createCatDto: CreateCatDto) {
  return createCatDto; // 自动转为 JSON，状态码 201
}
```

#### （2）特定于库的方式
如果你需要更精细的控制，可以使用底层的响应对象（需要引入 Express 或 Fastify 的响应对象）：

```typescript
import { Response } from 'express';

@Get()
findAll(@Res() res: Response) {
  res.status(200).json({ message: '手动设置响应' });
}
```

**注意**：使用 `@Res()` 后，NestJS 会认为你完全接管了响应逻辑，标准方式会失效。如果只想设置 Header 或 Cookie，但仍希望 NestJS 处理响应体，可以使用：

```typescript
@Get()
findAll(@Res({ passthrough: true }) res: Response) {
  res.set('X-Custom-Header', 'value');
  return { message: '仍然使用标准方式返回' };
}
```

## 五、高级功能和最佳实践
### 1. 自定义状态码和响应头
可以通过 `@HttpCode()` 和 `@Header()` 装饰器自定义状态码和响应头：

```typescript
import { Post, HttpCode, Header } from '@nestjs/common';

@Post()
@HttpCode(202)
@Header('Cache-Control', 'no-store')
create() {
  return '自定义状态码和响应头';
}
```

### 2. 重定向
NestJS 支持通过 `@Redirect()` 实现重定向：

```typescript
@Get('docs')
@Redirect('https://docs.nestjs.com', 301)
getDocs(@Query('version') version: string) {
  if (version === '5') {
    return { url: 'https://docs.nestjs.com/v5/', statusCode: 302 };
  }
}
```

### 3. 路由通配符
支持使用通配符匹配灵活的路由：

```typescript
@Get('ab*cd') // 匹配 abcd、ab_cd、abXYZcd 等
findWildcard() {
  return '通配符匹配的路由';
}
```

### 4. 异步处理
NestJS 天生支持异步操作，可以返回 `Promise` 或 `Observable`：

```typescript
@Get()
async findAll(): Promise<any[]> {
  const cats = await this.catsService.findAll(); // 异步查询
  return cats;
}

// 使用 Observable
import { Observable, of } from 'rxjs';

@Get()
findAllObservable(): Observable<any[]> {
  return of([{ name: 'Tom', age: 3 }]);
}
```

### 5. 最佳实践
+ **单一职责**：一个控制器专注于一类业务逻辑，避免过于复杂。
+ **使用 DTO**：通过 DTO 规范请求体和查询参数的数据结构，确保类型安全。
+ **路由顺序**：静态路由优先于动态路由，避免冲突。
+ **优先使用标准响应**：尽量避免直接操作底层响应对象，保持代码简洁。
+ **异步优先**：使用 `async/await` 处理数据库或外部 API 调用，提升性能。

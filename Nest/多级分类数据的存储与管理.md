在 Web 开发中，多级分类或树形结构数据无处不在，例如商品分类、组织架构、评论系统等。如何高效地存储和管理这类数据，是后端开发人员必须面对的挑战。不当的设计可能会导致查询效率低下、数据冗余以及难以维护等问题。

本文将深入探讨多级分类数据的不同存储策略，并以 `TypeORM` 和 `NestJS` 为例，通过一个完整的实践项目，展示如何使用“闭包表”（Closure Table）模式优雅地解决这一问题。你将学到：

*   四种主流的树形结构存储方案及其优缺点。
*   如何使用 TypeORM 的 `@Tree` 装饰器快速实现树形实体。
*   在 NestJS 中进行树形数据的增、删、改、查操作。
*   各种高级查询技巧，如查找祖先、后代以及根节点等。



## 存储策略概述

对于多级分类数据，常见的存储方法有多种。传统的多表存储（即每个层级一个表）虽然直观，但在层级深度不固定或频繁变动时，会变得非常笨重，导致数据冗余和维护困难。

因此，**单表存储**是更受推荐的方案。通过在表中增加特定字段来维护层级关系，可以更灵活地适应业务变化。本文将重点介绍四种主流的单表存储策略。



## 实践示例：使用 TypeORM 和 NestJS
### 项目初始化
创建 nest 项目：

```sh
nest new typeorm-tree-entity-test -p npm
```

进入项目目录，创建一个 CRUD 模块：

```sh
nest g resource city --no-spec
```

安装所需的 TypeORM 包和 MySQL 驱动：

```sh
npm install @nestjs/typeorm typeorm mysql2
```



### 配置数据库连接
```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { CityModule } from './city/city.module';
import { TypeOrmModule } from '@nestjs/typeorm';
import { City } from './city/entities/city.entity';

@Module({
  imports: [
    CityModule,
    TypeOrmModule.forRoot({
      type: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'xxx',
      database: 'tree-test',
      synchronize: true,
      logging: true,
      autoLoadEntities: true, // 推荐使用 autoLoadEntities
      extra: { connectionLimit: 10 },
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

### 实体与闭包表

运行服务后，TypeORM 会根据 `City` 实体的定义自动创建两张表。

**1. `city` 表**

这张表包含了实体定义的基本属性，如 `id`, `name`, `status` 等。`@TreeParent` 装饰器会自动添加一个 `parentId` 字段，用于存储父节点的 ID。

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714632706746-ed9c40d9-39c2-4e94-99e2-ba98bd7aa5fe.png)

**2. `city_closure` 表**

这张表是“闭包表”模式的核心，由 `@Tree('closure-table')` 指定生成。它用于存储树中节点之间所有的层级关系，而不仅仅是直接的父子关系。表中通常包含两个外键，都指向 `city` 表的 `id`。

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714632724546-7883b784-fd09-4e65-a89f-0f3302baf9d9.png)





### 数据初始化与插入
为了更好地演示，我们将数据插入的逻辑从 `findAll` 方法中分离出来，创建一个专门用于初始化的方法。这样更符合单一职责原则。

在 `city.service.ts` 中，我们重构代码如下：

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectEntityManager } from '@nestjs/typeorm';
import { EntityManager, TreeRepository } from 'typeorm';
import { City } from './entities/city.entity';

@Injectable()
export class CityService {
  private readonly treeRepository: TreeRepository<City>;

  constructor(@InjectEntityManager() private readonly entityManager: EntityManager) {
    this.treeRepository = this.entityManager.getTreeRepository(City);
  }

  async initData() {
    const root = this.treeRepository.create({ name: '华中' });
    await this.treeRepository.save(root);

    const parent = await this.treeRepository.findOneBy({ name: '华中' });
    if (parent) {
      const child1 = this.treeRepository.create({ name: '湖南', parent });
      await this.treeRepository.save(child1);

      const child2 = this.treeRepository.create({ name: '长沙', parent: child1 });
      await this.treeRepository.save(child2);
    }
    return 'Data initialized successfully.';
  }

  async findAll() {
    return this.treeRepository.findTrees();
  }
}
```

我们创建了一个 `initData` 方法，专门用于创建并保存三个层级关系的城市实体。`findAll` 方法现在只负责查询并返回完整的树形结构。

为了方便触发数据初始化，我们可以稍微修改 `city.controller.ts`：

```typescript
import { Controller, Get, Post, Query } from '@nestjs/common';
import { CityService } from './city.service';

@Controller('city')
export class CityController {
  constructor(private readonly cityService: CityService) {}

  @Post('init')
  initData() {
    return this.cityService.initData();
  }

  @Get()
  findAll() {
    return this.cityService.findAll();
  }
}
```

现在，我们可以通过访问 `POST /city/init` 来初始化数据，然后通过 `GET /city` 来查看树形结构的结果。



### 数据访问
访问：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714664008185-cf66dedf-a730-4025-8885-98ae642cf4f0.png)



## 查询数据的其他方法
### findRoots
findRoots 方法用于找出所有根节点。根节点是没有父节点的节点，通常作为数据层级结构的最顶层：

```typescript
async findAll() {
  return this.entityManager.getTreeRepository(City).findRoots();
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714663432534-a5576c86-5472-4bd3-b35a-5b3776fd8c6a.png)



### findDescendantsTree
`findDescendantsTree` 方法用于查询某个节点的所有后代节点，并以树形结构返回。

为了让接口更灵活，我们改造 `CityController` 和 `CityService`，使其能够接收参数。

**city.controller.ts**
```typescript
@Get('descendants')
findDescendants(@Query('name') name: string) {
  return this.cityService.findDescendants(name);
}
```

**city.service.ts**
```typescript
async findDescendants(name: string) {
  const parent = await this.treeRepository.findOneBy({ name });
  if (!parent) {
    throw new NotFoundException(`City with name '${name}' not found.`);
  }
  return this.treeRepository.findDescendantsTree(parent);
}
```

现在，我们可以通过访问 `GET /city/descendants?name=湖南` 来动态查询指定节点的所有后代。

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714663851780-5e6dfc4f-d1cf-4162-9efe-5204db3de627.png)





### findAncestorsTree
`findAncestorsTree` 与 `findDescendantsTree` 相反，它用于查询指定节点及其所有祖先节点的树形结构。

**city.controller.ts**
```typescript
@Get('ancestors')
findAncestors(@Query('name') name: string) {
  return this.cityService.findAncestors(name);
}
```

**city.service.ts**
```typescript
async findAncestors(name: string) {
  const child = await this.treeRepository.findOneBy({ name });
  if (!child) {
    throw new NotFoundException(`City with name '${name}' not found.`);
  }
  return this.treeRepository.findAncestorsTree(child);
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714663963030-07ff5d23-9052-4454-84b8-61f1115b660b.png)



### 返回扁平化结构
如果换成 findAncestors、findDescendants 就是用扁平结构返回：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714664079595-2979f86f-4215-4f1a-9ec2-f60faa4efa55.png)

把 findTrees 换成 find 也是会返回扁平的结构。



### 计数
调用 `countDescendants` 和 `countAncestors` 来进行计数。

**city.controller.ts**
```typescript
@Get('count/descendants')
countDescendants(@Query('name') name: string) {
  return this.cityService.countDescendants(name);
}
```

**city.service.ts**
```typescript
async countDescendants(name: string) {
  const parent = await this.treeRepository.findOneBy({ name });
  if (!parent) {
    throw new NotFoundException(`City with name '${name}' not found.`);
  }
  return this.treeRepository.countDescendants(parent);
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714664639741-3cf22bcd-af0a-4fe6-ac3e-a50e51b813f4.png)

我们最后来看下 city_closure 表：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714716005769-8a9a7259-f417-45ee-808a-df19f1d21387.png)

### 闭包表工作原理解析

闭包表的核心思想是“空间换时间”。它通过一张额外的表（`city_closure`）记录了树中所有节点之间的关系，而不仅仅是直接的父子关系。这张表通常包含三个字段：

*   `id_ancestor`: 祖先节点的 ID。
*   `id_descendant`: 后代节点的 ID。
*   `depth` (可选): 从祖先到后代的距离（层级差）。

让我们来解读上图中的数据：

| id_ancestor | id_descendant | depth |
| :--- | :--- | :--- |
| 1 (华中) | 1 (华中) | 0 |
| 2 (湖南) | 2 (湖南) | 0 |
| 3 (长沙) | 3 (长沙) | 0 |
| 1 (华中) | 2 (湖南) | 1 |
| 1 (华中) | 3 (长沙) | 2 |
| 2 (湖南) | 3 (长沙) | 1 |

*   **自身到自身的关系**：每个节点都是自己的祖先和后代，`depth` 为 0。这对于某些查询很有用。
*   **直接父子关系**：`depth` 为 1 的记录表示直接的父子关系。例如，(1, 2, 1) 表示“华中”是“湖南”的直接父节点。
*   **跨级关系**：`depth` 大于 1 的记录表示间接的祖孙关系。例如，(1, 3, 2) 表示“华中”是“长沙”的祖先，并且相隔 2 个层级。

**查询优势**：

*   **查询所有后代**：要查找“华中”（ID=1）的所有后代，只需查询 `city_closure` 表中 `id_ancestor = 1` 且 `id_descendant != 1` 的所有记录。
*   **查询所有祖先**：要查找“长沙”（ID=3）的所有祖先，只需查询 `id_descendant = 3` 且 `id_ancestor != 3` 的所有记录。

这种设计避免了递归查询，将复杂的树操作转换为了简单的 SQL `JOIN` 操作，从而极大地提高了查询性能。



## 处理树的不同策略
![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1714714903429-217b252d-c554-45ce-b7ae-833099f307e4.png)

TypeORM 支持四种存储模式：

+ Closure Table（闭包表）
+ Materialized Path（物化路径）
+ Nested Set（嵌套集合）
+ Adjacency List（邻接表）

下表总结了这四种策略的优缺点：

| 策略 | 优点 | 缺点 |
| :--- | :--- | :--- |
| **邻接表 (Adjacency List)** | 实现简单，数据直观，写操作快。 | 查询祖先或后代节点需要递归，性能差。 |
| **物化路径 (Materialized Path)** | 查询效率高，尤其是按层级查询。 | 路径更新复杂，字符串操作开销大，不利于数据库强制约束。 |
| **嵌套集合 (Nested Set)** | 读操作（尤其是查询子树）极为高效。 | 写操作（增、删、改）成本高昂，实现复杂。 |
| **闭包表 (Closure Table)** | 查询灵活，读写性能均衡，功能强大。 | 需要额外一张表来维护关系，占用更多存储空间。 |

通常我们会选择 Closure Table 或 Materialized Path，因为它们能更好地处理层级关系的存储。



### Materialized Path
Materialized Path（物化路径）是一种处理树形数据结构的方法，它通过在每个节点上存储一个表示从根节点到该节点路径的字符串来表示树的层次结构。

这个字符串通常包含了从根节点到当前节点的所有节点 ID，并且用一个特定的分隔符分隔开。这种方法在数据库中的表示通常很直观，并且查询效率较高，尤其是在读操作远多于写操作的情况下。



比如我们有一个组织结构：

```text
公司
├── 技术部
│   ├── 后端开发组
│   └── 前端开发组
└── 销售部
    ├── 国内销售组
    └── 国际销售组
```

上面结构转换为表包含以下列：

+ id: 部门的唯一标识符
+ name: 部门名称
+ path: 物化路径，表示从根部门到当前部门的路径

表中的数据可能如下所示：

| id | name | path |
| :--- | :--- | :--- |
| 1 | 公司 | 1/ |
| 2 | 技术部 | 1/2/ |
| 3 | 销售部 | 1/3/ |
| 4 | 后端开发组 | 1/2/4/ |
| 5 | 前端开发组 | 1/2/5/ |
| 6 | 国内销售组 | 1/3/6/ |
| 7 | 国际销售组 | 1/3/7/ |


每个部门的 path 列存储了从根部门（公司）到该部门的路径。

例如，后端开发组的 path 是 1/2/4/，这表示它首先是公司（id=1）的子部门，然后是技术部（id=2）的子部门，最后是后端开发组本身（id=4）。



### Nested Set
在 Nested Set 模型中，这棵树的数据库表可能如下所示：

| id | name | left | right |
| :--- | :--- | :--- | :--- |
| 1 | 公司 | 1 | 14 |
| 2 | 技术部 | 2 | 7 |
| 3 | 销售部 | 8 | 13 |
| 4 | 后端开发组 | 3 | 4 |
| 5 | 前端开发组 | 5 | 6 |
| 6 | 国内销售组 | 9 | 10 |
| 7 | 国际销售组 | 11 | 12 |


在这个表中，每个节点都有左值（left）和右值（right）。根据Nested Set的规则，我们可以知道：

+ 任何节点的左值总是小于其右值。
+ 如果一个节点的左值和右值分别大于另一个节点的左值且小于其右值，那么这个节点就是另一个节点的子节点。例如，技术部（left=2, right=7）是公司（left=1, right=14）的子部门，因为 2 和 7 都在 1 和 14 之间。
+ 通过比较左值和右值，我们可以轻松地查询到任何节点的所有子节点、父节点或同级节点。

要找到技术部下的所有子部门，可以查询所有左值大于 2 且右值小于 7 的节点：

```sql
SELECT * FROM departments WHERE left > 2 AND right < 7;
```

要找到后端开发组的父部门，可以查询包含左值 3 和右值 4 在其左右值范围内的节点：

```sql
SELECT * FROM departments WHERE left < 3 AND right > 4;
```

要查询与后端开发组同级的所有节点，首先找到其父节点（技术部），然后查询该父节点下的所有直接子节点。

Nested Set 模型的优点是查询效率非常高，尤其适合读操作远多于写操作的场景。但是，当需要添加、删除或移动节点时，可能需要更新多个节点的左值和右值，这会使得写操作相对较慢。

而且 Nested Set 在嵌套集合中不能有多个根。



### Adjacency List
在 Adjacency List 模型中，这棵树的数据库表可能如下所示：

| id | name | parent_id |
| :--- | :--- | :--- |
| 1 | 公司 | NULL |
| 2 | 技术部 | 1 |
| 3 | 销售部 | 1 |
| 4 | 后端开发组 | 2 |
| 5 | 前端开发组 | 2 |
| 6 | 国内销售组 | 3 |
| 7 | 国际销售组 | 3 |


在这个表中，每个节点都有一个 parent_id 字段，这个字段指向其父节点的 id。

对于根节点（公司），parent_id 是 NULL，因为它没有父节点。



要找到技术部下的所有直接子部门，可以查询 parent_id 等于技术部 id 的所有节点：

```sql
SELECT * FROM departments WHERE parent_id = 2;
```

要找到后端开发组的父部门，可以查询 id 等于后端开发组的 parent_id 的节点：

```sql
   SELECT * FROM departments WHERE id = (SELECT parent_id FROM departments WHERE name = '后端开发组');
```

查询一个节点的所有祖先节点需要递归查询，这是 Adjacency List 方法的一个缺点，因为它可能涉及多次数据库查询。在某些数据库管理系统中，可以使用递归的公用表表达式（CTE）来实现：

```sql
WITH RECURSIVE ancestors AS (
   SELECT id, name, parent_id FROM departments WHERE name = '后端开发组'
   UNION ALL
   SELECT d.id, d.name, d.parent_id FROM departments d
   INNER JOIN ancestors a ON a.parent_id = d.id
)
SELECT * FROM ancestors;
```

Adjacency List模型的缺点是查询某个节点的所有祖先节点或所有子孙节点可能需要多次递归查询，这在大型树中可能效率较低。

## 总结与选型建议

本文详细介绍了四种主流的树形结构数据存储策略：邻接表、物化路径、嵌套集合和闭包表，并重点通过 NestJS 和 TypeORM 实践了闭包表方案。

每种策略都有其独特的优势和适用场景：

*   **邻接表 (Adjacency List)**：实现简单，写操作快。但查询多级数据时需要递归，性能较差。适合层级不深、读操作不频繁的场景。
*   **物化路径 (Materialized Path)**：查询效率高，实现相对简单。但路径更新可能较慢，且不利于数据库强制约束。适合读多写少的场景。
*   **嵌套集合 (Nested Set)**：读操作（尤其是查询子树）极为高效。但写操作（增、删、改）成本高昂，需要更新大量节点的左右值。适合极少变动的静态树。
*   **闭包表 (Closure Table)**：功能强大，查询灵活，在读写性能之间取得了很好的平衡。虽然额外需要一张表来维护关系，但其带来的查询便利性通常是值得的。TypeORM 对其提供了优秀的支持，是许多复杂场景下的首选。

**如何选择？**

*   对于简单、层级固定的树，**邻接表**足够。
*   对于读密集型应用，可以考虑**物化路径**或**嵌套集合**。
*   对于需要频繁进行各种复杂查询（如查找祖先、后代）且数据可能变动的场景，**闭包表**是功能最全面、最可靠的选择。

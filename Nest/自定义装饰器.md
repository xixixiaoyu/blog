在 Nest 开发中，我们经常会遇到这样的情况：需要从请求中提取相同的数据，比如用户信息、权限验证等。如果每次都重复写相同的代码，不仅麻烦，还容易出错。这时候，自定义装饰器就能帮我们解决这个问题。

自定义装饰器通常用于实现特定的功能，如日志记录、权限验证、数据校验等。创建自定义装饰器主要涉及以下几种类型：

1. **类装饰器**：用于类声明
2. **方法装饰器**：用于方法
3. **属性装饰器**：用于属性
4. **参数装饰器**：用于方法参数

## 为什么需要自定义装饰器？
虽然 Nest 内置了很多实用的装饰器，比如 `@Body()`、`@Query()`、`@Param()` 等，但在实际项目中，这些"标配"装饰器有时候还不够用。

想象下这个场景：用户登录后，我们通常会把用户信息存储在 `request.user` 中。每当需要获取用户信息时，你可能会这样写：

```typescript
@Get('profile')
getUserProfile(@Req() req) {
  const user = req.user; // 每次都要手动提取
  console.log(user);
  return user;
}

@Put('settings')
updateSettings(@Req() req, @Body() settingsData) {
  const user = req.user; // 又要写一遍，真麻烦
  // 处理用户设置逻辑
}
```

看到了吗？每次都要写 `const user = req.user;`，代码重复且容易出错。这时候，一个自定义的 `@User()` 装饰器就能让代码变得更加简洁。



## 创建你的第一个自定义装饰器
Nest 提供了 `createParamDecorator` 函数，这就是我们创建自定义装饰器的"利器"。让我们来创建一个 `@User()` 装饰器：

```typescript
// src/common/decorators/user.decorator.ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const User = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    // 获取 HTTP 请求上下文
    const request = ctx.switchToHttp().getRequest();
    // 返回挂载在 request 上的用户信息
    return request.user;
  },
);
```

`createParamDecorator` 接收一个工厂函数作为参数。这个工厂函数有两个参数：

+ `data`：可以让装饰器更灵活，稍后我们会详细介绍
+ `ctx`：执行上下文，通过它可以访问当前请求的各种信息

现在在控制器中使用就简单多了：

```typescript
@Controller('users')
export class UsersController {
  @Get('profile')
  getUserProfile(@User() user: UserEntity) { // 直接就能拿到
    console.log(user);
    return user;
  }

  @Put('settings')
  updateSettings(@User() user: UserEntity, @Body() settingsData: any) {
    console.log(`更新用户 ${user.id} 的设置`, settingsData);
    return { message: '设置更新成功' };
  }
}
```

代码瞬间清爽了很多，路由处理函数可以更专注于业务逻辑。

或者：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387076361-c707e663-dac5-4da1-8e38-d84ce14bd70f.png)

这个函数就是一个自定义装饰器。

获取定义的 set-user 元数据：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387099428-2d6a2960-44db-499a-a469-1263e253cd47.png)

在对应的控制器方法应用自定义装饰器和守卫：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387107927-80eaba38-df5d-4874-a474-fa075059a8c6.png)

访问 [http://localhost:3000](http://localhost:3000/)，控制台会打印对应设置的元数据：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387118149-3f1ba5f7-5c05-4f3b-a913-46b34ee81831.png)



## 参数装饰器
有时候我们可能不需要整个用户对象，只需要某个特定属性，比如用户 ID 或姓名。`createParamDecorator` 工厂函数的第一个参数 `data` 正好可以派上用场：

```typescript
// src/common/decorators/user.decorator.ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const User = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;

    // 如果传入了属性名，返回对应属性值；否则返回整个用户对象
    return data ? user?.[data] : user;
  },
);
```

使用起来更加灵活：

```typescript
@Controller('users')
export class UsersController {
  @Get('welcome')
  sayHello(@User('firstName') firstName: string) {
    return firstName ? `你好 ${firstName}！` : '你好！';
  }

  @Get('details')
  getUserDetails(@User() user: UserEntity) {
    return user;
  }
}
```



## 与管道配合使用
自定义装饰器同样可以和管道（Pipes）配合使用，进行数据验证和转换：

```typescript
@Controller('users')
export class UsersController {
  @Get('validated-profile')
  getValidatedProfile(
    @User(new ValidationPipe({ validateCustomDecorators: true })) // 直接把管道应用在 @User() 上
    user: UserEntity,
  ) {
    console.log('用户数据通过验证:', user);
    return user;
  }
}
```

注意：对于 `ValidationPipe`，需要设置 `validateCustomDecorators: true` 才能验证自定义装饰器获取的数据。



## 组合装饰器
在处理认证和授权时，我们经常需要同时使用多个装饰器。Nest 的 `applyDecorators` 函数可以把多个装饰器组合成一个"超级装饰器"：

```typescript
// src/common/decorators/auth.decorator.ts
import { applyDecorators, UseGuards, SetMetadata } from '@nestjs/common';
import { AuthGuard } from '../guards/auth.guard'; // 你的认证守卫
import { RolesGuard } from '../guards/roles.guard'; // 你的角色守卫
import { Role } from '../enums/role.enum'; // 你的角色枚举，比如 Role.Admin, Role.User
import { ApiBearerAuth, ApiUnauthorizedResponse } from '@nestjs/swagger'; // Swagger 相关

export function Auth(...roles: Role[]) { // 接收角色作为参数
  return applyDecorators(
    SetMetadata('roles', roles), // 1. 设置角色元数据，供 RolesGuard 使用
    UseGuards(AuthGuard, RolesGuard), // 2. 应用认证守卫和角色守卫
    ApiBearerAuth(), // 3. Swagger 文档：表示这个接口需要 Bearer Token 认证
    ApiUnauthorizedResponse({ description: 'Unauthorized' }), // 4. Swagger 文档：未授权时的响应描述
  );
}
```

使用时非常简洁：

```typescript
@Controller('admin')
export class AdminController {
  @Get('users')
  @Auth(Role.Admin) // 一个装饰器搞定所有认证和授权逻辑
  findAllUsers() {
    return '管理员用户列表';
  }
}
```

**注意一个小坑**：目前 `@nestjs/swagger` 包里的 `@ApiHideProperty()` 装饰器和 `applyDecorators` 函数一起用时可能不会按预期工作，它不太适合被组合。

或者使用我们更熟悉的：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387406399-95d9927f-5ef8-47b3-bce0-346ef6c6fdd6.png)

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387412118-23f806e3-6a58-42a9-8ae5-fc94b6e99817.png)



## 实现内置的 @Param、@Query、@Headers 装饰器
Header：

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CustomHeaders = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return data ? request.headers[data.toLowerCase()] : request.headers;
  },
);
```

分别用内置 Headers 和自己实现的 CustomHeaders：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387472892-4ca43e1a-bd40-41a5-b2cb-f3f394cdf136.png)

访问下，控制台打印：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387483002-33dfc612-0d73-4538-9a02-ce375b11cbc9.png)



Query：

```typescript
export const CustomQuery = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return data ? request.query[data] : request.query;
  },
);
```

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387509965-ce18e5ad-143d-4752-89f6-a9318cb5189f.png)

访问页面：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387515916-2b29f62c-aeb5-4dde-a7ca-cf57ee176db2.png)

控制打印：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387521172-b9bd490e-afb2-464f-805b-60934764e08f.png)



Param：

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

// 创建自定义的 @Param 装饰器
export const CustomParam = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return data ? request.params[data] : request.params;
  },
);
```

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387536779-3dda5926-48f3-4a9d-975e-d3263bce5436.png)

访问页面：![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387545004-5295fea6-7943-4c6b-aed8-6276ff784df9.png)

控制台打印：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749387560537-f6118a56-d978-433b-bcfd-b6bc409c1f13.png)



## 自定义 class 装饰器
```typescript
import { applyDecorators, Controller, SetMetadata } from '@nestjs/common';

export const CustomController = (path, metaData) => {
  return applyDecorators(Controller(path), SetMetadata('my-class', metaData));
};
```

使用：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749388260946-d6a4ccc9-9e4c-4b51-b036-648d29c3c8df.png)

获取定义 class 上的元数据：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749388268412-73dfbd15-a349-454c-8365-c07bff293dd3.png)

访问 [http://localhost:3000/app](http://localhost:3000/app)，控制台打印：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749388274766-881d07f3-c5fa-47a8-8252-ec88fa1c5f24.png)



## 自定义属性装饰器
属性装饰器通常用来处理与类实例相关的逻辑，比如添加额外的验证、格式化数据或者注入依赖。

在这个装饰器中，我们定义了一个新的属性描述符，并使用 `Object.defineProperty` 重新定义了属性，这样就可以在 getter 和 setter 中添加自定义的逻辑：

```typescript
export function DefaultValue(value: string): PropertyDecorator {
  return function (target, propertyKey: string | symbol) {
    let val = value;

    const getter = () => {
      return val;
    };
    const setter = (next: string) => {
      val = next;
    };

    // 删除属性
    if (delete target[propertyKey]) {
      // 重新定义属性
      Object.defineProperty(target, propertyKey, {
        get: getter,
        set: setter,
        enumerable: true,
        configurable: true,
      });
    }
  };
}
```

使用这个装饰器来自动为属性赋予默认值：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749388491496-9396a67c-5800-40c7-b312-a2e9fc9cc049.png)

访问页面：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749388497273-5cb932b7-f348-4c23-9495-cf5473817498.png)


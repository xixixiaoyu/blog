# NestJS å®æˆ˜ï¼šä»é›¶æ„å»ºä¸€ä¸ªç”Ÿäº§çº§çš„ç™»å½•æ³¨å†Œç³»ç»Ÿ

æœ¬æ•™ç¨‹å°†å¼•å¯¼ä½ ä½¿ç”¨ NestJSã€TypeORM å’Œ JWTï¼Œä»é›¶å¼€å§‹æ„å»ºä¸€ä¸ªåŠŸèƒ½å®Œå–„ã€å®‰å…¨å¯é çš„ç™»å½•æ³¨å†Œç³»ç»Ÿã€‚æˆ‘ä»¬å°†éµå¾ªè¡Œä¸šæœ€ä½³å®è·µï¼Œæ¶µç›–ä»é¡¹ç›®åˆå§‹åŒ–ã€æ•°æ®åº“è®¾è®¡ã€é…ç½®ç®¡ç†åˆ°åŠ å¯†ã€æ ¡éªŒå’Œé‰´æƒçš„æ¯ä¸€ä¸ªç¯èŠ‚ã€‚

## æ ¸å¿ƒæŠ€æœ¯æ ˆ

*   **æ¡†æ¶**: [NestJS](https://nestjs.com/)
*   **ORM**: [TypeORM](https://typeorm.io/)
*   **æ•°æ®åº“**: MySQL
*   **é‰´æƒ**: JWT (JSON Web Token)
*   **æ ¡éªŒ**: `class-validator`, `class-transformer`
*   **åŠ å¯†**: `bcrypt`
*   **é…ç½®ç®¡ç†**: `@nestjs/config`

---

## æ­¥éª¤ä¸€ï¼šç¯å¢ƒå‡†å¤‡ä¸é¡¹ç›®åˆå§‹åŒ–

### 1. åˆ›å»ºæ•°æ®åº“

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªç”¨äºå­˜å‚¨ç”¨æˆ·ä¿¡æ¯çš„æ•°æ®åº“ã€‚

```sql
CREATE SCHEMA `login_system_prod` DEFAULT CHARACTER SET utf8mb4;
```

> **ğŸ’¡ æœ€ä½³å®è·µ**: ä½¿ç”¨ `utf8mb4` å­—ç¬¦é›†å¯ä»¥ç¡®ä¿ä½ çš„åº”ç”¨èƒ½æ­£ç¡®å¤„ç†åŒ…æ‹¬ Emoji åœ¨å†…çš„å„ç±»ç‰¹æ®Šå­—ç¬¦ã€‚

### 2. åˆå§‹åŒ– NestJS é¡¹ç›®

ä½¿ç”¨ Nest CLI åˆ›å»ºä¸€ä¸ªæ–°çš„é¡¹ç›®ã€‚æˆ‘ä»¬æ¨èä½¿ç”¨ `pnpm` ä½œä¸ºåŒ…ç®¡ç†å™¨ã€‚

```bash
nest new login-and-register -p pnpm
```

### 3. å®‰è£…æ ¸å¿ƒä¾èµ–

è¿›å…¥é¡¹ç›®ç›®å½•ï¼Œå®‰è£…æ‰€æœ‰å¿…éœ€çš„ä¾èµ–ã€‚

```bash
cd login-and-register

# ORMã€æ•°æ®åº“é©±åŠ¨å’Œé…ç½®ç®¡ç†
pnpm install @nestjs/typeorm typeorm mysql2 @nestjs/config

# å¯†ç åŠ å¯†
pnpm install bcrypt @types/bcrypt

# æ•°æ®æ ¡éªŒ
pnpm install class-validator class-transformer

# JWT é‰´æƒ
pnpm install @nestjs/jwt
```

---

## æ­¥éª¤äºŒï¼šé…ç½®ä¸æ•°æ®åº“é›†æˆ

### 1. ä½¿ç”¨ `.env` ç®¡ç†ç¯å¢ƒå˜é‡

å°†æ•æ„Ÿä¿¡æ¯ï¼ˆå¦‚æ•°æ®åº“å¯†ç ã€JWT å¯†é’¥ï¼‰ç¡¬ç¼–ç åœ¨ä»£ç ä¸­æ˜¯æå…¶å±é™©çš„ã€‚æˆ‘ä»¬ä½¿ç”¨ `.env` æ–‡ä»¶å’Œ `@nestjs/config` æ¥ç®¡ç†è¿™äº›é…ç½®ã€‚

åœ¨ `src` ç›®å½•ä¸‹åˆ›å»º `.env` æ–‡ä»¶ï¼š

```.env
# .env

# æ•°æ®åº“é…ç½®
DB_HOST=localhost
DB_PORT=3306
DB_USERNAME=root
DB_PASSWORD=your_database_password # æ›¿æ¢ä¸ºä½ çš„å¯†ç 
DB_DATABASE=login_system_prod

# JWT é…ç½®
JWT_SECRET=your-super-secret-key-that-is-long-and-random # æ›¿æ¢ä¸ºä¸€ä¸ªå¤æ‚çš„éšæœºå­—ç¬¦ä¸²
JWT_EXPIRES_IN=1d # Token æœ‰æ•ˆæœŸ
```

> **ğŸ”’ å®‰å…¨æç¤º**: æ°¸è¿œä¸è¦å°† `.env` æ–‡ä»¶æäº¤åˆ° Git ä»“åº“ï¼è¯·åŠ¡å¿…å°†å…¶æ·»åŠ åˆ° `.gitignore` æ–‡ä»¶ä¸­ã€‚

### 2. å¼‚æ­¥åŠ è½½é…ç½®æ¨¡å—

ç°åœ¨ï¼Œæˆ‘ä»¬æ¥é…ç½® `AppModule`ï¼Œè®©å®ƒèƒ½å¼‚æ­¥åŠ è½½å¹¶ä½¿ç”¨æˆ‘ä»¬çš„ç¯å¢ƒå˜é‡ã€‚

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserModule } from './user/user.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true, // å…¨å±€å¯ç”¨
      envFilePath: `src/.env`, // .env æ–‡ä»¶è·¯å¾„
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        type: 'mysql',
        host: configService.get<string>('DB_HOST'),
        port: parseInt(configService.get<string>('DB_PORT') ?? '3306', 10),
        username: configService.get<string>('DB_USERNAME'),
        password: configService.get<string>('DB_PASSWORD'),
        database: configService.get<string>('DB_DATABASE'),
        autoLoadEntities: true, // è‡ªåŠ¨åŠ è½½å®ä½“
        synchronize: true, // å¼€å‘ç¯å¢ƒä½¿ç”¨ï¼Œç”Ÿäº§ç¯å¢ƒå»ºè®®å…³é—­
        logging: true,
      }),
    }),
    UserModule,
  ],
})
export class AppModule {}
```

> **ğŸ’¡ æœ€ä½³å®è·µ**: ä½¿ç”¨ `forRootAsync` å¯ä»¥ç¡®ä¿åœ¨æ¨¡å—é…ç½®å®Œæˆä¹‹å‰ï¼Œæ‰€æœ‰ä¾èµ–ï¼ˆå¦‚ `ConfigService`ï¼‰éƒ½å·²å‡†å¤‡å°±ç»ªã€‚

---

## æ­¥éª¤ä¸‰ï¼šæ„å»º User æ¨¡å—

### 1. åˆ›å»º User æ¨¡å—ã€å®ä½“å’Œ DTO

ä½¿ç”¨ Nest CLI å¿«é€Ÿç”Ÿæˆ `User` æ¨¡å—çš„éª¨æ¶ã€‚

```bash
nest g resource user --no-spec
```

è¿™ä¼šåˆ›å»º `User` æ¨¡å—ã€æ§åˆ¶å™¨ã€æœåŠ¡å’Œå®ä½“æ–‡ä»¶ã€‚

### 2. å®šä¹‰ User å®ä½“

ç¼–è¾‘ `src/user/entities/user.entity.ts`ï¼Œå®šä¹‰ `User` è¡¨çš„ç»“æ„ã€‚

```typescript
// src/user/entities/user.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
} from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true, length: 50, comment: 'ç”¨æˆ·å' })
  username: string;

  @Column({ length: 100, comment: 'å¯†ç ', select: false })
  password: string;

  @CreateDateColumn({ comment: 'åˆ›å»ºæ—¶é—´' })
  createTime: Date;

  @UpdateDateColumn({ comment: 'æ›´æ–°æ—¶é—´' })
  updateTime: Date;
}
```

### 3. é…ç½® UserModule

ç¡®ä¿ `UserModule` å¯¼å…¥äº† `TypeOrmModule.forFeature([User])`ï¼Œè¿™æ · `UserService` æ‰èƒ½æ³¨å…¥ `UserRepository`ã€‚

```typescript
// src/user/user.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UserService } from './user.service';
import { UserController } from './user.controller';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UserController],
  providers: [UserService],
})
export class UserModule {}
```

### 4. å®šä¹‰ DTO å¹¶æ·»åŠ æ ¡éªŒ

æ•°æ®ä¼ è¾“å¯¹è±¡ (DTO) ç”¨äºå®šä¹‰ API çš„æ•°æ®ç»“æ„ã€‚æˆ‘ä»¬ä½¿ç”¨ `class-validator` æ¥æ·»åŠ æ ¡éªŒè§„åˆ™ã€‚

```typescript
// src/user/dto/register.dto.ts
import { IsNotEmpty, MinLength } from 'class-validator';

export class RegisterDto {
  @IsNotEmpty({ message: 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º' })
  username: string;

  @IsNotEmpty({ message: 'å¯†ç ä¸èƒ½ä¸ºç©º' })
  @MinLength(6, { message: 'å¯†ç é•¿åº¦ä¸èƒ½å°‘äº 6 ä½' })
  password: string;
}

// src/user/dto/login.dto.ts
// (å†…å®¹ä¸ RegisterDto ç›¸åŒï¼Œä½†åœ¨å®é™…é¡¹ç›®ä¸­å¯èƒ½ä¸åŒ)
export class LoginDto extends RegisterDto {}
```

### 5. å…¨å±€å¯ç”¨æ ¡éªŒç®¡é“

ä¸ºäº†è®© DTO æ ¡éªŒç”Ÿæ•ˆï¼Œæˆ‘ä»¬éœ€è¦åœ¨ `main.ts` ä¸­å…¨å±€å¯ç”¨ `ValidationPipe`ã€‚

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // å…¨å±€å¯ç”¨æ ¡éªŒç®¡é“
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true, // è‡ªåŠ¨è¿‡æ»¤æ‰ DTO ä¸­æ²¡æœ‰å®šä¹‰çš„å±æ€§
      transform: true, // è‡ªåŠ¨å°†ä¼ å…¥çš„æ•°æ®è½¬æ¢ä¸º DTO å®ä¾‹
    }),
  );

  await app.listen(3000);
}
bootstrap();
```

---

## æ­¥éª¤å››ï¼šå®ç°æ ¸å¿ƒä¸šåŠ¡é€»è¾‘

### 1. ä¼˜åŒ– UserService

`UserService` è´Ÿè´£å¤„ç†æ‰€æœ‰ä¸ç”¨æˆ·ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘ï¼ŒåŒ…æ‹¬å¯†ç åŠ å¯†å’Œæ•°æ®åº“æ“ä½œã€‚

```typescript
// src/user/user.service.ts
import {
  Injectable,
  HttpException,
  Logger,
  HttpStatus,
  UnauthorizedException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UserService {
  private readonly logger = new Logger(UserService.name);

  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  async register(
    registerDto: RegisterDto,
  ): Promise<Omit<User, 'password'>> {
    const existingUser = await this.userRepository.findOne({
      where: { username: registerDto.username },
    });

    if (existingUser) {
      throw new HttpException('ç”¨æˆ·å·²å­˜åœ¨', HttpStatus.CONFLICT);
    }

    const hashedPassword = await bcrypt.hash(registerDto.password, 10);

    const newUser = this.userRepository.create({
      username: registerDto.username,
      password: hashedPassword,
    });

    try {
      const savedUser = await this.userRepository.save(newUser);
      const { password, ...result } = savedUser;
      return result;
    } catch (error) {
      this.logger.error(error);
      throw new HttpException('æ³¨å†Œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  async login(loginDto: LoginDto): Promise<User> {
    const user = await this.userRepository
      .createQueryBuilder('user')
      .addSelect('user.password')
      .where('user.username = :username', { username: loginDto.username })
      .getOne();

    if (!user) {
      throw new UnauthorizedException('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯');
    }

    const isPasswordMatching = await bcrypt.compare(
      loginDto.password,
      user.password,
    );

    if (!isPasswordMatching) {
      throw new UnauthorizedException('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯');
    }

    return user;
  }
}
```

> **ğŸ”’ å®‰å…¨æç¤º**:
> *   **å¯†ç å“ˆå¸Œ**: æˆ‘ä»¬ä½¿ç”¨ `bcrypt` å¯¹å¯†ç è¿›è¡ŒåŠ ç›å“ˆå¸Œï¼Œè¿™æ˜¯å½“å‰æœ€å®‰å…¨çš„å¯†ç å­˜å‚¨æ–¹å¼ä¹‹ä¸€ã€‚
> *   **ç»Ÿä¸€é”™è¯¯æç¤º**: åœ¨ç™»å½•æ—¶ï¼Œæ— è®ºæ˜¯ç”¨æˆ·åä¸å­˜åœ¨è¿˜æ˜¯å¯†ç é”™è¯¯ï¼Œéƒ½è¿”å›ç›¸åŒçš„é”™è¯¯ä¿¡æ¯ï¼Œä»¥é˜²æ­¢æ”»å‡»è€…é€šè¿‡å“åº”æ¥çŒœæµ‹ç”¨æˆ·åæ˜¯å¦æœ‰æ•ˆï¼ˆç”¨æˆ·æšä¸¾æ”»å‡»ï¼‰ã€‚

### 2. å®ç° UserController

`UserController` è´Ÿè´£å¤„ç† HTTP è¯·æ±‚ï¼Œè°ƒç”¨ `UserService` å¹¶è¿”å›å“åº”ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†é›†æˆ JWT çš„ç­¾å‘ã€‚

é¦–å…ˆï¼Œåœ¨ `UserModule` ä¸­å¯¼å…¥å¹¶é…ç½® `JwtModule`ã€‚

```typescript
// src/user/user.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
// ... å…¶ä»–å¯¼å…¥

@Module({
  imports: [
    TypeOrmModule.forFeature([User]),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN'),
        },
      }),
    }),
  ],
  // ...
})
export class UserModule {}
```

ç„¶åï¼Œæ›´æ–° `UserController`ã€‚

```typescript
// src/user/user.controller.ts
import {
  Controller,
  Post,
  Body,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { UserService } from './user.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { JwtService } from '@nestjs/jwt';

@Controller('auth') // è·¯ç”±å‰ç¼€æ”¹ä¸º 'auth' æ›´ç¬¦åˆè¯­ä¹‰
export class UserController {
  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
  ) {}

  @Post('register')
  async register(@Body() registerDto: RegisterDto) {
    return await this.userService.register(registerDto);
  }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(@Body() loginDto: LoginDto) {
    const user = await this.userService.login(loginDto);
    const payload = { sub: user.id, username: user.username };

    return {
      access_token: await this.jwtService.signAsync(payload),
    };
  }
}
```

---

## æ­¥éª¤äº”ï¼šè·¯ç”±ä¿æŠ¤ä¸é‰´æƒ

### 1. åˆ›å»º AuthGuard

æˆ‘ä»¬éœ€è¦ä¸€ä¸ª `Guard` æ¥ä¿æŠ¤éœ€è¦ç™»å½•æ‰èƒ½è®¿é—®çš„è·¯ç”±ã€‚å®ƒä¼šæ£€æŸ¥è¯·æ±‚å¤´ä¸­æ˜¯å¦åŒ…å«æœ‰æ•ˆ
çš„ JWTã€‚

```bash
nest g guard auth --no-spec --flat
```

å®ç° `AuthGuard` çš„é€»è¾‘ã€‚

```typescript
// src/auth.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { Request } from 'express';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      throw new UnauthorizedException('æœªæä¾›è®¤è¯ä»¤ç‰Œ');
    }

    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: this.configService.get<string>('JWT_SECRET'),
      });
      // å°† payload æŒ‚è½½åˆ°è¯·æ±‚å¯¹è±¡ä¸Š
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException('ä»¤ç‰Œæ— æ•ˆæˆ–å·²è¿‡æœŸ');
    }
    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

### 2. åˆ›å»º Profile æ¥å£

è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªéœ€è¦ç™»å½•æ‰èƒ½è®¿é—®çš„æ¥å£æ¥æµ‹è¯• `AuthGuard`ã€‚

åœ¨ `UserController` ä¸­æ·»åŠ ä¸€ä¸ª `getProfile` æ–¹æ³•ã€‚

```typescript
// src/user/user.controller.ts
import { Controller, Post, Body, HttpCode, HttpStatus, UseGuards, Get, Request } from '@nestjs/common';
import { AuthGuard } from '../auth.guard'; // å¯¼å…¥ AuthGuard

// ...

@Controller('auth')
export class UserController {
  // ... constructor å’Œå…¶ä»–æ–¹æ³•

  @UseGuards(AuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}
```

---

## æ­¥éª¤å…­ï¼šæµ‹è¯•ä½ çš„åº”ç”¨

ç°åœ¨ï¼Œä½ å¯ä»¥å¯åŠ¨åº”ç”¨å¹¶ä½¿ç”¨ Postman æˆ–å…¶ä»– API å·¥å…·è¿›è¡Œæµ‹è¯•äº†ã€‚

```bash
pnpm start:dev
```

1.  **æ³¨å†Œ**: `POST /auth/register`
2.  **ç™»å½•**: `POST /auth/login` (è·å– `access_token`)
3.  **è®¿é—®å—ä¿æŠ¤çš„è·¯ç”±**: `GET /auth/profile`
    *   **ä¸å¸¦ Token**: ä½ åº”è¯¥ä¼šæ”¶åˆ° `401 Unauthorized` é”™è¯¯ã€‚
    *   **å¸¦ä¸Š Token**: åœ¨è¯·æ±‚å¤´çš„ `Authorization` å­—æ®µä¸­æ·»åŠ  `Bearer <your_token>`ï¼Œä½ å°†èƒ½æˆåŠŸè·å–åˆ°ç”¨æˆ·ä¿¡æ¯ã€‚

---

## æ€»ç»“

æ­å–œï¼ä½ å·²ç»æˆåŠŸæ„å»ºäº†ä¸€ä¸ªåŒ…å«æ³¨å†Œã€ç™»å½•å’Œ JWT é‰´æƒåŠŸèƒ½çš„ NestJS åº”ç”¨ã€‚é€šè¿‡è¿™ä¸ªé¡¹ç›®ï¼Œæˆ‘ä»¬å®è·µäº†å¤šé¡¹ä¼ä¸šçº§å¼€å‘ä¸­çš„æœ€ä½³å®è·µï¼ŒåŒ…æ‹¬ï¼š

*   **é…ç½®å¤–éƒ¨åŒ–**: ä½¿ç”¨ `.env` å’Œ `@nestjs/config` ç®¡ç†æ•æ„Ÿä¿¡æ¯ã€‚
*   **å®‰å…¨å¯†ç å­˜å‚¨**: ä½¿ç”¨ `bcrypt` è¿›è¡Œå¯†ç åŠ ç›å“ˆå¸Œã€‚
*   **å¥å£®çš„è¾“å…¥æ ¡éªŒ**: ä½¿ç”¨ `class-validator` å’Œ `ValidationPipe`ã€‚
*   **æ¨¡å—åŒ–è®¾è®¡**: æ¸…æ™°åœ°åˆ†ç¦»äº†ä¸šåŠ¡é€»è¾‘ã€æ•°æ®è®¿é—®å’Œè·¯ç”±æ§åˆ¶ã€‚
*   **åŸºäº Guard çš„é‰´æƒ**: å®ç°äº†å¯å¤ç”¨çš„è·¯ç”±ä¿æŠ¤æœºåˆ¶ã€‚

å¸Œæœ›è¿™ç¯‡æ•™ç¨‹èƒ½ä¸ºä½ åç»­çš„ NestJS å¼€å‘ä¹‹æ—…æ‰“ä¸‹åšå®çš„åŸºç¡€ã€‚

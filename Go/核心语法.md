## 1. 变量 (Variables)

Go 是静态强类型语言，变量声明清晰明了。

### 声明方式

1.  **标准声明**：使用 `var` 关键字，格式为 `var 变量名 类型`。
2.  **类型推断**：省略类型，编译器根据右值自动推导。
3.  **短变量声明**：使用 `:=`。这是 Go 最常用的写法，但**只能在函数内部使用**。

### 作用域与批量声明

*   **作用域**：函数内定义的变量是局部变量；函数外定义的是包级变量。
*   **批量声明**：使用 `var()` 块可以一次性声明多个变量，常用于全局配置。

```go
package main

import "fmt"

// 批量声明包级变量
var (
    Version  = "1.0.0"
    IsActive = true
)

func main() {
    // 1. 标准声明 (默认初始化为零值，int 为 0)
    var a int
    a = 10

    // 2. 类型推断
    var b = "Hello"

    // 3. 短变量声明 (推荐在函数内使用)
    // 注意：:= 左侧必须至少有一个新变量
    c := 3.14
    name, age := "Alice", 30

    fmt.Printf("a: %d, b: %s, c: %.2f\n", a, b, c)
    fmt.Printf("User: %s, Age: %d\n", name, age)
}
```

## 2. 常量 (Constants)

常量在编译期确定，定义后不可修改。

### iota 枚举

Go 没有专门的 `enum` 关键字，而是通过 `const` 配合 `iota` 计数器来实现枚举。`iota` 在 `const` 关键字出现时被重置为 0，每新增一行常量声明，`iota` 自动加 1。

```go
package main

import "fmt"

const (
    // iota = 0
    Sunday = iota 
    // iota = 1
    Monday        
    // iota = 2
    Tuesday       
)

const (
    _  = iota             // 跳过 0
    KB = 1 << (10 * iota) // 1 << (10*1) = 1024
    MB                    // 1 << (10*2)
    GB                    // 1 << (10*3)
)

func main() {
    fmt.Println("Monday:", Monday) // 输出: 1
    fmt.Println("MB:", MB)         // 输出: 1048576
}
```

## 3. 基础数据类型 (Basic Data Types)

Go 的基础类型非常直观，但需注意其**强类型**特性。

*   **布尔型**: `bool` (true/false)。
*   **整型**: `int` (根据平台为 32 或 64 位), `int8`, `int64`, `uint` 等。
*   **浮点型**: `float32`, `float64` (默认推荐)。
*   **字符串**: `string` (不可变字节序列，UTF-8 编码)。

**关键点**：Go 不支持隐式类型转换。不同类型之间（即使是 `int` 和 `int64`）必须显式转换。

```go
package main

import "fmt"

func main() {
    var i int = 42
    var f float64 = float64(i) // 必须显式转换
    var u uint = uint(f)

    // 字符串拼接
    str := "Go" + "lang"
    
    fmt.Println(i, f, u, str)
}
```

## 4. 控制流程 (Control Flow)

Go 的控制流简洁且强大，去掉了 `while`，增强了 `if` 和 `switch`。

### if-else

`if` 可以在判断条件前执行一个简单的初始化语句，该语句中定义的变量作用域仅限于 `if` 块内。

```go
if err := doSomething(); err != nil {
    // err 仅在这里有效
    fmt.Println("Error:", err)
} else {
    fmt.Println("Success")
}
```

### for 循环

Go 只有 `for` 一种循环关键字，但它能覆盖所有场景。

```go
// 1. 标准形式
for i := 0; i < 5; i++ {
    fmt.Println(i)
}

// 2. 类 while 形式
n := 0
for n < 5 {
    n++
}

// 3. 无限循环
for {
    // 需要配合 break 跳出
    break
}
```

### switch

Go 的 `switch` 默认自带 `break`，匹配成功即停止。

*   **fallthrough**: 强制执行下一个 case（不判断条件）。
*   **无表达式 switch**: 替代冗长的 `if-else` 链。

```go
score := 85

// 无表达式 switch
switch {
case score >= 90:
    fmt.Println("A")
case score >= 80:
    fmt.Println("B")
default:
    fmt.Println("C")
}
```

## 5. 复合数据结构 (Composite Data Structures)

### 数组 (Arrays)

数组是**定长**的，长度是类型的一部分。`[3]int` 和 `[4]int` 是不同类型。数组是值类型，传递时会发生拷贝。

```go
var arr [3]int = [3]int{1, 2, 3}
```

### 切片 (Slices) —— 核心重点

切片是对底层数组的**引用**，它是动态的，包含三个要素：指针、长度 (`len`)、容量 (`cap`)。

*   **创建**: 使用 `make` 或字面量。
*   **扩容**: `append` 向切片追加元素。如果容量不足，Go 会自动分配更大的底层数组并复制数据。
*   **截取**: `slice[low:high]`，左闭右开。

```go
package main

import "fmt"

func main() {
    // 使用 make 创建: make([]Type, len, cap)
    s := make([]int, 0, 5)
    
    // append 追加元素
    s = append(s, 1, 2, 3)
    fmt.Printf("Len: %d, Cap: %d\n", len(s), cap(s)) // Len: 3, Cap: 5

    // 再次追加，触发扩容
    s = append(s, 4, 5, 6)
    fmt.Printf("Len: %d, Cap: %d\n", len(s), cap(s)) // Cap 通常翻倍

    // 切片截取
    sub := s[1:3] // 获取索引 1 到 2 的元素
    fmt.Println("Sub:", sub)
}
```

### Map (映射)

无序的键值对集合。

*   **初始化**: `make(map[KeyType]ValueType)`。
*   **安全取值**: 使用 `value, ok := map[key]` 模式判断键是否存在，避免零值混淆。

```go
package main

import "fmt"

func main() {
    // 初始化
    m := map[string]int{
        "apple": 5,
        "banana": 10,
    }

    // 插入或更新
    m["orange"] = 8

    // 删除
    delete(m, "banana")

    // 安全取值 (Comma ok idiom)
    if val, ok := m["apple"]; ok {
        fmt.Println("Apple price:", val)
    }

    // 遍历 (顺序不固定)
    for k, v := range m {
        fmt.Printf("%s -> %d\n", k, v)
    }
}
```

## 6. 指针 (Pointers)

Go 保留了指针，但去除了复杂的指针运算（如 `ptr++`），既保证了性能又兼顾了安全。

### 为什么使用指针？

1.  **修改外部变量**: 函数默认是值传递，若想修改外部变量，需传地址。
2.  **性能优化**: 传递大型结构体时，传指针（地址）比拷贝整个结构体更高效。

### 语法

*   `&`: 取地址。
*   `*`: 解引用（取指针指向的值）。

```go
package main

import "fmt"

// 参数是指针类型
func addOne(n *int) {
    *n = *n + 1 // 修改指针指向的值
}

func main() {
    x := 10
    fmt.Println("Before:", x)

    // 传递 x 的地址
    addOne(&x)
    
    fmt.Println("After:", x) // 输出: 11
}
```

---

**结语：**

以上就是 Go 语言最核心的语法骨架。你会发现，Go 没有繁复的语法糖，它强迫你写出清晰、可预测的代码。建议你动手敲一遍上面的示例，感受 Go 的简洁之美。

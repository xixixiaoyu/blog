# 写作提示 —— 函数调用安全与沙箱

使用说明：
- 生成函数调用（Tool/Function Calling）的安全与沙箱指南，避免越权与危险操作。

生成目标：
- 设计工具权限模型与白/黑名单；参数校验与资源限制（CPU/内存/IO）。
- 采用沙箱/隔离执行环境（例如子进程、VM、容器、远程服务）。
- 提供审计与告警机制；记录调用链与异常。

大纲建议：
1. 权限与策略（可用工具列表、范围与限制）
2. 参数与输入校验（类型、范围、正则与过滤）
3. 执行环境隔离（沙箱、子进程、远程代理）
4. 资源与超时（CPU/内存/IO 限制、取消与超时）
5. 审计与告警（日志字段、异常模式）
6. 风险与演练（红队测试、越权尝试与防御）

输出格式要求：
- Markdown；附最小沙箱执行示例与权限配置模板。
- 给出审计日志字段与阈值建议。

质量检查清单：
- 权限模型明确；危险操作隔离与限制有效。
- 有审计与告警；可定位与追责。
- 兼顾用户体验与安全边界。

默认技术栈：TypeScript + NestJS

工具注册与权限模型（白名单 + 参数校验）：

依赖：`npm i zod execa`

```ts
// src/tools/registry.ts
import { z } from 'zod';
import { execa } from 'execa';

type ToolDef = {
  name: string;
  schema: z.ZodTypeAny;
  exec: (args: any, ctx: { tenantId: string }) => Promise<any>;
  allowTenants?: string[]; // 可选租户白名单
};

export const Tools: Record<string, ToolDef> = {
  shell_ls: {
    name: 'shell_ls',
    // 仅允许在特定目录列出文件（避免通配与危险参数）
    schema: z.object({ path: z.string().regex(/^\/safe\/[a-zA-Z0-9_\/.-]+$/) }),
    async exec(args) {
      // 使用 execa，禁用 shell，设置超时与最小资源控制
      const p = await execa('ls', ['-la', args.path], { shell: false, timeout: 2000 });
      return { stdout: p.stdout };
    },
    allowTenants: ['tenantA'],
  },
};

export function getTool(name: string): ToolDef | undefined { return Tools[name]; }
```

沙箱执行与审计（Interceptor 示例）：

```ts
// src/tools/interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, ForbiddenException } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class ToolAuditInterceptor implements NestInterceptor {
  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const req = context.switchToHttp().getRequest();
    req.audit = { ts: Date.now(), ip: req.ip, ua: req.headers['user-agent'] };
    return next.handle();
  }
}
```

控制器：校验 + 权限 + 超时 + 审计日志

```ts
// src/tools.controller.ts
import { Controller, Post, Body, UseInterceptors, ForbiddenException } from '@nestjs/common';
import { z } from 'zod';
import { getTool } from './tools/registry';

const InvokeSchema = z.object({ name: z.string(), args: z.any() });

@Controller('tools')
@UseInterceptors(ToolAuditInterceptor)
export class ToolsController {
  @Post('invoke')
  async invoke(@Body() body: unknown) {
    const { name, args } = InvokeSchema.parse(body); // 输入校验
    const tool = getTool(name);
    if (!tool) throw new ForbiddenException('Tool not allowed');
    // 权限校验（按租户）
    const tenantId = 'tenantA'; // 伪代码：来自鉴权中间件
    if (tool.allowTenants && !tool.allowTenants.includes(tenantId)) {
      throw new ForbiddenException('Tenant not allowed to call this tool');
    }
    // 参数校验
    const parsed = tool.schema.parse(args);

    // 执行与超时保护（exec 内部已限制 timeout）
    const start = Date.now();
    try {
      const result = await tool.exec(parsed, { tenantId });
      // 审计日志（示例字段）
      return {
        ok: true,
        tool: name,
        durationMs: Date.now() - start,
        result,
        audit: { ip: '...', ua: '...' }, // 来自 Interceptor
      };
    } catch (e) {
      // 记录异常与告警（省略）
      throw e;
    }
  }
}
```

风险与隔离建议（文字版）：
- 对危险操作（执行任意脚本、文件写入、网络访问）使用远程隔离服务（容器/Firecracker），通过队列或 RPC 调用，网关仅转发；
- 对所有工具使用 Schema 校验与白名单配置；禁用通配参数与复杂表达式；
- 资源限制：超时（2s-5s）、输出大小上限（例如 64KB）、并发上限；
- 演练与红队：定期对越权尝试与注入进行测试，记录并修复策略空洞。

审计日志字段建议：
- `tenantId`、`userId`、`toolName`、`argsDigest`（参数摘要）、`durationMs`、`status`、`errorCode`、`resourceUsed`（如 CPU/ms、内存峰值）、`ip`、`ua`。

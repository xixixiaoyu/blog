# 写作提示 —— 向量数据库选型与检索工程

使用说明：
- 生成面向 RAG 的检索工程指南，覆盖库选型、索引、分块、混合检索与重排序。

生成目标：
- 对比常见向量存储（Faiss、Milvus、pgvector、Elastic/OpenSearch、SQLite 扩展）。
- 给出索引与分片策略、分块（大小/重叠/层级）与元数据设计。
- 介绍混合检索（向量 + BM25）、MMR/交叉编码器（Cross-Encoder）重排序。
- 提供更新与维护流程（增量索引、删除、TTL、去重与版本化）。

大纲建议：
1. 选型维度（精度、性能、维护成本、生态）
2. Schema 与元数据（来源、标题、标签、段落层级）
3. 分块与切片策略（大小、重叠、页面/章节）
4. 索引与查询（ANN、参数、过滤与多字段查询）
5. 混合检索与重排序（BM25、MMR、Cross-Encoder）
6. 更新与数据治理（增量、删除、TTL、去重）
7. 监控与评估（检索覆盖率、相关性、答案质量影响）

输出格式要求：
- Markdown；提供最小端到端示例（构建索引 → 检索 → 重排）。
- 标注依赖与版本；给出评估指标与报表建议。

质量检查清单：
- 示例可运行或易于运行；指标能衡量检索有效性。
- 明确分块与索引策略的权衡与常见坑。
- 有更新维护与数据治理闭环。

默认栈建议：
- 索引与检索服务：Python + FastAPI（Faiss/Milvus/pgvector/OpenSearch 生态丰富、评估工具齐全）
- 网关与前端集成：TypeScript + NestJS（统一接口、流式回答与引用渲染）

接口契约（示例）：
- 请求：`POST /search`，Body：`{ query: string, topK?: number, filters?: Record<string, any> }`
- 响应：`{ matches: Array<{ id: string, score: number, text: string, meta: Record<string, any> }>, usage?: { embedding_tokens?: number } }`

NestJS 调用 FastAPI 检索服务（REST 示例）

依赖：`npm i @nestjs/axios`；Python 侧请提供 `/search` 接口。

```ts
// src/rag.service.ts
import { Injectable } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';

@Injectable()
export class RagService {
  constructor(private readonly http: HttpService) {}

  async search(query: string, topK = 5) {
    const res$ = this.http.post('http://localhost:8001/search', { query, topK });
    const { data } = await firstValueFrom(res$);
    return data.matches as Array<{ id: string; score: number; text: string; meta: any }>;
  }
}
```

NestJS 控制器将检索结果与 LLM 回答融合（伪代码）：

```ts
// src/rag.controller.ts
import { Controller, Post, Body } from '@nestjs/common';
import { RagService } from './rag.service';
import OpenAI from 'openai';

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

@Controller('rag')
export class RagController {
  constructor(private readonly rag: RagService) {}

  @Post('answer')
  async answer(@Body() body: { question: string }) {
    const matches = await this.rag.search(body.question, 5);
    const context = matches.map((m, i) => `[${i + 1}] ${m.text}`).join('\n');
    const msg = `Answer the question using the context with citations [1..N].\nQuestion: ${body.question}\nContext:\n${context}`;
    const completion = await openai.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
      messages: [{ role: 'user', content: msg }],
    });
    const text = completion.choices[0]?.message?.content ?? '';
    return { text, matches };
  }
}
```

Milvus/pgvector 直连（可选）：
- Milvus Node SDK：`npm i @zilliz/milvus2-sdk-node`，通过 `search` 接口检索；适合将 NestJS 直接作为检索层。
- pgvector：建议由 Python 侧维护索引与相似度查询（SQL/ANN 扩展）；NestJS 以 REST/gRPC 方式调用，减少类型适配复杂度。

评估与监控（文字版）：
- 检索覆盖率（命中率）、相关性指标（nDCG、MRR）与答案质量（Hallucination 率）。
- 记录分块策略与参数（大小、重叠）对质量的影响，形成报表；定期重建或增量更新索引。
- 日志字段：`queryLen`、`topK`、`filters`、`latencyMs`、`hits`、`rerankModel`；监控异常模式与缓存命中率。

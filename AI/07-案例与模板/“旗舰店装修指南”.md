
# 写作提示 —— 构建“AI 原生”用户体验：一本“AI UI 组件库”设计指南

**核心类比**：将为 AI 应用构建前端界面的过程，类比为设计和实现一个“AI 原生的 UI 组件库”。这个组件库的目标，是像 `shadcn/ui` 或 `Material-UI` 一样，将 AI 应用中独特的、复杂的交互模式（如流式生成、工具调用、多模态输入）封装成声明式、可组合、易于使用的 React/Vue 组件，从而赋能整个开发团队，快速构建出优雅、一致的 AI 用户体验。

**使用说明**：
- 本提示旨在将 AI 前端开发，从临时的、面向过程的“集成工作”，提升为系统的、面向组件的“设计与工程实践”。
- 你需要以“前端架构师”或“UI 库核心开发者”的口吻，为团队撰写这份《AI UI 组件库设计与实现白皮书》。

**生成目标**：
- **建立“组件化”思维**：将 AI 交互的每一个环节，都视为一个可以被抽象和封装的“组件”或“Hook”。例如，`useChat` Hook 负责管理对话状态和 API 调用，`<StreamingResponse />` 组件负责优雅地渲染流式文本。
- **推广“无头组件（Headless UI）”模式**：将组件的“逻辑”与“视图”分离。提供一个包含所有交互逻辑的 `useChat` Hook，但允许开发者自由地定制 UI，而不是被限定在某个固定的外观里。这极大地提升了组件库的灵活性和可复用性。
- **引入“乐观更新（Optimistic UI）”**：为了追求极致的响应速度，在向服务器发送用户消息后，不等真实响应返回，立即在 UI 上显示用户的消息。这为用户创造了一种“即时”的交互错觉，是现代 Web 应用的核心体验之一。
- **设计“AI 交互状态机”**：将一次完整的 AI 交互（从用户输入 -> 等待响应 -> 工具调用 -> 流式生成 -> 完成）建模为一个健壮的有限状态机（State Machine）。这使得处理复杂的加载、错误和中间状态变得清晰、可预测。
- **提供“可组合的 API”**：组件库的 API 设计应遵循“高内聚、低耦合”的原则，让开发者可以像搭乐高一样，自由组合各种功能。例如，`useChat` Hook 可以接受一个 `tools` 参数来动态添加可用的前端工具。

**大纲建议：《“Nexus AI” UI 组件库：设计原则与实现指南》**

1.  **第一章：引言 —— AI 交互需要自己的“设计语言”**
    *   阐述为何不能简单地将传统 UI 组件用于 AI 应用，以及构建一个专门的 AI UI 库的必要性。
    *   对标 `Vercel AI SDK`，介绍本组件库的核心理念：将 AI 交互的复杂性封装在简单的 React Hooks 和组件背后。

2.  **第二章：核心引擎：`useChat` Hook 的设计与实现**
    *   **状态管理**：如何使用 `useReducer` 或 `XState` 来管理复杂的对话状态机（`idle`, `loading`, `streaming`, `error`）。
    *   **API 交互**：如何封装 `fetch` 请求，处理流式响应（ReadableStream），并实时更新消息列表。
    *   **乐观更新**：展示如何在用户提交消息时，立即将其添加到本地状态中。
    *   **代码示例 (React/TypeScript)**：提供一个简化的 `useChat` Hook 实现，清晰地展示其核心逻辑。

3.  **第三章：构建可复用的“AI 组件”**
    *   **`<StreamingResponse />`**：一个接收流式数据并以打字机效果渲染的组件。
    *   **`<ToolStatus />`**：一个用于实时展示后端工具调用状态（开始、结束、成功、失败）的组件。
    *   **`<MarkdownRenderer />`**：一个支持代码高亮、数学公式和自定义组件的 Markdown 渲染器。
    *   **“无头”实践**：展示如何将 `<ChatWindow />` 分解为一个 `useChat` Hook 和一个纯粹的 UI 组件，让开发者可以“自带 UI”。

4.  **第四章：高级模式：处理工具调用与多模态**
    *   **前端工具调用**：`useChat` Hook 如何管理一个前端可用的工具列表，并在 LLM 请求时，自动执行并返回结果。
    *   **多模态输入**：设计一个 `<MultiModalInput />` 组件，它允许用户同时输入文本、上传图片和录制音频，并将其统一编码后发送。

5.  **第五章：性能与可访问性**
    *   **性能优化**：使用 `React.memo` 和 `useCallback` 避免不必要的重渲染。
    *   **可访问性 (a11y)**：确保所有组件都符合 WAI-ARIA 标准，例如，为动态更新的内容添加 `aria-live` 属性。

**质量检查清单**：
- **抽象是否优雅？**：`useChat` Hook 的 API 是否足够简洁、直观，能够隐藏底层的复杂性？
- **是否遵循现代前端最佳实践？**：是否恰当地运用了 Hooks、无头组件、状态机和乐观更新等现代前端模式？
- **代码是否具有生产价值？**：提供的 TypeScript 代码示例是否类型安全、逻辑严谨，可以直接用于生产项目？
- **是否赋能而非限制？**：“无头”和“可组合”的设计，是否真正地将 UI 的控制权交还给了应用开发者？

# 写作提示 —— 鉴权与配额

使用说明：
- 生成服务端与前端在 AI 应用中的鉴权与配额控制指南，强调安全与可运维性。

生成目标：
- 总结 API Key 管理、令牌发放、RBAC、租户隔离、配额与计费的基本模型。
- 给出前后端分离场景下的安全实践（服务端代理、密钥不下发到前端）。
- 提供可观测与审计方案（使用量、异常、风控）。

大纲建议：
1. 身份与凭证（API Key、JWT、签名）
2. 权限模型与租户（RBAC、ABAC、隔离策略）
3. 配额与速率（限流、日/月额度、告警与封禁）
4. 前端安全实践（不下发密钥、短期令牌、后端代理）
5. 审计与风控（日志、异常检测、滥用与防御）
6. 合规与隐私（最小权限、加密与存储）

输出格式要求：
- Markdown；附最小鉴权与配额中间件示例（Node/Nest）。
- 给出仪表板或日志字段建议（文字版）。

质量检查清单：
- 方案可实施，前后端职责清晰。
- 配额与限流策略可观测、可调整。
- 兼顾安全与用户体验，不泄露敏感信息。

默认技术栈：TypeScript + NestJS

API Key Guard（最小示例）：

```ts
// src/api-key.guard.ts
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from '@nestjs/common';

@Injectable()
export class ApiKeyGuard implements CanActivate {
  async canActivate(ctx: ExecutionContext) {
    const req = ctx.switchToHttp().getRequest();
    const key = req.headers['x-api-key'] as string | undefined;
    if (!key) throw new UnauthorizedException('Missing API key');
    // TODO: 校验 key（数据库/配置中心），可包含租户与配额信息
    const tenant = await lookupTenantByKey(key); // 伪代码
    if (!tenant) throw new UnauthorizedException('Invalid API key');
    req.tenant = tenant;
    return true;
  }
}
```

配额与速率（每租户限流，Throttler 或 rate-limiter-flexible）：

```ts
// src/quota.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, TooManyRequestsException } from '@nestjs/common';
import { Observable } from 'rxjs';
import { RateLimiterMemory } from 'rate-limiter-flexible';

const limiter = new RateLimiterMemory({ points: 60, duration: 60 }); // 每 60s 允许 60 点

@Injectable()
export class QuotaInterceptor implements NestInterceptor {
  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const req = context.switchToHttp().getRequest();
    const key = req.tenant?.id ?? 'anonymous';
    try {
      await limiter.consume(key, 1);
      return next.handle();
    } catch {
      throw new TooManyRequestsException('Quota exceeded');
    }
  }
}
```

控制器接入：

```ts
// src/llm.controller.ts
import { Controller, Post, Body, UseGuards, UseInterceptors } from '@nestjs/common';
import { ApiKeyGuard } from './api-key.guard';
import { QuotaInterceptor } from './quota.interceptor';

@Controller('llm')
@UseGuards(ApiKeyGuard)
@UseInterceptors(QuotaInterceptor)
export class LlmController {
  @Post('chat')
  async chat(@Body() body: { prompt: string }) {
    return { text: '...' };
  }
}
```

前端安全实践（文字版）：
- 不下发上游供应商密钥到前端；所有调用经由后端代理。
- 使用短期令牌（JWT）标识用户，会话与租户；后端校验签名与权限。
- 重要操作（函数调用、工具执行）启用审计日志与风控策略。

审计与风控（日志字段建议）：
- `tenantId`、`userId`、`endpoint`、`model`、`tokensIn/out`、`quotaUsed`、`statusCode`、`errorCode`、`latencyMs`、`ip`、`ua`。
- 异常模式识别：使用量骤增、错误率异常、敏感操作频繁；触发告警与封禁策略。

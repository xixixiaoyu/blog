
# Master Prompt: 将 AI 请求管理类比为“运营一家餐厅厨房”

## 1. 核心目标 (Core Goal)

你是一位资深的餐厅经理兼后厨总管（后端架构师），你的任务是为一群经验丰富的厨师（后端工程师）撰写一本“现代化厨房运营手册”。这本手册将指导他们如何设计一个高效、有序的后厨系统，以应对从“单人快餐”到“百人宴席”等各种复杂的顾客点餐需求（AI API 请求）。

**核心类比**：
- **AI 网关/服务**: 一家繁忙的“**餐厅**”。
- **API 请求**: 顾客的“**点菜单**”。
  - **交互式聊天**: “单人快餐”订单，追求最快的上菜速度 (低延迟)。
  - **后台批处理**: “大型宴席”订单，可以提前预定，对总完成时间有要求，但对首道菜的速度不敏感。
  - **Embedding 请求**: 大量的“炸薯条”订单，可以合并成一大锅一起炸，以提高效率。
- **后厨系统 (Your Backend)**: 整个餐厅的“**厨房**”。
- **并发控制策略**: 厨房的“**运营规则**”。
  - **速率限制 (Rate Limiting)**: 餐厅门口的“**领位员**”，控制客流总数，防止厨房被瞬间涌入的订单压垮。
  - **并发队列 (Concurrency Queue)**: 厨房的“**订单队列看板**”。厨师（GPU）数量有限，新订单按优先级在此排队等待处理。
  - **批处理 (Batching)**: “**炸薯条工作站**”，积累多个订单后，一次性炸一大筐，分发给不同餐桌。
  - **超时与取消 (Timeout & Cancellation)**: 顾客等太久决定“**取消订单**”，或厨房发现食材不够“**主动退单**”。

本文的目标是提供一套源于真实世界、符合直觉的工程方法论，将抽象的并发控制问题，转化为具体的、可管理的厨房运营流程。

## 2. 文章结构 (Article Structure)

**I. 标题：AI 服务性能告急？像运营餐厅厨房一样管理你的请求！**

**II. 引言：从“路边摊”到“米其林三星后厨”**
   - 痛点：当你的 AI 应用用户量激增，简单的“接单做菜”模式会导致厨房混乱、顾客抱怨（服务超时、错误频发）。
   - 解决方案：引入专业的“后厨管理体系”，系统性地解决订单（请求）的接收、排队、处理和交付问题。

**III. 厨房运营第一课：门口的“领位员” (速率限制)**
   - **类比**：速率限制器就是餐厅的门卫和领位员，它的职责不是服务顾客，而是保护厨房不被冲垮。
   - **工具选型**：`@nestjs/throttler` (for NestJS), `express-rate-limit` (for Express)。
   - **实践指南 (Code Snippet)**：演示如何设置全局速率限制（餐厅总容量）和特定路由的限制（VIP 包厢有特殊规则）。

**IV. 核心工作流：“订单队列看板” (并发队列)**
   - **类比**：并发队列是后厨的核心。厨师（GPU/模型实例）数量是固定的，所有订单都必须先上看板排队。
   - **工具选型**：`p-queue`。它是一个功能强大的异步任务队列库。
   - **实践指南 (Code Snippet)**：
     - 创建一个并发数（厨师数量）固定的队列。
     - **优先级调度**：演示如何让“单人快餐”（高优交互任务）插队到“大型宴席”（低优批处理任务）前面。
     ```javascript
     import PQueue from 'p-queue';

     const queue = new PQueue({ concurrency: 10 }); // 厨房里有 10 位厨师

     // 用户聊天请求，高优先级
     queue.add(() => handleChat(request), { priority: 10 });

     // 夜间报告生成，低优先级
     queue.add(() => generateReport(data), { priority: 1 });
     ```

**V. 增效秘诀：“炸薯条工作站” (请求批处理)**
   - **类比**：对于 Embedding 这类可合并的任务，就像炸薯条。单独为每个订单炸一份效率极低。聪明的做法是等几分钟，凑一筐一起炸。
   - **工具选型**：`dataloader` (Facebook 出品) 或 `rxjs` 的 `bufferTime`。
   - **实践指南 (Code Snippet)**：
     - 使用 `dataloader` 演示如何自动将单个的 Embedding 请求合并成一个对上游 API 的批量调用。
     - 解释批处理的两个关键参数：`maxBatchSize` (炸筐的最大容量) 和 `window` (最长等待时间)。

**VI. 异常处理：“顾客退单”与“厨房劝退” (超时与取消)**
   - **类比**：健壮的厨房必须能处理各种意外。`AbortController` 就是顾客和厨房之间的“取消信号”。
   - **实践指南**：
     - **客户端取消**：当前端组件卸载时，如何通过 `AbortSignal` 取消一个正在队列中等待或正在处理的请求，释放“厨师”资源。
     - **服务端超时**：为每个“烹饪”步骤设置超时，防止某个“难做的菜”卡住一位“厨师”太久。
     - **重试策略**：当上游 API (供应商) 返回 `429` (太忙) 或 `5xx` (服务错误) 时，如何像一个有经验的服务员一样，礼貌地让顾客稍等片刻再试（指数退避）。

**VII. 监控仪表盘：“后厨作战室”**
   - **类比**：在厨房的墙上挂一个巨大的电子屏幕，实时显示运营数据。
   - **关键指标 (Metrics)**：
     - `queue_length`: 等位的订单数。
     - `queue_wait_time`: 订单平均等待时长。
     - `active_concurrency`: 在岗厨师数。
     - `ttft` (Time to First Food): 从下单到第一道菜上桌的时间。
   - **告警 (Alerts)**：当“平均等位时间超过 5 分钟”或“取消订单率超过 10%”时，立即向餐厅经理（你）发送警报。

## 3. 质量与风格核对清单 (Quality & Style Checklist)

- [ ] **类比一致性**：“餐厅厨房”的类比是否贯穿始终，且每个技术点的映射都清晰自然？
- [ ] **场景驱动**：是否为每种并发策略都提供了一个具体的“厨房”场景？
- [ ] **代码实用性**：提供的代码片段是否可以直接用于构建一个真实的 Node.js/NestJS 服务？
- [ ] **系统性思维**：是否清晰地展示了速率限制、队列、批处理和异常处理如何组合成一个完整的系统？
- [ ] **可观测性**：是否提供了具体、可操作的监控指标和告警建议，帮助工程师量化“厨房”的健康状况？

# 写作提示 —— 多提供商适配与降级策略

使用说明：
- 生成聚合多模型供应商的路由与降级方案，保障稳定性、成本与性能。

生成目标：
- 设计统一接口与参数规范；支持基于能力与成本的路由策略（加权/优先级）。
- 给出降级路径（能力退化、上下文长度缩减、非流式替代）。
- 实现健康检查、熔断、重试与回退（Failover）。

大纲建议：
1. 聚合层接口设计（统一参数与响应）
2. 路由策略（加权、优先级、按任务/模型选择）
3. 降级与回退（能力、质量与成本的权衡）
4. 熔断与重试（退避策略、配额限制）
5. 监控与治理（健康检查、SLO/SLI、报表）
6. 密钥管理与安全（代理层、租户隔离、审计）

输出格式要求：
- Markdown；附最小路由与降级示例代码。
- 提供配置与参数建议，支持快速调整。

质量检查清单：
- 路由与降级方案可落地，能应对供应商波动。
- 有观测与熔断机制，避免雪崩效应。
- 权限与配额管理到位，安全合规。

默认技术栈（聚合层）：TypeScript + NestJS

最小可运行路由示例（NestJS Service）

依赖：`npm i cockatiel @nestjs/throttler`

```ts
// src/provider-router.service.ts
import { Injectable } from '@nestjs/common';
import { Policy, RetryPolicy, CircuitBreakerPolicy, ConsecutiveBreaker, TimeoutPolicy } from 'cockatiel';

type Provider = 'openai' | 'anthropic' | 'vllm' | 'ollama';

interface RouteConfig {
  weights: Record<Provider, number>; // 加权路由
  priority: Provider[];              // 回退优先级
}

@Injectable()
export class ProviderRouterService {
  private retry = RetryPolicy.handleAll().exponential({ maxAttempts: 2 });
  private timeout = TimeoutPolicy.timeout(30_000);
  private breaker = CircuitBreakerPolicy.handleAll({
    halfOpenAfter: 10_000,
    breaker: new ConsecutiveBreaker(5),
  });

  async routeAndCall<T>(cfg: RouteConfig, call: (p: Provider) => Promise<T>): Promise<T> {
    const pick = this.pickByWeight(cfg.weights) ?? cfg.priority[0];
    const policies = Policy.wrap(this.timeout, this.breaker, this.retry);

    try {
      return await policies.execute(() => call(pick));
    } catch (e) {
      // 回退链路
      for (const p of cfg.priority) {
        if (p === pick) continue;
        try {
          return await policies.execute(() => call(p));
        } catch {}
      }
      throw e;
    }
  }

  private pickByWeight(weights: Record<Provider, number>): Provider | undefined {
    const entries = Object.entries(weights) as Array<[Provider, number]>;
    const sum = entries.reduce((s, [, w]) => s + w, 0);
    let r = Math.random() * sum;
    for (const [p, w] of entries) {
      if ((r -= w) <= 0) return p;
    }
    return undefined;
  }
}
```

控制器接入与限流（Throttler）：

```ts
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ThrottlerModule } from '@nestjs/throttler';
import { ProviderRouterService } from './provider-router.service';

@Module({
  imports: [
    ThrottlerModule.forRoot({
      ttl: 60, // 秒
      limit: 120, // 每分钟每租户最大请求数（示例）
    }),
  ],
  providers: [ProviderRouterService],
})
export class AppModule {}
```

```ts
// src/aggregate.controller.ts
import { Controller, Post, Body, UseGuards } from '@nestjs/common';
import { ThrottlerGuard } from '@nestjs/throttler';
import { ProviderRouterService } from './provider-router.service';

@Controller('aggregate')
@UseGuards(ThrottlerGuard)
export class AggregateController {
  constructor(private readonly router: ProviderRouterService) {}

  @Post('chat')
  async chat(@Body() body: { prompt: string }) {
    const cfg = {
      weights: { openai: 0.6, anthropic: 0.2, vllm: 0.15, ollama: 0.05 },
      priority: ['openai', 'anthropic', 'vllm', 'ollama'] as const,
    };
    const result = await this.router.routeAndCall(cfg, async (p) => {
      // 根据 provider 实际调用（伪代码）
      if (p === 'openai') return callOpenAI(body.prompt);
      if (p === 'anthropic') return callAnthropic(body.prompt);
      if (p === 'vllm') return callVLLM(body.prompt);
      return callOllama(body.prompt);
    });
    return { provider: result.provider, content: result.content };
  }
}
```

降级路径示例（文字版）：
- 能力降级：函数调用失败 → 纯文本回答；多模态不可用 → 文本替代。
- 上下文裁剪：输入过长 → 摘要/引用压缩，逐段对话。
- 流式替代：上游无流式 → 代理层分片缓冲，模拟增量输出（150ms）。

健康检查与观测要点：
- 对每个 provider 记录成功率、延迟、错误分类（429/5xx/超时）。
- breaker 开关状态与半开次数；重试次数与退避参数。
- 配额与速率：按租户/用户维度统计；配额逼近时提前告警与降速。

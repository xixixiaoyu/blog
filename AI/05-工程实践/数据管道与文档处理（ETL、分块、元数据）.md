# 写作提示 —— AI 工厂之“原材料”：数据管道与文档处理

**核心类比**：将 RAG 应用的数据处理流程，比作“AI 工厂”的“原材料供应链与仓储系统”。整个流程的目标是，将来自不同“供应商”（数据源）的、形态各异的“原材料”（文档），通过一条自动化的“加工流水线”（ETL 管道），转化为符合生产标准的“零件”（分块后的文本），并贴上清晰的“规格标签”（元数据），最终送入“自动化立体仓库”（向量数据库）中，以备“生产线”（RAG 模型）随时调用。

**使用说明**：
- 本提示旨在生成一份关于 RAG 数据管道的权威指南，覆盖从数据采集到最终入库的全过程。
- 你需要以“AI 工厂供应链经理”的口吻，将数据工程的复杂概念，转化为生动、具体的工厂运营流程。

**生成目标**：
- **建立自动化流水线**：设计一条从“卸货”（抽取）到“入库”（加载）的全自动化数据处理管道。
- **定义标准化工艺**：明确“清洗”、“切割”（分块）和“贴标”（元数据）的工艺标准，确保所有“零件”的质量和一致性。
- **构建智能仓库**：解释“自动化立体仓库”（向量数据库）的工作原理，以及它如何实现对“零件”的快速、精准检索。
- **实现库存管理**：引入增量更新、版本化和去重机制，实现对“仓库库存”的高效管理和成本控制。

**大纲建议：《AI 工厂：原材料供应链与仓储管理手册》**

1.  **第一章：供应链的哲学 —— 原材料决定产品质量**
    *   引入“原材料供应链”类比，强调数据质量是 RAG 应用效果的基石。
    *   论证一条稳定、高效、可治理的数据管道，是“AI 工厂”成功的先决条件。

2.  **第二章：采购与卸货 —— 从多样的供应商获取原材料（数据抽取）**
    *   介绍如何从不同的“供应商”处获取原材料，例如：
        *   **网页**：网络爬虫，如同派出采购机器人。
        *   **PDF/Markdown**：文件上传，如同接收供应商直送的货箱。
        *   **API**：从合作伙伴的系统中直接同步数据。

3.  **第三章：质检与标准化加工 —— 清洗、切割与贴标（ETL）**
    *   **清洗车间**：去除原材料中的“杂质”（如 HTML 标签、格式噪声、无关信息）。
    *   **切割车间（分块）**：将大块原材料“切割”成标准尺寸的“零件”。讨论不同的切割策略（固定大小、按章节、语义分块）及其适用场景。
    *   **贴标车间（元数据）**：为每个“零件”贴上详细的“规格标签”，如 `来源`、`批次号`、`章节`、`作者` 等，为后续的精准检索和引用提供依据。

4.  **第四章：入库 —— 构建自动化立体仓库（向量数据库）**
    *   解释“仓库”的核心功能：将“零件”的特征（通过 Embedding 模型）转化为可以在高维空间中度量的“坐标”。
    *   描述“入库”流程：将带有“坐标”和“标签”的“零件”存放到仓库的货架上。
    *   强调仓库的检索效率（`search`）直接决定了工厂的“生产节拍”。

5.  **第五章：库存管理与追溯 —— 增量、版本化与去重**
    *   **增量更新**：建立机制，只加工和更新那些发生变化的“原材料”，避免全量重复劳动。
    *   **版本化与去重**：为每个“零件”建立唯一的身份标识（`source + hash`），并记录其版本号。这确保了库存的准确性，并能在“产品”出现问题时，快速“追溯”到是哪个批次的“零件”导致的问题。

6.  **第六章：连接工厂仪表板 —— 供应链的监控与治理**
    *   **连接监控**：将“原材料”的加工状态（如 `处理数量`、`失败率`、`延迟`）和“库存”的质量指标（`覆盖率`、`新鲜度`）实时上报给“AI 任务控制中心”。
    *   **自动警报**：当“质检车间”发现大量不合格原材料，或“传送带”发生堵塞时，立即在“控制中心”触发警报，通知“供应链经理”介入处理。

**质量检查清单（供应链审核清单）**：
- **供应链是否稳定？**：我们能否从所有数据源可靠、持续地获取数据？
- **加工工艺是否标准？**：每个“零件”在入库前，是否都经过了严格的清洗、切割和贴标流程？
- **仓库检索是否高效？**：我们能否在生产高峰期，依然快速、准确地为生产线提供所需零件？
- **库存管理是否精细？**：我们是否清楚库存中每个零件的版本和来源，并能避免不必要的存储和计算浪费？
- **监控是否到位？**：当供应链的任何一个环节出现问题时，我们能否在第一时间发现并响应？

---
*保留并重构原有内容，将其作为实现“原材料加工与仓储”流程的具体技术实现细节和代码示例。*
---

NestJS 接口契约与调用示例：

```ts
// src/pipeline.service.ts
import { Injectable } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';

@Injectable()
export class PipelineService {
  constructor(private readonly http: HttpService) {}

  async ingest(items: Array<{ id: string; text: string; meta?: Record<string, string> }>) {
    const res$ = this.http.post('http://localhost:8001/ingest', items);
    return (await firstValueFrom(res$)).data;
  }

  async index() {
    const res$ = this.http.post('http://localhost:8001/index', {});
    return (await firstValueFrom(res$)).data;
  }

  async search(query: string, topK = 5) {
    const res$ = this.http.post('http://localhost:8001/search', { query, topK });
    return (await firstValueFrom(res$)).data.matches as Array<{ id: string; score: number; text: string; meta: any }>;
  }
}
```

分块与元数据建议（文字版）：
- 分块大小：普通文本 500-1000 tokens；代码/表格适当缩小；保持 10-20% 重叠；
- 层级：文档 → 章节 → 段落 → 片段；存储层保持层级与来源引用；
- 元数据：`source`、`title`、`section`、`tags`、`lang`、`updatedAt`；为检索过滤与引用渲染服务。

增量与版本化：
- 变更检测：基于哈希/ETag；只更新变更片段；
- 去重：按 `source+hash` 唯一键；维护 `version` 与 `status`（active/deleted）
- 回放：保留历史版本用于评估回归与解释。

监控与治理（字段建议）：
- `docCount`、`chunkCount`、`avgChunkSize`、`embedLatencyMs`、`indexLatencyMs`、`errorRate`；
- 数据质量抽样：随机抽查片段覆盖率与相关性；
- 失败重试：指数退避与死信队列；记录失败原因与次数。

# 写作提示 —— 日志、监控与评测

使用说明：
- 生成可落地的观测与评测方案，覆盖提示日志、响应日志、错误与性能指标。

生成目标：
- 给出日志字段建议（会话 ID、用户 ID、提示、响应、耗时、Token、错误码）。
- 说明监控指标（延迟、吞吐、错误率、成本）与告警策略。
- 提供离线/在线评测方案与回归数据集维护方式。

大纲建议：
1. 观测目标与数据治理（隐私、合规、最小保留）
2. 日志字段设计与采集位置（前端/后端）
3. 监控指标与告警（SLO/SLI，阈值与异常模式）
4. 评测与回归（数据集、Rubric、自动判分）
5. 问题定位与复盘（重现实验、版本对比）
6. 可视化与报表（仪表板与定期回顾）

输出格式要求：
- Markdown；给出最小埋点与报表示例（文字版或伪代码）。
- 明确隐私与合规处理（脱敏、匿名化）。

质量检查清单：
- 观测与评测方案能在工程内落地。
- 有隐私与合规保护；采集最小化原则。
- 指出回归与改进的闭环机制。

---

默认技术栈与目标
- 后端：TypeScript + NestJS（结构化日志 + 指标）
- 观测出口：ELK（日志检索与仪表盘）/ OpenTelemetry OTLP（时序指标与追踪）
- 评测：离线集（可回放）+ 在线打分（灰度），与 LLMOps 平台联动（参见《LLMOps 与评估框架（LangSmith、Ragas、DeepEval）》）

1. 观测目标与数据治理（隐私、合规、最小保留）
- 最小化采集：默认不保存完整提示/响应；对关键样本开启抽样 1%-5% 且脱敏。
- 脱敏策略：PII（姓名、电话、邮箱、证件号）用正则/规则标注并替换为占位符；保留哈希摘要以便定位。
- 数据保留期：原始日志 7-30 天；聚合指标长期保留；符合当地法规（GDPR/CCPA）。
- 访问控制：仅 SRE/合规角色可查看原始样本；产品与研发使用聚合视图。

2. 日志字段设计与采集位置（前端/后端）
- 建议字段：
  - 关联：`traceId`、`spanId`、`sessionId`、`conversationId`、`userId`、`tenantId`
  - 模型：`provider`、`model`、`temperature`、`topP`、`toolsUsed`
  - 成本：`inputTokens`、`outputTokens`、`costUsd`
  - 性能：`latencyMs`、`ttftMs`（首标记耗时）
  - 结果：`status`（ok/error）、`errorCode`、`retryCount`
  - 合规模型：`toxicityScore`、`hallucinationFlag`（可选）
- 采集位置：
  - 前端：TTFT/渲染延迟、取消事件、网络错误；避免完整提示，使用 `promptDigest`（SHA256）
  - 后端：请求入/出、供应商返回、重试与降级、缓存命中与 miss、成本计算

3. NestJS 结构化日志（拦截器示例）
```ts
// src/common/logging.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable, tap } from 'rxjs';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const req = context.switchToHttp().getRequest();
    const start = Date.now();
    const base = {
      ts: new Date().toISOString(),
      method: req.method,
      path: req.url,
      traceId: req.headers['x-trace-id'],
      tenantId: req.user?.tenantId,
    };
    return next.handle().pipe(
      tap((data) => {
        const log = {
          ...base,
          provider: data?.provider,
          model: data?.model,
          inputTokens: data?.metrics?.inputTokens,
          outputTokens: data?.metrics?.outputTokens,
          costUsd: data?.metrics?.costUsd,
          latencyMs: Date.now() - start,
          status: data?.status ?? 'ok',
        };
        // 结构化输出（推荐接入 pino/winston，再由 Filebeat/Fluentd 采集到 ELK）
        console.log(JSON.stringify(log));
      }),
    );
  }
}
```

4. OpenTelemetry 指标埋点（Node SDK + 自定义度量）
```ts
// src/observability/metrics.ts
import { MeterProvider } from '@opentelemetry/sdk-metrics';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';

const exporter = new OTLPMetricExporter({ url: process.env.OTLP_METRIC_URL });
const meterProvider = new MeterProvider({});
meterProvider.addMetricReader(new (require('@opentelemetry/sdk-metrics').PeriodicExportingMetricReader)({ exporter, exportIntervalMillis: 10000 }));
export const meter = meterProvider.getMeter('ai-app');

export const reqLatency = meter.createHistogram('llm.request.latency', { description: 'LLM request latency (ms)' });
export const inputTokens = meter.createCounter('llm.tokens.input', { description: 'input token count' });
export const outputTokens = meter.createCounter('llm.tokens.output', { description: 'output token count' });
export const costUsd = meter.createCounter('llm.cost.usd', { description: 'request cost in USD' });
```
在业务代码中：
```ts
// 伪代码：完成一次模型调用后
reqLatency.record(durationMs, { provider, model });
inputTokens.add(metrics.inputTokens ?? 0, { provider, model });
outputTokens.add(metrics.outputTokens ?? 0, { provider, model });
costUsd.add(metrics.costUsd ?? 0, { provider, model });
```

5. 监控指标与告警（SLO/SLI）
- 核心 SLI：
  - 延迟：`p50/p95 llm.request.latency`（区分无流/流式 TTFT）
  - 可用性：`errorRate`（5xx + 供应商错误） ≤ 1%-3%
  - 吞吐：`RPS`、并发 `in-flight`
  - 成本：`costUsd`/日；`tokens`/日；预算告警
- 告警策略：
  - 延迟 p95 超阈（如 > 5s）持续 5 分钟；
  - 错误率 > 3% 持续 3 分钟；
  - 成本日预算消耗 > 80% 提醒；> 95% 紧急降级（走低成本模型、收紧 Context）。
- 看板建议：按 provider/model 分层展示延迟/错误率/成本趋势；显示最近变更与实验（A/B）。

6. 日志到 ELK 的管道
- 应用日志用 pino（`asObject: true`）输出 JSON；Filebeat 采集到 Logstash；统一字段 Schema（ecs/自定义）。
- 建仪表盘：
  - 每日成本与 tokens；
  - 延迟与错误率（分供应商/模型）；
  - 缓存命中率；重试次数与降级触发率；
  - 合规模型（toxicity/hallucination）趋势。

7. 离线/在线评测与回归
- 数据集维护：
  - 格式：`id`, `question`, `context(optional)`, `expected(optional)`, `tags`。
  - 版本：为每次评测记录模型版本、提示版本、路由策略版本。
- 自动化评分（示例伪代码）：
```ts
// 使用评测模型进行打分（建议用低成本模型+校正规则）
async function scoreAnswer(question: string, answer: string) {
  const rubric = '评估回答与问题的相关性(0-1), 准确性(0-1), 结构(0-1)';
  // 调用评分模型（略），返回 { relevance: 0.8, faithfulness: 0.7, style: 0.6 }
}
```
- 指标汇总：每次回放生成 `avgScores`、`passRate`、`regressionCases`，并入库；构建对比页面（旧策略 vs 新策略）。
- 在线灰度：10%-30% 流量走新策略，实时观察延迟/错误率/质量分；达标后扩大覆盖。

8. 问题定位与复盘
- 保留必要上下文：提示摘要、检索片段摘要、模型/路由版本、关键参数；
- 重现实验：在测试环境回放请求（固定随机种子、固定检索集）；
- 复盘模板：问题描述 -> 影响范围 -> 根因 -> 修复方案 -> 防回归措施；

9. 隐私与合规处理（操作要点）
- 脱敏库：PII 模型 + 规则；日志写入前统一执行 `redact()`；
- 匿名化：用户标识采用租户内哈希；敏感内容仅在隔离环境可见；
- 数据主体权利：支持删除请求；日志系统按标识清除；

10. 最小埋点与报表示例（文字版）
- 最小埋点：后端输出 `provider/model/tokens/cost/latency/status`；前端输出 `ttft/abort`；
- 每日报表：
  - 成本：总成本、按 provider 分摊、TOP 路由/模型；
  - 性能：p95 延迟、错误率；
  - 质量：平均得分、回归用例数；
  - 风险：滥用检测数（违规提示/输出），已触发的降级次数。

附：与分布式追踪的结合
- 使用 `traceparent` 从前端透传到网关（参见《OpenTelemetry 与分布式追踪》）；
- 为 SSE/WS 会话创建 Span，并在日志中记录 `traceId`，实现跨层关联。

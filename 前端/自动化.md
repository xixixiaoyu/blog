### 一、 为什么前端需要自动化？
在回答“学什么”之前，我们先明确“为什么”。典型的前端自动化场景包括：
*   **项目初始化**：`git clone` 后，自动安装依赖、拷贝环境配置文件、启动开发服务器。
*   **开发流程**：代码保存后自动格式化、语法检查、运行单元测试。
*   **构建部署**：一键执行代码打包、版本号管理、静态资源上传 CDN、部署到服务器。
*   **质量保障**：在 Git 提交前，自动检查代码规范，阻止不规范的代码进入仓库。
*   **日常杂务**：批量处理图片、生成图标字体、同步多环境数据等。

---

### 二、 自动化工具链：从 Shell 到现代前端生态

你可以将它们视为一个工具箱，不同工具解决不同层级的问题。

#### 1. 基础层：Shell 脚本（理解核心概念）

你不需要成为 Bash 专家，但必须理解其核心概念，因为它是所有自动化工具的基石。

*   **学什么**：
    *   **基本命令**：`cd`, `ls`, `cp`, `mv`, `rm`, `mkdir`, `cat`, `grep`。这些是操作文件系统的基础。
    *   **环境变量**：`$PATH` 是什么？如何设置临时 (`KEY=value`) 和永久（在 `~/.zshrc` 或 `~/.bash_profile` 中）的环境变量。
    *   **退出码**：`$?`。命令成功返回 `0`，失败返回非 `0`。这是判断脚本步骤是否成功的依据。
    *   **逻辑操作符**：`&&`（成功才执行下一步），`||`（失败才执行下一步）。例如：`npm run build && npm run deploy`。
    *   **管道 `|`**：将一个命令的输出作为另一个命令的输入。例如：`cat log.txt | grep "Error"`。

*   **何时使用**：
    *   在服务器上执行简单的文件操作或部署任务。
    *   编写极其简单、不依赖 Node.js 环境的初始化脚本。

*   **示例**：
    ```bash
    #!/bin/bash
    # deploy.sh - 一个非常简单的部署脚本示例
    
    echo ‘开始构建...’
    npm run build
    
    if [ $? -eq 0 ]; then
      echo ‘构建成功，开始部署...’
      # 假设你有一个部署工具
      my-deploy-tool ./dist
    else
      echo ‘构建失败，请检查错误！’
      exit 1
    fi
    ```

#### 2. 核心层：Node.js 脚本（你的主战场）

既然前端项目本身就运行在 Node.js 环境，用它来写自动化脚本是最自然、最强大的选择。

*   **学什么**：
    *   **`child_process` 模块**：这是关键。学会使用 `exec` 或 `execSync` 来执行 Shell 命令。
    *   **`fs` 模块**：用于读写、操作文件，比 Shell 命令更精细、更可靠。
    *   **`path` 模块**：处理文件路径，避免跨平台（Windows/macOS/Linux）的路径问题。

*   **何时使用**：绝大多数前端自动化任务。你可以利用整个 npm 生态系统的能力。

*   **示例**：
    ```javascript
    // scripts/deploy.js
    const { execSync } = require(‘child_process’)
    const fs = require(‘fs’)
    const path = require(‘path’)
    
    console.log(‘开始构建...’)
    try {
      // 执行 npm 脚本
      execSync(‘npm run build’, { stdio: ‘inherit’ })
      
      // 读取构建结果
      const distPath = path.join(__dirname, ‘../dist’)
      if (fs.existsSync(distPath)) {
        console.log(‘构建成功，开始部署...’)
        execSync(‘my-deploy-tool ./dist’, { stdio: ‘inherit’ })
      } else {
        throw new Error(‘dist 目录不存在，构建可能失败了’)
      }
    } catch (error) {
      console.error(‘脚本执行失败:’, error)
      process.exit(1)
    }
    ```
    在 `package.json` 中配置：`"deploy": "node scripts/deploy.js"`。

#### 3. 任务运行器：npm scripts（首选）与 Gulp

*   **npm scripts**：**这是你首先应该掌握并深度使用的工具**。它直接利用操作系统 Shell，能调用所有本地安装的 CLI 工具。
    *   **优势**：简单、直接、无额外依赖、生态强大。
    *   **技巧**：
        *   使用 `pre` 和 `post` 钩子（如 `prebuild`, `postbuild`）。
        *   使用 `--` 传递参数（如 `npm run test -- --watch`）。
        *   使用工具如 `concurrently` 并行运行任务，`npm-run-all` 顺序运行任务。
    *   **示例**：
        ```json
        {
          "scripts": {
            "build": "webpack --mode=production",
            "lint": "eslint . --ext .js,.ts",
            "test": "jest",
            "precommit": "npm run lint && npm run test",
            "dev": "concurrently \"npm run server\" \"npm run watch\""
          }
        }
        ```

*   **Gulp**：基于流的任务运行器。适用于需要精细控制文件处理流程的复杂任务（如图片压缩、字体生成）。
    *   **何时使用**：当 npm scripts 的“命令拼接”模式变得难以维护时，Gulp 的代码化配置是更好的选择。

#### 4. Git Hooks：自动化质量关卡
**核心工具：Husky + lint-staged**
这是现代前端项目的标配，用于在提交代码前自动执行检查。
*   **Husky**：让你能方便地在 `package.json` 中配置 Git hooks。
*   **lint-staged**：只对 **Git 暂存区** 的文件（即本次提交的文件）运行检查，效率极高。
*   **配置示例** (`package.json`)：
    ```json
    {
      "lint-staged": {
        "*.{js,ts,vue}": ["eslint --fix", "prettier --write"]
      },
      "scripts": {
        "prepare": "husky install"
      }
    }
    ```
    这会在每次 `git commit` 时，自动修复 JS/TS/Vue 文件的代码风格和格式问题。

---

### 三、 学习路径与建议

1.  **第一步：精通 npm scripts**。
    *   把你项目中手动的构建、测试步骤，用 `npm run <script>` 串联起来。
    *   学习使用 `pre`/`post` 钩子和参数传递。

2.  **第二步：引入 Git Hooks 自动化代码质量**。
    *   在下一个项目中立刻配置 `Husky` 和 `lint-staged`，这是投入产出比最高的实践。

3.  **第三步：用 Node.js 编写复杂脚本**。
    *   当你发现某个 `npm script` 长得像一长串“咒语”时，就是时候把它写成一个 `scripts/your-script.js` 文件了。
    *   学习 `child_process.execSync` 和 `fs` 模块的基本用法。

4.  **第四步：了解 Shell 基础**。
    *   为了读懂和编写简单的 `.sh` 文件，以便在服务器或 Docker 容器中发挥作用。

5.  **进阶：学习 Gulp 或更复杂的 CI/CD（如 GitHub Actions, Jenkins）**。
    *   当你的项目有非常复杂的资源处理流水线时，再考虑 Gulp。
    *   CI/CD 是现代软件工程的必备知识，它将自动化从你的本地扩展到整个团队。

---

### 思考题

回顾你当前或之前参与的项目，有没有哪些重复、繁琐的步骤是可以通过上述的某一种工具实现自动化的？如果让你来改进，你会从哪一步开始？

希望这份梳理能帮助你构建起清晰的学习地图。
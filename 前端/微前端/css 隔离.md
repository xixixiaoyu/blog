微前端的 CSS 隔离，本质上是**防止子应用间的样式相互污染**。

我们可以从「作用域限制」这个第一性原理出发，把方案分为两大类：**构建时隔离** 与 **运行时隔离**。

### 一、构建时隔离（推荐首选）

这类方案在代码编译阶段就限制选择器的作用范围，**无运行时开销，最可靠**。

####  **CSS Modules**

```js
// 构建工具（如 webpack）会将类名哈希化
import styles from './app.css' // .container -> .app_container_3a7b

// 模板中通过对象引用
<div className={styles.container}>
```

构建时自动将类名/ID 局部化，生成唯一标识。

自动化、无性能损耗、支持样式组合（composes）。但是仅隔离类名和 ID，无法隔离标签选择器（如 `body {}`）；需构建工具支持。

适合尤其是 React、Vue 等组件化新项目。

#### **BEM / 手动命名空间**

```css
/* 约定式前缀 */
.app1-container {}
.app2-header {}
```

通过人为约定给所有选择器加前缀，形成逻辑命名空间。

简单，无技术门槛。但是容易出错，无法隔离第三方库样式。

适合快速验证、遗留项目改造，或作为其他方案的补充。

#### **PostCSS 插件自动加前缀**

```js
// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-prefix-selector')({
      prefix: '.app1',
      exclude: ['.app1']
    })
  ]
}
```

构建时自动为所有选择器添加前缀。

自动化程度高，对源码无侵入。但是需改造子应用构建配置；复杂选择器（如 `:global()`）可能处理不当。

适合需要接入不可控的第三方子应用时。



### 二、运行时隔离（特殊场景备用）

这类方案在浏览器中动态限制样式作用域，**有性能开销，但灵活性高**。




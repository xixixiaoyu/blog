微前端的 CSS 隔离，本质上是**防止子应用间的样式相互污染**。

我们可以从「作用域限制」这个第一性原理出发，把方案分为两大类：**构建时隔离** 与 **运行时隔离**。

### 一、构建时隔离（推荐首选）

这类方案在代码编译阶段就限制选择器的作用范围，**无运行时开销，最可靠**。

####  **CSS Modules**

```js
// 构建工具（如 webpack）会将类名哈希化
import styles from './app.css' // .container -> .app_container_3a7b

// 模板中通过对象引用
<div className={styles.container}>
```

构建时自动将类名/ID 局部化，生成唯一标识。

自动化、无性能损耗、支持样式组合（composes）。但是仅隔离类名和 ID，无法隔离标签选择器（如 `body {}`）；需构建工具支持。

适合尤其是 React、Vue 等组件化新项目。

#### **BEM / 手动命名空间**

```css
/* 约定式前缀 */
.app1-container {}
.app2-header {}
```

通过人为约定给所有选择器加前缀，形成逻辑命名空间。

简单，无技术门槛。但是容易出错，无法隔离第三方库样式。

适合快速验证、遗留项目改造，或作为其他方案的补充。

#### **PostCSS 插件自动加前缀**

```js
// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-prefix-selector')({
      prefix: '.app1',
      exclude: ['.app1']
    })
  ]
}
```

构建时自动为所有选择器添加前缀。

自动化程度高，对源码无侵入。但是需改造子应用构建配置；复杂选择器（如 `:global()`）可能处理不当。

适合需要接入不可控的第三方子应用时。



### 二、运行时隔离（特殊场景备用）

这类方案在浏览器中动态限制样式作用域，**有性能开销，但灵活性高**。

#### **Shadow DOM（Web Components）**

```js
const shadow = element.attachShadow({ mode: 'open' })
shadow.innerHTML = `<style>/* 完全隔离 */</style><div>...</div>`
```

浏览器原生隔离机制，样式只在 Shadow DOM 内部生效。**隔离最彻底**，真正的物理屏障。

但是**侵入性强**（需改造 DOM 结构）；调试困难；与 React 事件代理、Modal Portal 等机制有兼容性问题；样式共享困难。

#### **CSS-in-JS（如 styled-components, emotion）**

```js
const Container = styled.div`
  background: ${props => props.theme.bg}; /* 可动态化 */
`
```

运行时动态生成带唯一哈希的类名，实现局部作用域。

样式与组件强绑定，动态能力强；天然隔离。

但是**运行时性能开销**；可能导致 FOUC（闪烁）；依赖特定库；对非 React 生态不友好。

适用于需要动态主题、样式逻辑复杂的场景。

#### **iframe**

浏览器原生硬隔离，JS/CSS/DOM 完全独立。但是**体验割裂**（通信困难、路由不同步、UI 不统一、资源重复加载）。**这违背了微前端「体验一体化」的初衷**。

而且隔离不可控的、有安全风险的第三方内容（如旧系统页面）。**不推荐作为常规方案**。

#### **运行时样式沙箱（如 qiankun 的 `strictStyleIsolation`）**

```js
// qiankun 会动态为插入的 style 添加前缀
start({
  sandbox: { strictStyleIsolation: true }
})
```

JS 劫持 `document.head.appendChild`，为动态插入的 `<style>` 标签内容添加前缀或转换选择器。

对子应用无侵入，能处理动态插入的样式。

但是会有**性能损耗**；无法处理 `@keyframes`、`@font-face` 等；复杂选择器转换可能失败；非 100% 可靠。

而且无法改造子应用构建、且需隔离动态样式的兜底方案。



| 方案             | 隔离强度 | 性能  | 侵入性 | 可靠性 | 推荐度 |
| :--------------- | :------- | :---- | :----- | :----- | :----- |
| **CSS Modules**  | ⭐⭐⭐⭐     | ⭐⭐⭐⭐⭐ | ⭐⭐     | ⭐⭐⭐⭐⭐  | ⭐⭐⭐⭐⭐  |
| **BEM/命名空间** | ⭐⭐⭐      | ⭐⭐⭐⭐⭐ | ⭐⭐⭐    | ⭐⭐     | ⭐⭐⭐    |
| **PostCSS 前缀** | ⭐⭐⭐⭐     | ⭐⭐⭐⭐⭐ | ⭐⭐⭐    | ⭐⭐⭐⭐   | ⭐⭐⭐⭐   |
| **Shadow DOM**   | ⭐⭐⭐⭐⭐    | ⭐⭐⭐⭐  | ⭐⭐⭐⭐⭐  | ⭐⭐⭐⭐⭐  | ⭐⭐     |
| **CSS-in-JS**    | ⭐⭐⭐⭐     | ⭐⭐⭐   | ⭐⭐⭐    | ⭐⭐⭐⭐   | ⭐⭐⭐    |
| **iframe**       | ⭐⭐⭐⭐⭐    | ⭐⭐    | ⭐⭐⭐⭐⭐  | ⭐⭐⭐⭐⭐  | ⭐      |
| **运行时沙箱**   | ⭐⭐⭐⭐     | ⭐⭐⭐   | ⭐      | ⭐⭐⭐    | ⭐⭐⭐    |

**黄金法则：优先构建时，辅以运行时。**

**新项目**：**无脑上 CSS Modules**，配合组件化开发，这是性价比最高的方案。

遗留项目改造

- 若能改构建：用 **PostCSS 自动加前缀**。
- 若不能改构建：用 **BEM 约定** + **运行时沙箱**兜底。

样式共享**：将公共样式（主题、组件库）以 **CSS Custom Properties** 或 **JS 变量**形式下沉到基座应用，子应用通过变量引用，而非直接复用类名。

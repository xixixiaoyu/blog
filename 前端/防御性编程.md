后端程序通常运行在可控的服务器环境中，而前端代码则运行在成千上万用户**不可控**的设备与浏览器上。

不仅环境不可控，面对后端传递的数据和用户的输入也不可控，第三方依赖就更不可控了。

我们说些策略：

使用**可选链操作符 (?.) 和 空值合并操作符 (??)**：

```js
// 优雅地处理可能的 null 或 undefined
const userName = user?.profile?.name ?? '匿名用户'
const firstPost = user?.posts?.[0]?.content ?? '暂无内容'
```

**数据校验与类型守卫**：

```js
// 使用 TypeScript 接口定义期望的类型
interface User {
  profile: {
    name: string
  }
  posts: Array<{ content: string }>
}

// 在运行时进行校验（例如使用 Zod、Yup 等库）
function isValidUser(data) {
  return data 
    && typeof data?.profile?.name === 'string'
    && Array.isArray(data.posts)
}

if (isValidUser(apiResponse)) {
  // 现在可以安全地访问了
  const userName = apiResponse.profile.name
}
```

**参数默认值**：

```js
function formatUserInfo(user = {}) {
  return `用户名：${user.name ?? '未知'}，年龄：${user.age ?? '未知'}`
}
```

在函数开始处检查关键参数：

```js
function fetchData(url, options) {
  if (!url || typeof url !== 'string') {
    console.warn('无效的 URL 参数')
    return Promise.reject(new Error('Invalid URL'))
  }
  // ... 主逻辑
}
```

**异步加载与错误捕获**：

```js
// 使用 import() 动态导入，失败时可以降级
try {
  const module = await import('some-library')
  module.someFunction()
} catch (error) {
  console.error('库加载失败', error)
  // 执行备用方案
  fallbackFunction()
}
```

```js
async function apiRequest(url) {
  try {
    const response = await fetch(url)
    if (!response.ok) throw new Error(`HTTP ${response.status}`)
    return await response.json()
  } catch (error) {
    // 统一处理网络错误、超时、解析错误等
    showToast('网络似乎出了点问题，请重试')
    // 同时将错误上报给监控系统
    reportError(error)
    throw error // 根据情况决定是否继续向上抛出
  }
}
```


### 1. 纯客户端渲染（CSR）的“先天不足”
在没有 Next.js 或 Nuxt.js 的情况下，我们用 React 或 Vue 开发一个应用，通常是这样的流程：
1. 浏览器请求一个 URL，比如 `https://example.com`。
2. 服务器返回一个几乎空荡荡的 HTML 文件，里面只有一个 `<div id="root"></div>`，以及一个可能指向巨大 JavaScript 文件的链接。
3. 浏览器下载并执行这个 JavaScript 文件。
4. JavaScript 在浏览器里运行，生成页面内容，填充到 `div#root` 中，最终用户看到完整的页面。

这带来了两个致命问题：
- **首屏加载慢**：用户在看到内容前，需要经历“下载 JS → 执行 JS → 渲染页面”的漫长等待，体验很差，特别是网络不好或设备性能差的时候。
- **SEO（搜索引擎优化）不友好**：搜索引擎的爬虫访问你的网站时，它看到的是一个几乎没有内容的空 HTML。虽然现代爬虫有能力执行 JS，但效率低下且不可靠，导致你的页面很难被正确索引和排名。

### 2. Next.js/Nuxt.js 的核心解决方案：混合渲染
Next.js 和 Nuxt.js 的本质就是**将渲染过程部分（或全部）移到了服务器端**，并巧妙地结合了服务端渲染和客户端渲染的优点
它们的目标是：**让用户和爬虫第一眼就能看到完整的、内容丰富的页面。**
这个过程可以分为两个关键阶段：
**阶段一：首屏，服务端“精装修”**
当用户首次请求一个页面时：
1. 服务器接收到请求。
2. 服务器在后台运行 React 或 Vue 代码，**预先渲染出完整的 HTML 页面**。
3. 服务器将这个包含所有内容的 HTML 页面直接发送给浏览器。

**带来的好处立竿见影：**
- **首屏加载极快**：浏览器收到的是一个完整的页面，可以立即显示，用户无需等待 JS 加载。
- **对 SEO 极其友好**：爬虫看到的是一个内容饱满的 HTML 页面，可以轻松抓取和分析。

但是对服务器的计算资源有一定要求，因为每个请求都需要实时渲染，这可能会带来更高的服务器成本和稍高的响应延迟（TTFB，Time to First Byte）。

**阶段二：交互，客户端“智能化接管”**
当完整的 HTML 页面加载到浏览器后，事情还没完。Next/Nuxt 会在 HTML 中“注入”必要的 JavaScript（这个过程叫 Hydration，意为“注水”）。
1. 这段 JS 在后台静默执行，为已经渲染好的页面**绑定事件和交互逻辑**（比如按钮点击、表单提交等）。
2. 一旦“注水”完成，这个页面就从一张静态的“照片”变成了一个可以交互的、动态的 Web 应用。
3. 之后，用户在应用内点击链接跳转到其他页面时，就不再需要刷新整个页面了。框架会像传统的单页应用（SPA）一样，**只通过 JS 在客户端更新需要变化的部分**，实现快速、流畅的页面切换。

虽然首屏内容很快可见，但页面变得可交互（Time to Interactive, TTI）仍然需要等待 JS 下载、解析和执行完成。对于非常复杂的页面，Hydration 过程也可能消耗一定的客户端性能。 这也是 React 团队正在通过 Server Components 等技术努力优化的方向。
在现代框架（特别是 Next.js 13+ 的 App Router）中，“混合”渲染的含义更进了一步，它还意味着你可以在**同一个页面中混合使用不同的渲染策略**。比如，页面的主体框架是静态生成的（SSG），而某个需要实时数据的组件是服务端渲染的（SSR），另一个完全交互的组件是客户端渲染的（CSR）。这体现了更细粒度的控制力。

### 3. 基于这个核心，它们做的更多事情
解决了渲染这个根本问题后，Next.js 和 Nuxt.js 围绕它构建了一整套强大的生态系统，让开发变得更简单、更高效：
- **基于文件系统的路由**：你不需要手动配置路由。只要在 `pages` 或 `app` 目录下创建一个文件，它就自动成为一个页面路由。这极大地简化了开发。
- **多种数据获取策略**：它们提供了灵活的 API，让你可以**按需选择**每个页面的渲染方式。
    - **静态生成（SSG）**：在构建时就预渲染好页面，适合内容不经常变化的网站（如博客、文档、营销页），性能最佳。
    - **服务端渲染（SSR）**：每次请求时都在服务器渲染页面，适合内容高度个性化或需要实时数据的页面。
    - **增量静态再生（ISR）**：允许页面在构建时被静态生成，但可以设置一个过期时间（如每 60 秒），当有新请求到来且页面已过期时，服务器会在后台重新生成页面，这样既有静态页面的极速访问体验，又能保证内容在一定程度上保持更新。
- **API 路由**：允许你在同一个项目里编写后端 API 接口。这让你可以轻松构建“全栈应用”，而无需单独维护一个后端服务。
- **内置优化**：自动进行代码分割、图片优化、字体优化等，确保你的应用性能始终处于最佳状态。
即使在 Next.js/Nuxt.js 中，我们依然可以按需使用**纯客户端渲染（CSR）**。比如对于一个高度个性化且对SEO无要求的数据看板（Dashboard），我们完全可以让页面框架由服务端渲染，而内部的数据面板在客户端通过 useEffect 或 SWR 等方式获取，这同样是混合渲染思想的体现。

### 4. 注意事项
#### 4.1 时刻问自己“我的代码运行在何处？”
这是最重要的一点，也是一切问题的根源。在纯客户端渲染的应用中，你的 JavaScript 代码百分之百运行在用户的浏览器里。
但在 Next.js 或 Nuxt.js 中，你的代码可能运行在**两个完全不同的环境**：
- **服务端**：一个 Node.js 环境，用于预渲染页面。
- **客户端**：用户的浏览器环境，用于交互。

比如你的代码里可能使用了 `window`、`document`、`localStorage` 等浏览器独有的全局 API。当这段代码在服务端运行时，Node.js 环境里根本没有这些东西，程序立刻就会崩溃
你就可能需要将这类代码放入 `useEffect` 中。`useEffect` 只会在客户端运行，服务端渲染时不会执行它。
或者**动态导入**。对于非首屏必需的、重度依赖浏览器环境的组件（比如一个复杂的图表库），可以使用动态导入，并指定 `ssr: false`，让这个组件完全在客户端渲染。
```js
// ✅ Next.js 中动态导入组件
import dynamic from 'next/dynamic'

// 这个组件不会在服务端渲染
const DynamicChart = dynamic(() => import('../components/HeavyChart'), {
  ssr: false,
})

function MyPage() {
  return (
    <div>
      <h1>我的页面</h1>
      <DynamicChart />
    </div>
  )
}
```
#### 4.2 数据获取的时机与策略
在传统 SPA 中，我们通常在组件挂载后（`useEffect` 或 `mounted` 钩子）去请求数据。
但在这些框架中，你需要在页面渲染**之前**就把数据准备好，这样才能让服务端生成出带内容的 HTML。
你需要清晰地分辨不同数据获取函数的运行时机：

| 函数 (以 Next.js 为例)    | 运行时机             | 用途                                   |
| :------------------- | :--------------- | :----------------------------------- |
| `getStaticProps`     | **构建时**（在服务器上）   | 用于静态生成页面，适合内容不经常变动的场景，如博客文章、产品文档。    |
| `getServerSideProps` | **每次请求时**（在服务器上） | 用于服务端渲染，适合内容需要实时更新或高度个性化的场景，如用户信息面板。 |
| `客户端` useEffect `请求` | **页面加载后**（在浏览器上） | 用于获取用户交互后才需要的数据，或频繁更新的数据，如评论列表、实时通知。 |
- **不要在 `getStaticProps` 或 `getServerSideProps` 里写任何浏览器 API！** 它们运行在服务端。
- `getStaticProps` 和 `getServerSideProps` 返回的数据会被序列化（JSON.stringify）。所以，你不能在里面返回 `Date`、`Map`、`Set` 或函数等无法被序列化的类型，需要先转换成普通对象或字符串。

在 Next.js 13+ 的 **App Router** 中，数据获取方式变得更加简洁，可以直接在 React Server Components (RSC) 中使用 async/await 来获取数据，框架会根据数据的缓存策略（如 cache, no-store）和页面的动态性来自动决定其行为，概念上融合了 getStaticProps 和 getServerSideProps 的优点。这会让内容更加前沿。
#### 4.3 状态管理的“双重人格”
如果你在使用 Redux、Zustand 或 Pinia 这类状态管理库，你需要确保在服务端渲染时创建的状态，能够“传递”到客户端，并被客户端正确地“接管”（这个过程常被称为“注水”或 Hydration）。
如果服务端渲染出的页面状态，与客户端 JS 加载后生成的初始状态不一致，React 或 Vue 就会抛出一个警告，并且可能失去事件绑定等。
**如何解决？**
- **使用官方或社区推荐的集成方案**。例如，Next.js 有 `next-redux-wrapper`，Nuxt 对 Pinia 有内置的完美支持。这些工具的核心作用就是帮你自动处理状态的序列化和传递。
- **确保数据来源唯一**。页面的初始数据应该来自 `getStaticProps` 或 `getServerSideProps`，然后把它作为 props 传给页面组件，再由页面组件用它来初始化全局状态。避免在客户端又用 `useEffect` 重新请求一遍初始数据，这很容易导致不一致。
#### 4.4 样式处理的特殊性
如果你使用像 `styled-components` 或 `emotion` 这样的 CSS-in-JS 库，在服务端渲染时，虽然生成了 HTML，但样式规则可能还没来得及注入。这会导致用户先看到一个没有样式的“裸奔”页面，然后突然闪一下，变成有样式的页面，体验非常糟糕。
这类库通常都提供了服务端渲染的解决方案。核心思路是：
1. 在服务端渲染组件时，同时收集所有生成的 CSS 样式字符串。
2. 将这些 CSS 字符串放到 HTML 的 `<head>` 标签里，和 HTML 一起返回给浏览器。
3. 这样浏览器拿到 HTML 的同时，也看到了样式，就能立刻渲染出最终的页面，避免了闪烁。

Next.js 的 `_document.js/tsx` 文件就是用来做这类事情的。
在 **App Router** 中，_document.js 文件被根 layout.tsx 文件取代，CSS-in-JS 库也需要适配新的流式渲染和 Server Components 架构，通常会有新的配置方式。

#### 4.5 性能与工程实践
- **环境变量**：一定要区分服务端环境变量和客户端环境变量。在 Next.js 中，只有以 `NEXT_PUBLIC_` 开头的变量才会被打包到客户端代码中。其他变量只能在 `getStaticProps`、`getServerSideProps` 等 Node.js 环境中访问。**千万不要把密钥、Token 等敏感信息暴露到客户端！**
- **善用内置优化组件**：框架提供的 `<Image>`、`<Font>` 等组件是性能优化的“法宝”。它们自动帮你处理了图片懒加载、尺寸优化、格式转换（如 WebP）和字体闪屏等问题。**请优先使用它们，而不是原生的 `<img>` 标签。**
- **代码分割**：框架默认会为每个页面进行代码分割。但你还可以做得更细，使用 `dynamic`（Next.js）或 `defineAsyncComponent`（Vue/Nuxt）来按需加载那些非首屏必需的、体积较大的组件，让初始页面的 JavaScript 包更小，加载更快。

### 总结
|特性|传统 React/Vue 应用 (纯 CSR)|Next.js / Nuxt.js 应用|
|:--|:--|:--|
|**首屏渲染**|浏览器执行 JS 后渲染|服务器预渲染 HTML|
|**首屏速度**|慢|快|
|**SEO 效果**|差|优秀|
|**页面跳转**|客户端路由，无刷新|客户端路由，无刷新|
|**开发体验**|需手动配置路由、打包等|约定优于配置，开箱即用|
|**应用类型**|主要是前端应用|可轻松构建全栈应用|
引出一个新的思考点：我们到底应该在什么时候选择静态生成（SSG），什么时候选择服务端渲染（SSR），又或者干脆用传统的客户端渲染（CSR）呢？这背后其实就是对业务场景的权衡。你觉得呢？
- **SSG (静态生成)**：首选！性能最好，成本最低。适用于内容不频繁变动的页面，如博客文章、产品文档、营销官网、落地页。但是构建时间会随着页面数量的增多而变长，对于拥有成千上万个页面的大型网站，全量构建可能会非常耗时，这时就体现 ISR 价值了。
- **SSR (服务端渲染)**：当页面内容需要高度个性化（如用户个人中心）或数据必须是实时的（如股票行情、新闻动态）时使用。性能略逊于 SSG，但 SEO 友好。
- **ISR (增量静态再生)**：SSG 和 SSR 的完美结合。适用于内容会更新但不需要严格实时性的场景，如电商商品列表、新闻首页。可以在享受静态速度的同时，保证内容在一定时间后自动更新。
- **CSR (客户端渲染)**：适用于需要高度交互、对 SEO 没有要求、且可以放在登录保护后的应用内部页面，如复杂的管理后台仪表盘（Dashboard）、在线编辑器等。
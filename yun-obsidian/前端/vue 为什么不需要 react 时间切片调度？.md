## 1. React 时间切片、fiber、并发机制关系？
### 1.1 Fiber：可中断的基础设施
在 React 16 之前，React 的更新是“一口气做完”的。当状态变化时，React 会递归遍历整个组件树，进行 diff 算法，然后一次性更新 DOM。
这个过程是同步且不可中断的。如果组件树很庞大，这个递归过程就会耗时很长，浏览器主线程被完全占用，用户的所有交互（点击、输入）都会被卡住，直到渲染完成。
```jsx
// 优化后的示例，更聚焦于单次更新的成本
class ComplexComponent extends React.Component {
  state = {
    // 假设这是一个包含上千个项目的数组
    // generateLargeList() 是一个用于生成大型数组的辅助函数
    items: generateLargeList(), 
  };
  
  handleFilter = (e) => {
    // 用户的每一次输入，都会触发一次可能非常耗时的全列表重新渲染
    this.setState({
      filterText: e.target.value
    });
  };
  
  render() {
    const filteredItems = this.state.items.filter(
      item => item.text.includes(this.state.filterText)
    );
    
    return (
      <div>
        <input onChange={this.handleFilter} />
        {/* 渲染一个非常长的列表，这会导致 render 本身非常耗时 */}
        <ul>
          {filteredItems.map(item => <li key={item.id}>{item.text}</li>)}
        </ul>
      </div>
    );
  }
}
```
```
时间轴 ------------------------------------------------>
帧 1: |---- JS (React 更新，耗时 100ms) ----|
帧 2: |---------------------------------------|
帧 3: |---------------------------------------|
...
帧 6: |---------------------------------------|
帧 7: |---- (React 更新结束) ----| 处理用户点击 | 绘制 |
```
为了让用户感觉流畅，浏览器需要以每秒 60 帧的速度刷新屏幕。这意味着，每一帧的预算时间大约是 `1000ms / 60 ≈ 16.67ms`。浏览器必须在这 16.67ms 内完成：
- 运行 JavaScript 代码（包括 React 的更新逻辑）。
- 计算 CSS 样式（Style）。
- 进行页面布局（Layout）。
- 绘制页面（Paint）。
- 处理用户交互事件（点击、输入、滚动等）。

但是现在从第 1 帧到第 6 帧这将近 100ms 的时间里：
- **用户交互被阻塞**：用户的点击、输入事件被放入了任务队列，只能眼巴巴地等着 React 更新完毕。
- **页面渲染被阻塞**：浏览器没有机会去执行布局和绘制，页面看起来就像“冻住”了。
- **严重掉帧**：本应发生的 5-6 次屏幕刷新都丢失了，这就是我们感知到的**卡顿**。

**Fiber 的诞生，就是为了打破这种“一口气做完”的模式。**
Fiber 本质上是一个 JavaScript 对象，它代表了一个组件（或其他工作单元）的信息。
更重要的是，它通过 child、sibling、return 指针，将传统的树形结构“链表化”。这使得 React 可以**不再使用无法中断的递归方式来遍历组件树，而是改成一个可以随时暂停和恢复的循环迭代**。你可以在处理完任何一个 Fiber 节点后，记录下当前的位置，然后随时把主线程交还给浏览器。
```js
// 一个极度简化的 Fiber 节点结构
const fiberNode = {
  // 组件类型
  type: 'div',
  // 组件实例（如类组件的实例）
  stateNode: null,
  // 指向第一个子节点
  child: null,
  // 指向下一个兄弟节点
  sibling: null,
  // 指向父节点
  return: null,
  // ... 其他状态信息，如 props、state、副作用等
}
```
链表可以**随时暂停和恢复**。你不需要像递归那样必须走到最深处才能返回。下次再继续时，从记录的位置拿起来接着干就行。
**所以，Fiber 的核心贡献是：将渲染工作从“不可中断的递归调用”变成了“可中断的链表遍历”。它为时间切片提供了物理基础。**

### 1.2 时间切片：利用 Fiber 实现的调度策略
有了 Fiber 这个可中断的基础设施，我们就可以实现“时间切片”了。
因为 React 更新从根组件开始的“重新渲染 + Diff”过程依然可能是一个耗时较长的**纯计算任务**。
如果这个任务长时间占用主线程，页面就会卡顿。“时间切片”正是为了解决这个问题而设计的：**它允许 React 将这个宏大的计算任务切分成小块，在执行间隙可以响应用户输入等更高优先级的事件，从而保证应用的流畅性**。这个过程在 React 中被称为“调度”。
```js
function workLoopConcurrent() {
  // 只要还有下一个工作单元，并且当前时间片还没用完
  while (nextUnitOfWork !== null && !shouldYieldToHost()) {
    // 执行当前工作单元，并返回下一个要处理的工作单元
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
  }
}

// 判断是否应该让出主线程
function shouldYieldToHost() {
  // 实际的调度器实现比这复杂得多，它会使用 MessageChannel 等方式
  // 来检查主线程是否有待处理的用户输入等高优任务。
  // 获取当前时间
  const currentTime = getCurrentTime()
  // 如果当前时间超过了本次渲染的截止时间，就应该让出
  return currentTime >= deadline
}
```

### 1.3 并发机制：基于前两者的高级能力
当我们既能将工作拆分（Fiber），又能控制工作的执行时机（时间切片）时，再引入**优先级**的概念，一个更强大的能力就诞生了：**并发**。
注意React 的并发并不是指真正的并行计算（因为 **JS 仍然是单线程的**），而是指 React 能够同时管理多个状态更新，并根据优先级智能地决定渲染顺序、暂停或恢复渲染任务的能力。
**并发机制是 Fiber 和时间切片的“上层建筑”，它带来了革命性的新特性：**
- **`startTransition`**：你可以告诉 React：“这个更新（比如搜索一个很长的列表）是不紧急的，可以慢慢来。” React 会在后台用时间切片的方式处理它。如果在此期间，有更紧急的更新（比如用户在输入框里打字），React 会**暂停**不紧急的渲染，优先处理紧急的更新，处理完后再**恢复**之前不紧急的渲染。这保证了用户交互的流畅性。
- **`Suspense`**：当一个组件需要等待异步数据时，它可以在渲染过程中“抛出”一个 Promise。React 捕获到这个 Promise 后，会**暂停**这个组件树的渲染，并显示一个 fallback UI（比如 loading）。当数据加载完成，Promise resolve，React 会**恢复**该组件树的渲染。这个过程完全依赖于 Fiber 的可中断特性。
- **`useDeferredValue`**：与 `startTransition` 类似，它允许你延迟更新 UI 的某个部分。比如，一个输入框同时控制一个列表的筛选和一个图表的显示。你可以让图表的更新“延迟”，这样列表的筛选会感觉更即时。
**所以，并发机制是建立在 Fiber 和时间切片之上的应用层能力。它让 React 能够智能地管理多个渲染任务，根据优先级进行调度、暂停、恢复甚至丢弃，从而打造出极致流畅的用户体验。**


## 2. Vue 的不同路径：精准更新
### 2.1 细粒度的响应式系统和高效的异步更新队列
Vue 的响应式系统实现了**细粒度**的依赖追踪，其精度远超“组件级别”，可以直达模板中的**具体绑定**（如一个文本插值或一个属性）。
- **依赖收集：** 在组件首次渲染时，Vue 会像一个侦探，记录下模板中哪个“视图片段”使用了哪个“响应式数据”。这个过程通过 Proxy (Vue 3) 或 Object.defineProperty (Vue 2) 实现。
- **精准更新：** 当一个响应式数据变化时，Vue 不会重新渲染整个组件。它会直接通知并重新执行那些“订阅”了该数据的**更新函数 (effect)**。这些函数只负责更新模板中那一小块依赖该数据的 DOM。

所以因为更新任务从一开始就是最小化的、分散的，所以每个任务的执行成本极低。Vue 只需要通过 nextTick 将同一事件循环中的多个小任务合并，进行一次批处理即可。这个过程本身就非常高效，几乎不会长时间阻塞主线程，因此也就不需要引入“时间切片”这种复杂的调度机制来打断它。

而 React 的模型不同，当一个组件的状态发生变化时，React 会**从这个组件开始，向下遍历其子组件树**，进行新旧 Virtual DOM 的对比（这个过程称为 Reconciliation）。虽然开发者可以手动通过 `React.memo`、`PureComponent` 或 `shouldComponentUpdate`、`useMemo`、`useCallback` 等 API 手动进行优化，跳过那些没有必要更新的子树，但其核心思想是“通过比对找出差异”。
这就像你只知道城里某个街区（触发更新的组件）有情况，但需要把这个街区挨家挨-户盘问一遍才能确定具体问题。如果这个街区很大（组件树很深或很宽），盘问过程依然会很耗时。**而这种“地毯式排查”的模式，其根本原因在于 React 的状态是不可变的（Immutable）**：当状态变化时，React 只知道状态对象变了，但无法精确知道是哪个属性变了，因此需要通过 Diff 来寻找差异。
```js
// 这是一个极度简化的 Vue 响应式原理示意
const state = new Proxy({ count: 0 }, {
  get(target, key) {
    // 依赖收集：记录当前正在渲染的组件依赖了 key
    track(target, key)
    return target[key]
  },
  set(target, key, value) {
    target[key] = value
    // 派发更新：直接通知所有依赖 key 的组件
    trigger(target, key)
    // 注意：这里只是通知，真正的更新是异步批处理的
  }
})

function trigger(target, key) {
  // 找到所有依赖 key 的组件更新函数
  const effects = depsMap.get(key)
  effects.forEach(effect => {
    // 将更新函数放入一个队列，而不是立即执行
    queueJob(effect)
  })
}

// Vue 的调度器会异步处理这个队列
function queueJob(job) {
  // 使用 nextTick 等微任务，将同一个 tick 内的所有更新合并
  // 最终只触发一次渲染
  nextTick(job)
}
```


### 2.2 编译时优化
Vue 是少数将编译时优化作为核心性能策略的主流框架之一。
Vue的编译器在将模板（template）编译成渲染函数（render function）的过程中，会进行大量的静态分析，为运行时的更新过程提供关键的优化信息。
主要有：
- **静态内容提升**：编译器识别出模板中永远不会改变的部分（静态节点），并将其提升到渲染函数之外，后续更新时完全跳过这些节点。
- **更新类型标记**：编译器为动态节点打上"标记"（Patch Flag），**（例如，标记 1 代表这个节点只有文本内容会变，标记 8 代表只有 class 会变）**，告诉运行时 diff 算法只需比对特定属性，避免全量树比对。
- **事件处理缓存**：编译器自动缓存内联事件处理器，避免每次渲染时都创建新的函数实例，优化内存占用和更新性能。

这些由编译器提供的优化，使得 Vue 的虚拟DOM更新过程比传统的手动优化或纯运行时的虚拟 DOM diff 要快得多。这进一步巩固了 Vue 的性能优势，使得单次更新任务的执行时间被压缩到极短，从而降低了对时间切片这种复杂调度策略的需求。

## 3. 历史佐证：Vue 对时间切片的探索
Vue 的开发团队确实曾经尝试并实现过时间切片功能。
https://github.com/vuejs/rfcs/issues/89#issuecomment-546988615
然而，在经过内部测试和权衡后，这个实验性的功能最终被移除了。
![[Pasted image 20251005110949.png]]
![[Pasted image 20251005111012.png]]
尤雨溪核心意思是：**React 推崇的“时间切片”技术，主要是为了解决其自身架构设计所导致的“CPU 密集型卡顿”问题，而 Vue 则通过更底层的架构优化，从根源上避免了这类问题，使得时间切片在 Vue 中显得既不必要，反而会增加复杂度和包体积。**
有几个有意思的点：
1. “卡顿”的本质是**高负载的 CPU 计算**（处理大量数据、执行复杂的 JavaScript 逻辑。）和**同步的 DOM 更新**（浏览器需要根据计算结果，一次性、同步地更新页面元素）。这两者加在一起，如果总耗时超过了浏览器一帧的渲染时间（大约 16.67 ms），用户就会感觉到卡顿。
2. “时间切片”、只优化了 **CPU 计算部分**，对于 DOM 更新那部分，它无能为力。因为 DOM 必须同步更新才能保证页面的最终状态是正确一致的，不能被切片。
3. React 更新**更容易花费超过 100 毫秒的纯 CPU 时间**。
4. Vue 通过**更简单的 VDOM**、**编译时优化（AOT）**、**智能的响应式更新**从源头避免了过度消耗。
5. 时间切片本身还会导致**框架复杂度飙升**，**包体积增大**。







## 结论
React 和 Vue 在性能优化上走向了两条截然不同的道路，这根植于它们核心架构的差异：
- **React 的并发机制**：其核心是“**调度**”。它接受了“更新可能是慢的”这一事实，因此构建了以 Fiber 为基础的复杂调度系统，为“慢”任务提供一种不阻塞主线程的执行方式，保障用户交互的优先响应。
- **Vue 的响应式系统**：其核心是“**精准**”。它通过细粒度的依赖追踪和编译时优化，从源头上极大地减少了不必要的更新和计算量，努力让每一次任务都“足够快”，以至于在绝大多数场景下都不需要中断与恢复的复杂调度。

两者没有绝对的优劣，只是在不同设计哲学下的不同取舍。React 提供了处理极端复杂场景的强大能力，而 Vue 则提供了更易于理解和“开箱即用”的高性能体验。

|           |                                           |                                        |
| --------- | ----------------------------------------- | -------------------------------------- |
| 特性        | React (并发模式)                              | Vue 3                                  |
| **核心哲学**  | **调度 (Scheduling)**：接受更新可能很慢，通过智能调度保障流畅性。 | **精准 (Precision)**：从源头减少计算量，让每次更新都足够快。 |
| **工作单元**  | Fiber 节点（组件级）                             | 组件 / Effect                            |
| **更新机制**  | 自上而下的 Diff (Reconciliation)               | 细粒度的依赖追踪                               |
| **中断能力**  | **可中断/可恢复**                               | **非中断式（任务粒度小，无需中断）**                   |
| **优化手段**  | 运行时调度（时间切片、优先级）                           | 编译时优化（静态提升、Patch Flags）+ 响应式系统         |
| **解决的问题** | 极端复杂或低性能设备下的 UI 响应性问题。                    | 大多数场景下的高效更新，避免不必要的计算。                  |
| **开发者心智** | 需要理解 startTransition 等并发 API 来处理低优任务。     | 响应式系统自动优化，心智负担较低。                      |

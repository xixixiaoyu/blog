## 1. React 时间切片、fiber、并发机制关系？
### 1.1 Fiber：可中断的基础设施
在 React 16 之前，React 的更新是“一口气做完”的。当状态变化时，React 会递归遍历整个组件树，进行 diff 算法，然后一次性更新 DOM。
这个过程是同步且不可中断的。如果组件树很庞大，这个递归过程就会耗时很长，浏览器主线程被完全占用，用户的所有交互（点击、输入）都会被卡住，直到渲染完成。
```jsx
class ComplexForm extends React.Component {
  state = {
    // 大量状态
    formData: { /* 复杂表单数据 */ },
    calculations: { /* 复杂计算结果 */ },
    // ...更多状态
  };
  
  handleChange = (e) => {
    // 当用户输入时，触发状态更新
    this.setState({
      formData: {
        ...this.state.formData,
        [e.target.name]: e.target.value
      }
    });
    
    // 触发复杂计算
    this.performComplexCalculations();
  };
  
  performComplexCalculations = () => {
    // 复杂计算逻辑
    const results = /* 耗时计算 */;
    this.setState({ calculations: results });
  };
  
  render() {
    // 渲染复杂表单
    return (
      <form>
        {/* 大量表单字段 */}
      </form>
    );
  }
}
```
```
时间轴 ------------------------------------------------>
帧 1: |---- JS (React 更新，耗时 100ms) ----|
帧 2: |---------------------------------------|
帧 3: |---------------------------------------|
...
帧 6: |---------------------------------------|
帧 7: |---- (React 更新结束) ----| 处理用户点击 | 绘制 |
```
为了让用户感觉流畅，浏览器需要以每秒 60 帧的速度刷新屏幕。这意味着，每一帧的预算时间大约是 `1000ms / 60 ≈ 16.67ms`。浏览器必须在这 16.67ms 内完成：
- 运行 JavaScript 代码（包括 React 的更新逻辑）。
- 计算 CSS 样式（Style）。
- 进行页面布局（Layout）。
- 绘制页面（Paint）。
- 处理用户交互事件（点击、输入、滚动等）。

但是现在从第 1 帧到第 6 帧这将近 100ms 的时间里：
- **用户交互被阻塞**：用户的点击、输入事件被放入了任务队列，只能眼巴巴地等着 React 更新完毕。
- **页面渲染被阻塞**：浏览器没有机会去执行布局和绘制，页面看起来就像“冻住”了。
- **严重掉帧**：本应发生的 5-6 次屏幕刷新都丢失了，这就是我们感知到的**卡顿**。

**Fiber 的诞生，就是为了打破这种“一口气做完”的模式。**
Fiber 本质上是一个 JavaScript 对象，它代表了一个组件（或其他工作单元）的信息。
更重要的是，它通过 `child`、`sibling`、`return` 指针，将整个组件树连接成了一个**链表结构**，而不是之前的树形结构：
```js
// 一个极度简化的 Fiber 节点结构
const fiberNode = {
  // 组件类型
  type: 'div',
  // 组件实例（如类组件的实例）
  stateNode: null,
  // 指向第一个子节点
  child: null,
  // 指向下一个兄弟节点
  sibling: null,
  // 指向父节点
  return: null,
  // ... 其他状态信息，如 props、state、副作用等
}
```
链表可以**随时暂停和恢复**。你不需要像递归那样必须走到最深处才能返回。你可以在处理完任何一个 Fiber 节点后，记录下当前的位置，然后随时把主线程交还给浏览器。下次再继续时，从记录的位置拿起来接着干就行。
**所以，Fiber 的核心贡献是：将渲染工作从“不可中断的递归调用”变成了“可中断的链表遍历”。它为时间切片提供了物理基础。**

### 1.2 时间切片：利用 Fiber 实现的调度策略
有了 Fiber 这个可中断的基础设施，我们就可以实现“时间切片”了。
时间切片的目标是：**将一个大的、耗时的渲染任务，拆分成许多个小任务，每个小任务只运行一小段时间（比如 5ms），然后主动让出主线程，看看浏览器有没有更紧急的事情要做（比如处理用户输入）。**
这个过程在 React 中被称为“调度”。
```js
function workLoopConcurrent() {
  // 只要还有下一个工作单元，并且当前时间片还没用完
  while (nextUnitOfWork !== null && !shouldYieldToHost()) {
    // 执行当前工作单元，并返回下一个要处理的工作单元
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
  }
}

// 判断是否应该让出主线程
function shouldYieldToHost() {
  // 获取当前时间
  const currentTime = getCurrentTime()
  // 如果当前时间超过了本次渲染的截止时间，就应该让出
  return currentTime >= deadline
}
```

### 1.3 并发机制：基于前两者的高级能力
当我们既能将工作拆分（Fiber），又能控制工作的执行时机（时间切片）时，一个更强大的能力就诞生了：**并发**。
**并发机制是 Fiber 和时间切片的“上层建筑”，它带来了革命性的新特性：**
- **`startTransition`**：你可以告诉 React：“这个更新（比如搜索一个很长的列表）是不紧急的，可以慢慢来。” React 会在后台用时间切片的方式处理它。如果在此期间，有更紧急的更新（比如用户在输入框里打字），React 会**暂停**不紧急的渲染，优先处理紧急的更新，处理完后再**恢复**之前不紧急的渲染。这保证了用户交互的流畅性。
- **`Suspense`**：当一个组件需要等待异步数据时，它可以在渲染过程中“抛出”一个 Promise。React 捕获到这个 Promise 后，会**暂停**这个组件树的渲染，并显示一个 fallback UI（比如 loading）。当数据加载完成，Promise resolve，React 会**恢复**该组件树的渲染。这个过程完全依赖于 Fiber 的可中断特性。
- **`useDeferredValue`**：与 `startTransition` 类似，它允许你延迟更新 UI 的某个部分。比如，一个输入框同时控制一个列表的筛选和一个图表的显示。你可以让图表的更新“延迟”，这样列表的筛选会感觉更即时。
**所以，并发机制是建立在 Fiber 和时间切片之上的应用层能力。它让 React 能够智能地管理多个渲染任务，根据优先级进行调度、暂停、恢复甚至丢弃，从而打造出极致流畅的用户体验。**


## 2. 为什么 Vue 不需要这些
### 2.1 细粒度的响应式系统和高效的异步更新队列
Vue 的响应式系统能够实现精确到"组件级别"甚至更细粒度的依赖追踪。
在组件渲染过程中，Vue 会记录下模板中用到的每一个响应式数据。在Vue 2中，这通过`Object.defineProperty`实现；在 Vue 3 中，则通过性能更优的`Proxy`实现。
当一个响应式数据被修改时，只有那些直接依赖于该数据的组件（或副作用`effect`）才会被通知需要更新。
这种精确的依赖关系意味着，Vue 已经**精确地知道了哪些组件需要更新**，所以它要处理的更新列表是明确且有限的。它只需要把这些更新任务放进一个队列，然后在下一个事件循环中（通过 `nextTick`）批量执行即可。这个过程通常很快，不会长时间阻塞主线程，因此也就不需要“时间切片”这种复杂的打断机制。
而 React 当应用状态发生变化时，会从根节点开始，遍历整个 Fiber 树，对比新旧虚拟 DOM，这个过程称之为 **Reconciliation（协调）**。就像你只知道城里有个小偷，但不知道是谁，于是只能挨家挨户地盘问。如果城市很大，这个过程就会非常耗时。

```js
// 这是一个极度简化的 Vue 响应式原理示意
const state = new Proxy({ count: 0 }, {
  get(target, key) {
    // 依赖收集：记录当前正在渲染的组件依赖了 key
    track(target, key)
    return target[key]
  },
  set(target, key, value) {
    target[key] = value
    // 派发更新：直接通知所有依赖 key 的组件
    trigger(target, key)
    // 注意：这里只是通知，真正的更新是异步批处理的
  }
})

function trigger(target, key) {
  // 找到所有依赖 key 的组件更新函数
  const effects = depsMap.get(key)
  effects.forEach(effect => {
    // 将更新函数放入一个队列，而不是立即执行
    queueJob(effect)
  })
}

// Vue 的调度器会异步处理这个队列
function queueJob(job) {
  // 使用 nextTick 等微任务，将同一个 tick 内的所有更新合并
  // 最终只触发一次渲染
  nextTick(job)
}
```


### 2.2 编译时优化
Vue 是少数将编译时优化作为核心性能策略的主流框架之一。
Vue的编译器在将模板（template）编译成渲染函数（render function）的过程中，会进行大量的静态分析，为运行时的更新过程提供关键的优化信息。
主要有：
- **静态内容提升**：编译器识别出模板中永远不会改变的部分（静态节点），并将其提升到渲染函数之外，后续更新时完全跳过这些节点。
- **更新类型标记**：编译器为动态节点打上"标记"（Patch Flag），告诉运行时 diff 算法只需比对特定属性，避免全量树比对。
- **事件处理缓存**：编译器自动缓存内联事件处理器，避免每次渲染时都创建新的函数实例，优化内存占用和更新性能。

这些由编译器提供的优化，使得 Vue 的虚拟DOM更新过程比传统的手动优化或纯运行时的虚拟 DOM diff 要快得多。这进一步巩固了 Vue 的性能优势，使得单次更新任务的执行时间被压缩到极短，从而降低了对时间切片这种复杂调度策略的需求。

## 3. 历史佐证：Vue 对时间切片的探索
Vue 的开发团队确实曾经尝试并实现过时间切片功能。
然而，在经过内部测试和权衡后，这个实验性的功能最终被移除了。
### 3.1 移除的主要原因
1. **收效甚微**：由于 Vue 的响应式系统和编译时优化已经将更新性能做到了极致，引入时间切片所带来的额外收益在绝大多数场景下并不明显。
2. **增加复杂性与负向开销**：时间切片调度机制本身是有开销的。将任务拆分、调度、中断和恢复，这一系列操作会增加额外的计算负担，可能降低VDOM diff的整体效率。
3. **架构哲学不符**：Vue的 哲学是追求简单、高效和"开箱即用"的性能。其架构已经通过更简单、更直接的方式解决了性能问题。引入一个复杂的并发调度系统，与这一核心理念相悖。
Vue 团队对时间切片的短暂探索和最终放弃，从实践上证明了在其现有高效架构下，引入时间切片的投入产出比并不理想。这进一步印证了 Vue 通过"从源头减少更新计算量"的策略的有效性。

## 4. 性能基准测试观察


## 结论
React 的解决方案是为"慢"任务提供一种不阻塞页面的执行方式，而 Vue 的解决方案则是努力让任务本身变得"足够快"，以至于不需要复杂的调度。
Vue 团队对时间切片的短暂探索和最终放弃，也从实践上证明了在其现有高效架构下，引入时间切片的投入产出比并不理想。
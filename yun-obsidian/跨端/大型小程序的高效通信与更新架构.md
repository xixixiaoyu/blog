你肯定也遇到过这样的场景：项目初期能跑就行，但随着业务像藤蔓一样疯狂生长，代码库慢慢变成了一座难以逾越的“屎山”。每一次需求迭代，都像是在雷区里小心翼翼地排雷，生怕触动哪个不起眼的角落，就引发一连串的线上问题。尤其是滥用 `setData` 这类更新方法，稍有不慎，页面就会变得卡顿，用户体验直线下降。
别担心，这并非无解之题。今天，我想和你分享的，正是在大厂实战中沉淀下来的一套**颗粒化通信更新架构方案**。虽然我们以小程序为例，但它的思想完全适用于单纯的 WebView H5 应用。

### 1. 拨开迷雾：我们到底在解决什么问题？
在动手设计之前，我们得先用第一性原理思考：问题的根源究竟在哪？
无论是小程序还是 WebView 应用，它们的结构都逃不过两个维度：**页面栈**和**组件树**。
- **页面栈**：就像一叠盘子，用户打开新页面就往上放一个，返回就取走一个。当我们在最上面的页面（比如页面 A）修改了数据，希望返回到下面的页面（比如页面 B）时，B 能同步更新。这就是跨页面的通信与更新难题。
- **组件树**：每个页面都是一棵由组件构成的“树”。树上的组件之间，比如深层级的组件 A 要和组件 E 通信，或者不相邻的组件 B 和组件 E 要通信，如果只能一层层地通过 `props` 传递，那代码会变得极其臃肿和脆弱。

这两个结构，共同决定了项目的复杂度。由此，我们引出了两大核心痛点：
#### 1.1 通信的复杂性
传统的通信方式，比如通过 `setData` 修改父组件数据来触发子组件更新，本质上是一次逻辑层到渲染层的完整通信。
如果我们只是想传递一个“嘿，你该刷新了”的消息，却不得不去构造和修改一份数据，这不仅让业务逻辑变得混乱，更是一种性能浪费。
你可能会说：“用状态管理工具不就好了？”
这确实是个好办法，但它也有局限。想象一下，你的页面栈里有三个完全相同的商品详情页（A、B、C）。如果页面 A 里的一个组件发起了一个全局事件，没有做页面维度的隔离，那么 A、B、C 三个页面里订阅了该事件的组件都会收到通知。这显然不是我们想要的结果，我们期望的是精准打击，而非无差别攻击。
#### 1.2 更新的复杂性
更新操作同样棘手。
还是刚才 A、B、C 三个商品详情页的例子。当你在页面 A 操作，触发了数据更新。如果此时我们粗暴地让 B 和 C 也执行 `setData`，会怎么样？B 和 C 此时在页面栈底部，用户根本看不到，但 `setData` 却实实在在地执行了。这会占用宝贵的线程资源，导致用户从 A 返回到 B 时，页面出现明显的卡顿，这就是所谓的 `setData` 阻塞。
另一个场景是，组件 A 更新了，订阅了它的 D、E、F 三个组件都会收到通知。但如果这次更新只和 D、F 有关，E 组件的更新就完全是浪费。这就需要一种机制，能像 React-Redux 里的 `Selector` 一样，精确地判断组件是否真的需要更新。
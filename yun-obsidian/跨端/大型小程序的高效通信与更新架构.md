你肯定也遇到过这样的场景：项目初期能跑就行，但随着业务像藤蔓一样疯狂生长，代码库慢慢变成了一座难以逾越的“屎山”。每一次需求迭代，都像是在雷区里小心翼翼地排雷，生怕触动哪个不起眼的角落，就引发一连串的线上问题。尤其是滥用 `setData` 这类更新方法，稍有不慎，页面就会变得卡顿，用户体验直线下降。
别担心，这并非无解之题。今天，我想和你分享的，正是在大厂实战中沉淀下来的一套**颗粒化通信更新架构方案**。虽然我们以小程序为例，但它的思想完全适用于单纯的 WebView H5 应用。

### 1. 拨开迷雾：我们到底在解决什么问题？
在动手设计之前，我们得先用第一性原理思考：问题的根源究竟在哪？
无论是小程序还是 WebView 应用，它们的结构都逃不过两个维度：**页面栈**和**组件树**。
![[Pasted image 20251005232413.png]]
- **页面栈**：就像一叠盘子，用户打开新页面就往上放一个，返回就取走一个。当我们在最上面的页面（比如页面 A）修改了数据，希望返回到下面的页面（比如页面 B）时，B 能同步更新。这就是跨页面的通信与更新难题。
- **组件树**：每个页面都是一棵由组件构成的“树”。树上的组件之间，比如深层级的组件 A 要和组件 E 通信，或者不相邻的组件 B 和组件 E 要通信，如果只能一层层地通过 `props` 传递，那代码会变得极其臃肿和脆弱。

这两个结构，共同决定了项目的复杂度。由此，我们引出了两大核心痛点：
#### 1.1 通信的复杂性
传统的通信方式，比如通过 `setData` 修改父组件数据来触发子组件更新，本质上是一次逻辑层到渲染层的完整通信。
如果我们只是想传递一个“嘿，你该刷新了”的消息，却不得不去构造和修改一份数据，这不仅让业务逻辑变得混乱，更是一种性能浪费。
你可能会说：“用状态管理工具不就好了？”
这确实是个好办法，但它也有局限。想象一下，你的页面栈里有三个完全相同的商品详情页（A、B、C）。如果页面 A 里的一个组件发起了一个全局事件，没有做页面维度的隔离，那么 A、B、C 三个页面里订阅了该事件的组件都会收到通知。这显然不是我们想要的结果，我们期望的是精准打击，而非无差别攻击。
#### 1.2 更新的复杂性
更新操作同样棘手。
还是刚才 A、B、C 三个商品详情页的例子。当你在页面 A 操作，触发了数据更新。如果此时我们粗暴地让 B 和 C 也执行 `setData`，会怎么样？B 和 C 此时在页面栈底部，用户根本看不到，但 `setData` 却实实在在地执行了。这会占用宝贵的线程资源，导致用户从 A 返回到 B 时，页面出现明显的卡顿，这就是所谓的 `setData` 阻塞。
另一个场景是，组件 A 更新了，订阅了它的 D、E、F 三个组件都会收到通知。但如果这次更新只和 D、F 有关，E 组件的更新就完全是浪费。这就需要一种机制，能像 React-Redux 里的 `Selector` 一样，精确地判断组件是否真的需要更新。

### 2. 设计蓝图：我们的架构愿景
我们需要一个能够**精准控制通信范围**、**按需执行更新**的架构。它应该立足于页面栈的管理，凌驾于组件树之上，实现颗粒化的控制。
让我们以一个经典的购物车场景来驱动设计。一个好的购物车架构，应该满足：
1. **数据共享**：多个页面（如商品详情页、购物车页）共享同一份购物车数据。
2. **颗粒化更新**：点击“加入购物车”后，只有当前页面的相关组件（如商品卡片上的加购按钮、底部的购物车栏）更新，而不是整个页面刷新。
3. **按需唤醒**：在页面 A 操作购物车后，页面栈中的页面 B（同样是购物车相关页）不会立即更新。只有当用户从 A 返回到 B 时，B 才会同步最新状态，避免无效的 `setData`。

基于这些愿景，我们的架构蓝图包含以下几个核心模块：
1. **状态提升**：将购物车这类共享数据，提升到一个全局的“数据中心”进行统一管理。
2. **发布订阅模式**：建立一套事件广播系统。组件或页面可以“订阅”自己感兴趣的消息，当数据变更时，由数据中心“发布”消息，精准通知给所有订阅者。
3. **建立页面维度**：这是解决“相同页面多实例”问题的关键。我们需要为每一个页面实例，创建一个独立的“订阅频道”。
4. **生命周期拦截**：通过一种“魔法”，让我们能够感知到页面的 `onShow`、`onHide`、`onUnload` 等生命周期，从而激活或冻结对应页面的“订阅频道”。

### 3. 动手实践：核心模块的代码实现
#### 3.1 基础构件：发布订阅模式
首先，我们需要实现发布订阅模式的基础模块。
**订阅器**：负责管理所有的订阅者。
```js
// subscription.js
import Observer from './observer';

/**
 * 基础订阅器，管理观察者（订阅者）
 */
class Subscription {
  // 使用 Set 存储观察者，保证唯一性
  observers: Set<Observer> = new Set();

  /**
   * 订阅消息
   * @param {Function} cb - 数据更新时的回调函数
   * @param {Function} selector - 可选，用于判断是否需要更新，性能优化关键
   * @returns {Function} - 取消订阅的函数
   */
  subscribe(cb: Function, selector?: Function) {
    if (typeof cb !== 'function') {
      console.warn('subscribe 的第一个参数应该是一个 function 类型');
      return;
    }
    const observer = new Observer(cb, selector);
    this.observers.add(observer);
    // 返回一个取消订阅的函数，方便外部调用
    return () => {
      this.observers.delete(observer);
    };
  }

  /**
   * 发布消息，通知所有观察者
   */
  publish(...args: any[]) {
    console.log(`准备通知 ${this.observers.size} 个订阅者`);
    this.observers.forEach((observer) => {
      observer.next(...args);
    });
  }

  /**
   * 取消指定回调的订阅
   * @param {Function} cb - 要取消订阅的回调函数
   */
  unSubscribe(cb: Function) {
    // 注意：这里直接用 cb 是删不掉的，因为 Set 中存的是 Observer 实例
    // 实际使用中，我们依赖 subscribe 返回的取消函数
    console.warn('建议使用 subscribe 返回的函数来取消订阅');
  }
}

export default Subscription;
```
**观察者**：代表每一个订阅者。
```js
// observer.js
export default class Observer {
  // 更新函数
  callback: Function | null = null;
  // 数据选择器，用于性能优化
  selector: Function | null = null;

  constructor(cb: Function, selector?: Function) {
    this.callback = cb;
    this.selector = selector;
  }

  /**
   * 触发更新
   * @param args - 发布时传递的参数
   */
  next(...args: any[]) {
    // 如果存在 selector，先执行它来判断是否需要真的更新
    // 这里可以扩展为更精细的对比逻辑
    let shouldUpdate = true;
    if (typeof this.selector === 'function') {
      shouldUpdate = this.selector(...args);
    }

    if (shouldUpdate && this.callback) {
      this.callback(...args);
    }
  }
}
```
#### 3.2 页面维度的核心：自定义订阅器
基础的 `Subscription` 还无法区分页面，我们来继承并强化它。
```js
// custom-subscription.js
import Subscription from './subscription';

/**
 * 自定义订阅器，增加了页面维度的概念
 */
class CustomSubscription extends Subscription {
  // 页面的原始 ID（如 'pageA'）
  originPageId: string = '';
  // 页面的唯一实例 ID（如 'pageA-1'）
  pageInstanceId: string = '';
  // 标记该页面是否在不可见时发生过数据变更
  hasChange: boolean = false;

  constructor(originPageId: string, pageInstanceId: string) {
    super();
    this.originPageId = originPageId;
    this.pageInstanceId = pageInstanceId;
  }

  /**
   * 设置更新标记
   * @param {boolean} status - 是否有更新
   */
  emitChange(status: boolean) {
    this.hasChange = status;
  }
}

export default CustomSubscription;
```
#### 3.2 大脑中枢：事件数据中心
这是整个架构的核心，一个单例，负责管理数据和所有的订阅器。
```js
// event-data-center.js
import CustomSubscription from './custom-subscription';
import Model from './model'; // Model 是一个简单的 { state: {} } 数据管理类

// 单例，确保全局只有一个数据中心
let eventDataCenter: EventDataCenter | null = null;

/**
 * 事件与数据的管理中心
 */
class EventDataCenter {
  // 页面实例索引，用于生成唯一 ID
  pageIndex: number = 0;
  // 数据模型
  model: Model;
  // 存放所有页面的订阅器，Map<pageInstanceId, CustomSubscription>
  subscriptions: Map<string, CustomSubscription> = new Map();
  // 当前激活状态的页面实例 ID
  activePageInstanceId: string | null = null;

  constructor() {
    this.model = new Model();
  }

  /**
   * 初始化一个页面的订阅器
   * @param {string} originPageId - 页面的原始 ID
   * @returns {string} - 页面的唯一实例 ID
   */
  initSubscription(originPageId: string): string {
    this.pageIndex++;
    const pageInstanceId = `${originPageId}-${this.pageIndex}`;
    const subscription = new CustomSubscription(originPageId, pageInstanceId);
    
    this.subscriptions.set(pageInstanceId, subscription);
    this.changeActivePage(pageInstanceId);
    
    return pageInstanceId;
  }

  /**
   * 切换当前激活的页面
   * @param {string | null} pageInstanceId - 要激活的页面实例 ID
   */
  changeActivePage(pageInstanceId: string | null) {
    this.activePageInstanceId = pageInstanceId;
  }

  /**
   * 获取当前激活的订阅器
   * @returns {CustomSubscription | null}
   */
  getActiveSubscription(): CustomSubscription | null {
    if (!this.activePageInstanceId) return null;
    return this.subscriptions.get(this.activePageInstanceId) || null;
  }

  /**
   * 改变所有订阅器的“待更新”状态
   * 当数据发生全局变更时，标记所有页面都有待更新的可能性
   */
  markAllSubscriptionChanged() {
    this.subscriptions.forEach((sub) => sub.emitChange(true));
  }

  /**
   * 通知当前激活的订阅器进行更新
   */
  notifyActiveSubscription(...args: any[]) {
    const activeSub = this.getActiveSubscription();
    if (activeSub && activeSub.hasChange) {
      activeSub.publish(...args);
      // 更新后重置标记
      activeSub.emitChange(false);
    }
  }

  /**
   * 对外的统一更新入口
   * @param {object} payload - 要更新的数据
   * @param args - 额外参数
   */
  dispatch(payload: object, ...args: any[]) {
    // 1. 更新全局数据
    this.model.setModelData(payload);
    // 2. 标记所有页面订阅器为“待更新”
    this.markAllSubscriptionChanged();
    // 3. 仅通知当前激活的订阅器执行更新
    this.notifyActiveSubscription(...args);
  }

  /**
   * 销毁指定页面的订阅器
   * @param {string} pageInstanceId 
   */
  destroySubscription(pageInstanceId: string) {
    this.subscriptions.delete(pageInstanceId);
    // 如果销毁的是当前激活页面，则置空
    if (this.activePageInstanceId === pageInstanceId) {
      this.activePageInstanceId = null;
    }
  }
}

// --- 对外暴露的辅助函数 ---

/**
 * 获取或创建数据中心实例
 */
export function getEventDataCenter(): EventDataCenter {
  if (!eventDataCenter) {
    eventDataCenter = new EventDataCenter();
  }
  return eventDataCenter;
}

/**
 * 页面显示时，激活其订阅器并检查更新
 */
export function activeSubscription(pageInstanceId: string) {
  const center = getEventDataCenter();
  center.changeActivePage(pageInstanceId);
  // 检查并执行可能在页面隐藏时堆积的更新
  center.notifyActiveSubscription();
}

/**
 * 页面隐藏时，激活器置空，冻结更新
 */
export function unActiveSubscription() {
  const center = getEventDataCenter();
  center.changeActivePage(null);
}
```
####  3.4 神奇的“魔法”：生命周期拦截
我们如何才能在页面生命周期里调用上面的函数呢？答案是自定义构造器。
```js
// container.js
import { getEventDataCenter, activeSubscription, unActiveSubscription } from './event-data-center';

/**
 * 自定义小程序页面构造器
 * @param {object} options - 页面原始配置
 * @param {string} originPageId - 页面的原始 ID
 * @param {Function} originPage - 原始的 Page 构造器，允许被多层包裹
 */
export default function customPage(options: WechatMiniprogram.Page.Options, originPageId: string, originPage: WechatMiniprogram.Page.Constructor = Page) {
  originPage({
    ...options,
    onLoad(query: any) {
      // 初始化数据中心，并创建当前页面的订阅器
      const center = getEventDataCenter();
      this._pageInstanceId = center.initSubscription(originPageId);
      
      options.onLoad?.call(this, query);
    },
    onShow() {
      // 页面显示，激活订阅器并尝试更新
      if (this._pageInstanceId) {
        activeSubscription(this._pageInstanceId);
      }
      options.onShow?.call(this);
    },
    onHide() {
      // 页面隐藏，冻结订阅器
      unActiveSubscription();
      options.onHide?.call(this);
    },
    onUnload() {
      // 页面卸载，销毁订阅器
      if (this._pageInstanceId) {
        const center = getEventDataCenter();
        center.destroySubscription(this._pageInstanceId);
      }
      options.onUnload?.call(this);
    },
  });
}
```
这样，我们只需要用 `customPage` 代替原来的 `Page`，就能无缝地接入整个架构。
#### 3.5 对外的 API
最后，为组件提供简洁的 API。
```js
// event-data-center.js (文件末尾追加)

const center = getEventDataCenter();

/**
 * 组件或页面订阅数据变化
 */
export function subscribe(cb: Function, selector?: Function) {
  const activeSub = center.getActiveSubscription();
  if (activeSub) {
    return activeSub.subscribe(cb, selector);
  }
  console.warn('当前没有激活的页面订阅器，订阅失败');
  return () => {};
}

/**
 * 获取数据中心的状态
 */
export function getModelData(key: string) {
  return center.model.getModelData(key);
}

/**
 * 触发数据更新和通知
 */
export function dispatch(payload: object, ...args: any[]) {
  center.dispatch(payload, ...args);
}
```
### 4. 效果验证
现在，我们把这个架构应用到购物车场景。
**页面 B（跳转源）**
```js
// pageB.js
import customPage from '../../common/event-data-center/container';

customPage({
  data: {},
  onLoad() {
    console.log('页面 B onLoad');
  },
  // 跳转到页面 A
  goToPageA() {
    wx.navigateTo({ url: '/pages/pageA/index' });
  },
}, 'pageB'); // 传入原始页面 ID
```
**底部购物车组件（bottom-cart）**
```js
// bottom-cart.js
import { subscribe, getModelData, dispatch } from '../../common/event-data-center/event-data-center';

Component({
  properties: {
    pageType: String, // 用于区分是哪个页面的组件
  },
  data: {
    count: 0,
  },
  lifetimes: {
    ready() {
      // 1. 订阅购物车数量的变化
      this.unsubscribe = subscribe(() => {
        const newCount = getModelData('cartCount') || 0;
        if (newCount !== this.data.count) {
          console.log(`【${this.properties.pageType}】底部购物车组件更新: ${this.data.count} -> ${newCount}`);
          this.setData({ count: newCount });
        }
      });
      // 2. 初始化时获取一次数据
      const initialCount = getModelData('cartCount');
      if (initialCount) {
        this.setData({ count: initialCount });
      }
    },
    detached() {
      // 组件销毁时，取消订阅
      this.unsubscribe && this.unsubscribe();
    },
  },
  methods: {
    addCart() {
      // 触发更新
      const currentCount = getModelData('cartCount') || 0;
      dispatch({ cartCount: currentCount + 1 });
    },
  },
});
```
**操作流程与预期效果：**
1. **在页面 B 点击“加购”**：`dispatch` 被调用，`EventDataCenter` 更新数据，标记所有页面“待更新”，并通知当前激活的页面 B 的订阅器。页面 B 的 `bottom-cart` 组件收到通知，`setData` 更新数量。页面 A 的组件虽然也被标记了“待更新”，但由于其订阅器未激活，不会执行 `setData`。
2. **从页面 B 跳转到页面 A**：页面 B 触发 `onHide`，订阅器被冻结。页面 A 触发 `onLoad` 和 `onShow`，创建新的订阅器并激活。
3. **在页面 A 点击“加购”**：同步骤 1，但只有页面 A 的组件会更新。
4. **从页面 A 返回到页面 B**：页面 A 触发 `onUnload`，订阅器销毁。页面 B 触发 `onShow`，其订阅器被重新激活。`EventDataCenter` 检测到该订阅器的 `hasChange` 标记为 `true`，于是立即发布更新通知，页面 B 的 `bottom-cart` 组件同步了最新的购物车数量。

整个过程，`setData` 被精确地控制在了**当前可见页面**的**需要更新的组件**上，完美地解决了我们开篇提出的所有痛点。

### 总结与思考
今天我们一起构建的这个架构，本质上是**“集中式状态管理 + 发布订阅 + 页面生命周期隔离”**三者思想的结晶。它将混乱的通信和更新逻辑，收敛到了一个可控、可预测的通道里。
这个方案最大的优点在于：
- **性能极致**：通过页面维度隔离和按需更新，最大程度地减少了不必要的 `setData` 调用。
- **逻辑清晰**：数据流向单一，组件职责明确，让大型项目的维护不再是噩梦。
- **扩展性强**：可以轻松在此基础上扩展出 `Selector`、中间件等更高级的功能。
当然，这只是一个原型，真实的大厂实践会更加复杂，比如会加入更严格的类型约束、更完善的数据持久化和回滚机制、以及更细粒度的性能监控。
但万变不离其宗，其核心的设计思想 —— **控制与隔离** —— 是解决复杂系统问题的通用法则。
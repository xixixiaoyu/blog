### 一切的开端：WebView —— 跨平台的“瑞士军刀”
想象一下，如果每开发一个应用，都要为 iOS 和 Android 分别写一套代码，那成本得多高啊？于是，聪明的工程师们找到了一个“偷懒”的妙招：**WebView**。
你可以把 WebView 理解为一个嵌入在原生 App 里的“迷你浏览器”。它拥有浏览器的大部分核心能力，可以加载和显示网页。有了它，我们就可以用熟悉的 HTML、CSS 和 JavaScript 来开发界面，然后让原生 App 通过 WebView 来展示。这种模式，我们称之为 **Hybrid（混合）模式**。
在 WebView 这个大舞台上，诞生了两位明星选手：**H5 混合应用**和**小程序**

#### 1. H5 模式：简单直接的“独幕剧”

h5 流程清晰明了：
1. **开场**：原生 App 打开一个 WebView 容器。
2. **剧情展开**：WebView 像普通浏览器一样，加载一个指定的 URL。
3. **呈现**：请求资源、加载数据、渲染页面，一气呵成。

它的通信流程也同样直接。当你在页面上点击一个按钮，DOM 事件触发，JavaScript 逻辑响应，然后直接更新视图。整个过程都在一个 WebView 内部完成，简单高效。
**复杂的 H5 Hybrid 应用同样依赖与 Native 的双向通信**，只是小程序将这套通信机制（JSBridge）和双线程架构标准化、内置化了，而传统的 H5 Hybrid 应用则需要开发者自己实现或依赖第三方框架来搭建这座桥梁。

#### 2. 小程序模式：精心编排的“双线剧”
小程序的架构采用了**双线程架构**：
这两条线分别是：
- **视图层**：负责舞台上的表演，也就是界面的渲染。它依然由 WebView 承载，负责展示 WXML 和 WXSS 编译后的页面。
- **逻辑层**：负责幕后的一切，比如响应用户操作、处理数据、发起网络请求等。它在一个独立的 JavaScript 引擎（比如 JavaScriptCore）中运行，**完全脱离了浏览器环境**。

现在，我们来看看这出“双线剧”是如何上演的：
**渲染流程：**
1. **准备舞台**：Native 打开一个 WebView 作为视图层。
2. **演员就位**：视图层加载页面的 WXML 和 WXSS 结构。
3. **导演决策**：逻辑层开始工作，比如通过 `setData` 准备要更新的数据。
4. **传递指令**：数据**不能直接**给视图层！它必须先经过 Native（中间人）。
5. **舞台呈现**：Native 收到数据后，再把它传递给视图层的 WebView，最终完成渲染。

假如逻辑层调用 setData 时，数据会被序列化（通常是转成 JSON 字符串）。这个字符串通过 JSBridge 传递给 Native。Native 收到后，再通过调用 WebView 提供的接口，执行一段注入到 WebView 中的 JavaScript 代码，并将这个 JSON 字符串作为参数传进去。WebView 里的渲染引擎接收到这个数据后，才开始进行后续的 diff 和渲染。这个过程虽然曲折，但保证了两个线程的隔离。

**通信流程：**
当你在小程序页面上点击一个按钮时，信息传递的路径就更曲折了：
**视图层 → Native → 逻辑层 → Native → 视图层**
每一次交互都需要 Native 这个“中间人”来传话。你可能会问，这样做不是更麻烦吗？别急，这恰恰是小程序设计的精髓所在。

#### 3. 逻辑层探秘：没有 `window` 的世界
既然逻辑层不是浏览器环境，那我们在小程序 JS 文件里写的那些 `Page`、`Component`、`wx` 等等，是从哪里来的呢？
答案是：**小程序基础库**。
这个基础库由宿主 App（比如微信）注入到逻辑层的 JS 引擎中。它提供了小程序运行所需的全部 API 和运行时环境，就像 React 库为 React 应用提供 `React.createElement` 一样。
让我们来看一个典型的页面代码：
```js
// pages/index/index.js
Page({
  data: {
    message: 'hello,world'
  },
  onLoad() {
    console.log('页面加载了')
    // console.log(window) // 如果执行这行，会得到 undefined
  },
  handleClick() {
    console.log('我被点击了！')
  }
})
```
这里的 `Page` 构造函数，就是基础库提供的。它负责接收我们定义的配置对象，并将其注册为小程序的一个页面实例。
因为逻辑层没有 `window` 对象，所以任何浏览器特有的 DOM、BOM API 都无法使用，这也保证了逻辑的纯粹性和安全性。
所有页面的 JS 代码，在编译后可能会被打包成一个大的 JS 文件（可以想象成 `app-service.js`）。当小程序需要打开某个页面时，就会从这个大文件中找到并执行对应的逻辑。
这个大文件也可以通过分包优化，可以将其拆分成按需加载的多个代码包

#### 4. 页面管理：原生导航与“单页”内涵
你有没有发现，小程序的页面跳转非常流畅，返回手势也很自然，这比很多 H5 单页应用（SPA）的体验要好。这是为什么呢？
秘密就在于小程序采用了**原生导航与 WebView 内容管理相结合**的混合方案。
**SPA 的痛点**： 传统的单页应用（SPA）只有一个 HTML 页面，路由切换时，需要通过 JS 卸载旧组件、挂载新组件。这个过程完全在浏览器环境内完成，不仅可能因复杂的 DOM 操作导致卡顿，也无法调用系统原生的页面转场动画和手势。
**小程序的方案**： 小程序巧妙地将“壳”和“芯”分开了。
- **原生负责“导航”和“转场”**：你看到的页面顶部导航栏、页面推入（push）和弹出（pop）的动画效果，以及侧滑返回手势，这些都是由宿主 App（如微信）的原生（Native）组件实现的。这从根本上保证了导航体验的流畅和原生化。
- **WebView 负责“内容”渲染**：对于 WebView 如何承载页面内容，小程序的实现方案经历了演进，主要有两种模式：
    1. **多 WebView 模式（早期或部分 iOS 实现）**：一个页面对应一个独立的 WebView。当你从 A 页面跳转到 B 页面时，会创建一个新的 WebView 来承载 B 页面，而 A 页面的 WebView 则被完整保留在导航栈的下一层。这种模式天然地实现了页面状态保持和环境隔离，但内存和性能开销较大。
    2. **单 WebView / WebView 池模式（当前主流实现）**：为了优化内存和启动速度，现在主流的小程序运行时（尤其在 Android 端）采用此模式。整个小程序可能只运行在一个或有限的几个 WebView 实例中。当页面跳转时，框架并不会创建新的 WebView，而是在同一个 WebView 内部，通过 JavaScript **模拟**出页面的推入（push）和弹出（pop）效果——即隐藏旧页面的 DOM，渲染新页面的 DOM。

无论是哪种模式，都带来了巨大的好处：
- **原生体验**：页面切换的动画和手势由原生接管，保证了流畅和自然。
- **状态保持**：返回上一页时，体验是无缝的。在“多 WebView”模式下，这是因为上一页的 WebView 实例并未销毁；在“单 WebView”模式下，则是框架在切换前保存了页面的滚动位置、DOM 状态等，并在返回时进行了**恢复**。
- **环境隔离**：不同页面的视图环境是隔离的。在“多 WebView”模式下是物理隔离；在“单 WebView”模式下，框架通过技术手段（如模拟 Shadow DOM）来确保页面间的样式和逻辑互不干扰。（小程序框架会为每个页面的根节点添加一个独特的类名或 ID，并通过 CSS 选择器（如后代选择器）来约束 WXSS 样式的生效范围，从而实现样式的“作用域隔离”）

为了在逻辑层管理这些页面视图，小程序引入了**页面栈**的管理机制。
- **页面栈**： 一个由小程序框架维护的、存放页面实例的逻辑栈，有最大容量限制（微信小程序是 10 层）。它记录了用户的访问路径。这个机制管理的不是物理的 WebView 实例，而是页面的**逻辑状态**。
- **路由方法**：
    - wx.navigateTo()：创建一个新的页面实例，并将其入栈。
    - wx.redirectTo()：替换当前页面实例，即当前页面出栈，新页面入栈。
    - wx.navigateBack()：页面实例不断出栈，直到返回目标页面。

这个机制就像一个有容量限制的停车场，当栈满了就不能再进新车了，这保证了应用的稳定运行和可预测的行为。

#### 5. 视图层探秘：从 WXML 到真实 DOM
视图层的工作，就是把我们写的 WXML 和 WXSS，变成用户能看到的真实界面。这个过程也很有意思。
WebView 只认识 HTML、CSS 和 JS，不认识 WXML。所以，小程序在编译阶段，会做一个“翻译”工作。
这和 React 的 JSX 语法非常相似。React 会把 `<div>` 编译成 `React.createElement()` 的调用。小程序也类似，它会把 WXML 编译成一个**语法树**，并最终生成一个 `render` 函数。
比如这段 WXML：
```xml
<view class="container {{ show ? 'in' : 'out' }}">
  <view bind:tap="handleClick">{{ message }}</view>
</view>
```
它最终可能会被编译成类似下面这样的 `render` 函数：
```js
// 这是一个概念性的 render 函数，用于说明原理
function render(context) {
  // context 是一个运行时对象，提供了很多辅助方法
  return [
    context.renderNode('view', {
      // 合并 class
      attrs: { class: context.mergeClass('container', context.getPropsData('show') ? 'in' : 'out') }
    }, [
      context.renderNode('view', {
        // 绑定事件
        events: { tap: 'handleClick' }
      }, [
        // 获取逻辑层 data 中的数据
        context.getPropsData('message')
      ])
    ])
  ]
}
```
当视图层 WebView 加载完成后，就会执行这个 `render` 函数。`context` 对象会帮助它从逻辑层获取最新的数据（`getPropsData`），然后调用基础库提供的方法（`renderNode`）来创建真实的 DOM 节点，最终渲染到页面上。

#### 总结与展望
我们一起梳理一下今天的发现：
1. **H5 和小程序都基于 WebView**，但架构理念不同。H5 是单线程的直接模式，而小程序是**双线程**的隔离模式。
2. 小程序的**逻辑层**运行在独立的 JS 引擎中，没有浏览器环境，由**小程序基础库**提供 API。
3. 小程序的页面切换体验接近原生，得益于**原生导航与高效的 WebView 内容管理相结合**的方案。它通过逻辑层的**页面栈**来管理页面状态，而视图层则可能采用**单 WebView 或多 WebView**的模式来渲染，实现了流畅的转场和状态保持。
4. WXML 会被编译成 `render` 函数，在视图层执行，通过 `context` 对象与逻辑层数据关联，最终渲染成页面。
双线程架构虽然增加了通信的复杂度，但它带来了巨大的好处：**逻辑与视图分离，避免了繁重的 DOM 操作阻塞 UI，从而保证了流畅的用户体验**。这正是小程序设计的核心智慧。
提问：逻辑层和视图层之间，那个神秘的“中间人” Native，究竟是如何实现高效通信的呢？这座桥梁，就是我们下次要聊的主角——**JSBridge**。
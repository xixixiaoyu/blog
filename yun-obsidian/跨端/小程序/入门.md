## 1. 模板语法
基本跟 Vue 大同小异。
### 1.1 数据绑定：`{{ }}`
双大括号 `{{ }}` 用于将 JavaScript 数据（来自页面的 `.js` 文件中的 `data` 对象）动态地渲染到视图层。
当逻辑层（`.js` 文件）调用 `this.setData` 改变 `data` 中的值时，视图层（`.axml` 文件）中所有绑定该数据的部分会自动更新。
```js
// 在 page.js 的 data 中定义数据
data: {
  message: 'Hello, Alipay Mini Program!',
  count: 0,
  isActive: true
}
```
```html
<!-- 在 page.axml 中使用数据绑定 -->
<view>{{ message }}</view>
<view>计数：{{ count }}</view>
<view class="{{ isActive ? 'active-class' : 'inactive-class' }}">动态类名</view>
```
`{{ }}` 内可以是简单的属性路径，也可以是完整的 JavaScript 表达式（三元运算符、算术运算、字符串拼接等），但不能是语句（如 `if`, `for`）或函数调用。

###  1.2 条件渲染：`a:if`
用于根据条件决定是否渲染一个组件块：
```html
<view a:if="{{ count > 5 }}">计数大于 5 时才显示我</view>
<view a:elif="{{ count > 0 }}">计数大于 0 但小于等于 5 时显示我</view>
<view a:else>其他情况显示我</view>
```
**对比 `hidden` 属性**：
- `hidden` 属性（`<view hidden="{{ !condition }}">`）是通过 CSS 的 `display: none` 来隐藏元素，元素依然存在于 DOM 树中。它适用于需要频繁切换显示/隐藏的场景。

### 1.3 列表渲染：`a:for`
用于将数组数据渲染成一系列结构相似的组件。
```html
<!-- item 和 index 是默认的循环变量名 -->
<view a:for="{{ items }}" a:for-item="item" a:for-index="idx">
  {{ idx + 1 }}. {{ item.name }}
</view>
```

### 1.4 事件处理：`onTap`
响应用户的交互操作，将视图层的事件传递到逻辑层进行处理。
以 `on` 或 `catch` 开头，后跟事件类型，`on` 和 `catch` 的区别在于事件冒泡。`on` 会允许事件向父组件传递，而 `catch` 会阻止事件冒泡。
```html
<!-- 在 .axml 中绑定事件 -->
<view onTap="handleViewTap" data-custom-info="some data">点我</view>
<button onGetAuthorize="onGetAuth" onError="onAuthError">授权</button>
```


## 2. 组件
### 2.1 官方内置
- **视图容器**：构建页面布局的基础。
    - `<view>`：最基础的块级容器，类似于 HTML 中的 `<div>`。
    - `<scroll-view>`：可滚动的视图区域。
    - `<swiper>`：轮播图容器。
- **基础内容**：展示文本、图标等。
    - `<text>`：文本组件。
    - `<icon>`：图标组件。
- **表单组件**：用于用户输入和交互。
    - `<button>`：按钮。
    - `<input>`：输入框。
    - `<checkbox>`、`<radio>`：复选框和单选框。
- **导航组件**：用于页面跳转。
    - `<navigator>`：页面链接。
- **媒体组件**：用于展示图片和视频。
    - `<image>`：图片。
    - `<video>`：视频。

### 2.2 自定义组件
假设我们要创建一个名为 `product-card` 的商品卡片组件：
```
/components/product-card/
├── product-card.axml  # 组件的结构
├── product-card.js    # 组件的逻辑
├── product-card.acss  # 组件的样式
└── product-card.json  # 组件的配置文件
```

### 2.3 组件通信
| 场景      | 推荐方式                |
| ------- | ------------------- |
| 父子组件通信  | Props + 回调函数        |
| 跨层级组件通信 | 全局 Store            |
| 兄弟组件通信  | EventBus 或 全局 Store |
| 页面间通信   | URL 参数 + 全局 Store   |
| 临时状态    | 组件内部 state          |
| 持久化数据   | 本地存储                |

### 2.4 组件复用
#### 全局复用：在 `app.json` 中声明
```json
// app.json
{
  "pages": [
    "pages/index/index",
    "pages/detail/detail"
  ],
  "window": {
    "defaultTitle": "My App"
  },
  // 在这里定义全局组件
  "usingComponents": {
    "product-card": "/components/product-card/product-card"
  }
}
```
现在，`index.axml` 和 `detail.axml` 以及任何其他页面，都可以直接使用 `<product-card>` 标签，无需再次声明。
#### 局部复用：在页面的 `.json` 文件中声明
如果你只是想在**某一个特定页面**使用这个组件，那么在那个页面对应的 `.json` 文件中声明即可：
```json
// pages/detail/detail.json
{
  "usingComponents": {
    "product-card": "/components/product-card/product-card"
  }
}
```
这时只有当用户进入 `detail` 页面时，小程序才会去加载 `product-card` 组件的代码，可以稍微提升首页的加载速度。

### 插槽
比如**一个通用的卡片容器组件 `container-card`：**
```html
<!-- components/container-card/container-card.axml -->
<view class="card-wrapper">
  <!-- 这是一个插槽，名字叫 "header" -->
  <slot name="header"></slot>
  <view class="card-body">
    <!-- 这是默认插槽，没有名字 -->
    <slot></slot>
  </view>
</view>
```
现在，你可以在页面里这样使用它：
```html
<!-- pages/index/index.axml -->
<container-card>
  <!-- 这部分内容会填充到名为 "header" 的插槽中 -->
  <view slot="header" class="custom-header">这是我的自定义标题</view>
  
  <!-- 这部分内容会填充到默认插槽中 -->
  <text>这是卡片的主体内容，可以是任何东西。</text>
  <button>一个按钮</button>
  <image src="..."></image>
</container-card>
```

## 3. 生命周期
### 3.1 应用级生命周期（app.ts）
- **onLaunch(options)**：小程序初始化完成，全局触发一次。
- **onShow(options)**：小程序启动或从后台进入前台。
- **onHide()**：小程序从前台进入后台。
- **onError(error)**：小程序发生脚本错误或 API 调用失败时触发。
- **onPageNotFound(object)**：要打开的页面不存在时触发。    
- **onShareAppMessage(object)**：全局分享配置。
### 3.2 页面级生命周期（页面.ts）
- **onLoad(query)**：页面加载时触发，一个页面只调用一次，可获取 query 参数。
- **onShow()**：页面显示/切入前台时触发。
- **onReady()**：页面初次渲染完成时触发，一个页面只调用一次。
- **onHide()**：页面隐藏/切入后台时触发。
- **onUnload()**：页面卸载时触发。
- **onPullDownRefresh()**：监听用户下拉刷新。
- **onReachBottom()**：页面滚动到底部。
- **onShareAppMessage(object)**：自定义当前页面的分享内容。
### 3.3 组件生命周期（组件.ts）
- **onInit()**：组件创建时触发，在 props 被接收后执行。
- **didMount()**：组件被渲染到页面 DOM 树后触发。
- **didUpdate(prevProps, prevData)**：组件的 props 或 data 发生变化时触发。
- **didUnmount()**：组件从页面 DOM 树中移除时触发。
### 3.4 执行顺序
- **首次打开**：应用 onLaunch → 应用 onShow → 页面 onLoad → 页面 onShow → 页面 onReady
- **页面切换（A → B）**：页面A onHide → 页面B onLoad → 页面B onShow → 页面B onReady
- **返回上一页（B → A）**：页面B onUnload → 页面A onShow
### 3.5 最佳实践
- **数据初始化**：onLoad 中进行（仅需一次的请求和初始化）。
- **网络请求**：onLoad（一次性数据）或 onShow（每次页面显示都需要刷新的数据，如登录状态、购物车数量）。
- **资源清理**：onUnload 或 didUnmount 中清理定时器、取消事件监听等。
- **定时器管理**：在 onHide 中暂停，在 onShow 中恢复，避免后台空耗性能。  
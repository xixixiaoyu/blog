# Master Prompt: 将 AI 服务高可用架构类比为“构建跨云多活的流量治理系统”

## 1. 核心目标 (Core Goal)

你是一位顶级的分布式系统架构师，你的任务是为一群资深后端工程师和 SRE 撰写一份关于“构建终极高可用的 AI 服务”的架构指南。这份指南需要将多模型、多供应商的冗余灾备问题，升维到云原生时代“**跨云多活的分布式流量治理**”的战略高度。

**核心类比**：
- **AI 服务网关**: 一个智能的“**全局流量管理器 (Global Traffic Manager)**”，类似于 Istio 或 Envoy，是所有 AI 请求的入口。
- **AI 模型供应商 (OpenAI, Anthropic, 自研模型)**: 部署在不同“**数据中心 (Data Center)**”或“**云区域 (Cloud Region)**”的服务集群。每个集群的健康状况、服务能力和成本各不相同。
- **故障转移 (Failover)**: “**数据中心级的灾难恢复**”。当一个数据中心（如 `us-east-1` 的 OpenAI）因“地震”或“断电”（API 全面宕机）而完全不可用时，流量管理器会自动将所有流量切换到位于另一个数据中心（如 `eu-west-1` 的 Anthropic）的“备用站点”。
- **负载均衡与路由**: “**智能 DNS 解析与流量调度**”。流量管理器根据预设策略（如延迟优先、成本最低）和实时的“健康检查”结果，决定将每个用户请求发往哪个“数据中心”。
- **熔断 (Circuit Breaking)**: “**智能的故障隔离机制**”。当流量管理器发现发往某个数据中心的请求连续失败时，它会暂时“切断”通往该数据中心的“光缆”，在一段时间内不再向其发送流量，防止雪崩效应。这比简单的 Failover 更主动、更精细。
- **服务降级 (Degradation)**: “**应急预案**”。在所有“主数据中心”都拥堵或不可用时，流量管理器会将请求导向一个“备用的、功能有限但能保证基本服务的微型数据中心”（例如，从 GPT-4o 降级到 GPT-4o-mini，或从流式降级到非流式）。
- **混沌工程 (Chaos Engineering)**: “**定期的消防演习**”。主动、有计划地在生产环境中注入故障（如模拟某个供应商的 API 延迟飙升、模拟网络分区），以检验整个系统的弹性和自动恢复能力是否符合预期。

本文的目标是提供一份架构师级别的纲领性文件，让工程师不再满足于实现简单的“if-else 式”的故障切换，而是从设计之初就构建一个具备“自愈”能力的、真正意义上的高可用 AI 服务体系。

## 2. 文章结构 (Article Structure)

**I. 标题：打不垮的 AI 服务：从多活、熔断到混沌工程的终极架构指南**

**II. 引言：当“模型”成为一种需要做灾备的“分布式数据库”**
   - 破题：AI 服务的可用性挑战，本质上是管理一个外部的、行为不确定的、分布式的依赖。我们必须用设计分布式系统的思路来设计 AI 网关。
   - 架构演进：展示从“单体调用” -> “简单 Failover” -> “动态路由与熔断” -> “跨云多活”的架构演进图。

**III. The Resilience Layer：构建你的“AI 服务网格”**
   - **统一接口 (The Standard Interface)**: 定义一个与供应商无关的、标准化的内部 AI 调用接口，这是所有高级策略的基础。
   - **健康检查 (Health Probes)**: 实现一个主动的健康检查器，定期“ping”所有下游供应商的 `/health` 端点和进行一次“模拟调用”，实时更新每个“数据中心”的可用性状态。
   - **动态路由 (Dynamic Routing)**: 
     - **策略**: 基于健康状态、延迟、成本、QPS 限制等多种因素的动态决策。
     - **Code Snippet**: 展示一个 `ProviderSelector` 服务，它根据实时指标数据，为每个请求选择最佳供应商。

**IV. 核心韧性模式 (Core Resilience Patterns)**
   - **请求级熔断与重试 (Request-Level Circuit Breaker & Retry)**
     - **场景**: 应对单个请求的瞬时网络错误或偶发性失败。
     - **Code Snippet**: 使用 NestJS 的 `HttpModule` 结合 `cockatiel` 库，展示如何为一个对外的 HTTP 请求包装上“超时 + 重试 + 熔断”的组合策略。
   - **服务级熔断 (Service-Level Circuit Breaker)**
     - **场景**: 当某个供应商的整体错误率超过阈值（如 5 分钟内错误率 > 30%），对其进行“硬熔断”，所有发往该供应商的请求会立刻失败或转发到备用供应商，而不是等待超时。

**V. 灾难恢复与降级 (Disaster Recovery & Degradation)**
   - **跨区域/跨云故障转移 (Cross-Region/Cloud Failover)**
     - **架构**: 设计主备（Active-Passive）或双活（Active-Active）架构。讨论其在成本和恢复时间目标 (RTO) 上的权衡。
   - **服务降级策略**: 
     - **模型降级**: GPT-4o -> GPT-4o-mini。优雅地处理能力差异（如 Function Calling 的支持）。
     - **模式降级**: 流式 -> 非流式。在网关层缓冲完整结果，然后模拟成流式返回给客户端，对前端透明。
     - **数据降级**: RAG 查询时，如果向量数据库查询失败，降级为仅使用关键词搜索，保证有结果返回。

**VI. 终极考验：混沌工程 (Chaos Engineering)**
   - **为什么需要**: “你不能指望一个未经测试的备份能够正常工作。”
   - **实践方法**: 
     - **工具**: 介绍 `toxiproxy` 等工具，用于在测试环境中模拟网络延迟、丢包、下游服务宕机等场景。
     - **Game Day**: 组织“消防演习”，设定场景（如“模拟 OpenAI API P99 延迟增加到 30 秒”），观察系统是否如预期般自动降级和恢复。

**VII. 监控与告警：建立“战情指挥室”**
   - **核心 SLIs/SLOs**: 监控 `网关层可用性`、`端到端延迟`、`供应商切换率`、`熔断器开启次数`。
   - **仪表盘**: 设计一个 Grafana 仪表盘，能够一目了然地看到全局流量分布、各供应商的健康状况和熔断状态。

**VIII. 结论：高可用不是功能，而是设计原则**
   - 总结：健壮的 AI 服务源于在架构设计之初就融入的韧性思维。

## 3. 质量与风格核对清单 (Quality & Style Checklist)

- [ ] **架构高度**: 是否通篇使用“分布式系统”、“流量治理”、“服务网格”、“多活”等具有架构高度的术语？
- [ ] **云原生思维**: 是否体现了云原生时代的设计思想，如健康检查、动态发现、配置中心化、不可变基础设施等？
- [ ] **代码深度**: 提供的代码示例是否展示了如何在真实框架（如 NestJS）中优雅地集成和组织韧性策略，而不仅仅是孤立的算法？
- [ ] **AI 特色**: 是否深入讨论了 AI 服务特有的故障模式（如模型效果衰退）和降级策略（如模型、模式降级）？
- [ ] **可落地性**: 混沌工程和监控部分是否提供了具体的工具和可操作的实践方法，而非空泛的理论？

# 表驱动测试

---

请你扮演一位 Go 语言的布道师和代码风格专家，为已经了解 Go 单元测试基础的开发者，撰写一篇关于“表驱动测试” (Table-Driven Tests) 的权威指南。

**文章目标：**

本文旨在让读者深刻理解什么是表驱动测试，为什么它是 Go 社区推崇的最佳实践，以及如何优雅地实现它。读者在阅读后，应该能熟练地将这种模式应用到自己的测试代码中，编写出高度可读、可扩展的测试用例。

**核心内容与结构：**

1.  **开篇：从一个“坏味道”的测试开始**
    *   展示一个反例：为一个函数（例如 `strings.Split`）编写多个独立的 `TestXXX` 函数，或者在一个测试函数中编写大量重复的调用和断言代码。
    *   分析其痛点：代码冗余、难以添加新用例、无法清晰地看出测试覆盖了哪些场景。
    *   引出解决方案：将测试用例的数据和逻辑分离，这便是表驱动测试的核心思想。

2.  **什么是表驱动测试？**
    *   给出清晰的定义：表驱动测试是一种将测试用例的输入和期望输出组织成一个“表格”（通常是结构体切片）的模式，然后在一个循环中遍历这个表格，执行相同的测试逻辑。
    *   强调其两大核心优势：
        *   **数据与逻辑分离：** 测试逻辑只写一次，测试数据清晰地列在表格中。
        *   **可维护性与可读性：** 添加、删除、修改测试用例变得极其简单和直观。

3.  **表驱动测试的标准结构（The Anatomy of a Table-Driven Test）**
    *   这是文章的核心。需要一步步拆解一个标准的表驱动测试的写法。
    *   **第一步：定义测试用例结构体。**
        *   通常包含 `name` (测试用例名), `args` (输入参数), `want` (期望输出), `wantErr` (是否期望错误) 等字段。
    *   **第二步：创建测试用例“表格”。**
        *   实例化一个包含多个测试用例结构体的切片。
        *   ```go
          tests := []struct{
              // ... 字段
          }{
              // ... 测试用例
          }
          ```
    *   **第三步：遍历表格，执行测试。**
        *   使用 `for` 循环遍历 `tests` 切片。

4.  **最佳实践：结合子测试 `t.Run()`**
    *   **为什么这是最佳实践？** 如果不使用子测试，只要有一个用例失败，整个测试函数就会失败，并且难以确定是哪个用例出了问题。循环也会在第一次失败时（如果使用 `t.Fatal`）就停止。
    *   **黄金组合：`for` + `t.Run()`**
        *   展示最终的“黄金标准”代码结构：
          ```go
          for _, tt := range tests {
              t.Run(tt.name, func(t *testing.T) {
                  // ... 这里是针对单个测试用例的逻辑
                  // 注意：并发测试中的变量捕获问题 (tt)
              })
          }
          ```
    *   **重点提示：并发测试中的变量捕获问题。**
        *   明确指出，如果子测试中使用了 `t.Parallel()`，必须在循环内部重新声明一个循环变量的副本，否则所有并发的子测试都会意外地使用最后一个测试用例的数据。
        *   `tt := tt // 捕获循环变量`

**代码要求：**

*   提供一个清晰、完整的表驱动测试示例。
*   被测试的函数最好能同时返回结果和错误，以便完整地展示 `want` 和 `wantErr` 字段的用法。
*   代码中必须包含 `for` 循环和 `t.Run` 的结合使用。
*   代码中必须包含处理并发测试时变量捕获问题的正确写法，并附有注释说明其必要性。

**总结：**

重申表驱动测试是 Go 社区在测试实践中沉淀出的宝贵经验。它不是一种强制的语法，而是一种让测试代码更清晰、更健壮的“风格指南”。鼓励读者在所有适合的场景下（几乎是所有单元测试）都优先使用表驱动测试模式。
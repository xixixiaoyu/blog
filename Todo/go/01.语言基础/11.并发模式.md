请你扮演一位 Go 并发模式的布道者和实践者，为一篇名为《Go 语言高级并发模式》的深度指南生成内容。

**文章目标：** 帮助已经掌握 Go 并发基础（goroutine, channel, select）的开发者，学习并应用一系列高级并发模式，以构建更复杂、更健壮、更高效的并发系统。

**内容要求：**

1.  **引言：模式的重要性**
    *   解释什么是并发模式：是解决常见并发问题的、可复用的方案。
    *   强调学习并发模式可以让我们站在巨人的肩膀上，写出更优雅、更地道的 Go 并发代码。

2.  **核心模式：`context`**
    *   **动机**：解释为什么需要 `context` —— 为了控制和取消跨越多个 API 边界（特别是网络请求）的 `goroutine` 树。
    *   **核心功能**：
        *   **取消 (`WithCancel`)**：展示如何创建一个可取消的 `context`，并将其传递给子 `goroutine`。子 `goroutine` 通过监听 `ctx.Done()` channel 来优雅地退出。
        *   **超时 (`WithTimeout`, `WithDeadline`)**：展示如何创建一个有超时限制的 `context`，这在处理外部请求时至关重要。
        *   **传递值 (`WithValue`)**：解释如何使用 `context` 在请求范围内传递非关键数据（如 request-ID, user-ID）。**强调**：不应该用它来传递关键的业务参数。
    *   **最佳实践**：`context` 应作为函数（特别是网络和长耗时函数）的第一个参数，命名为 `ctx`。

3.  **扇出，扇入 (Fan-out, Fan-in)**
    *   **概念**：
        *   **扇出**：一个 `goroutine` 将工作分发给多个 `goroutine` 去处理。
        *   **扇入**：一个 `goroutine` 收集多个 `goroutine` 的处理结果。
    *   **示例**：通过一个“计算任务”的例子，展示如何启动多个 worker `goroutine`（扇出）来并行处理数据，然后用一个 `merger` `goroutine`（扇入）来汇总所有 worker 的结果。

4.  **管道 (Pipelines)**
    *   **概念**：将一系列处理步骤（每个步骤都是一个 `goroutine`）串联起来，每个步骤的输出是下一个步骤的输入。
    *   **示例**：通过一个数据处理流水线的例子（如：读取数字 -> 计算平方 -> 打印结果），展示如何构建一个多阶段的并发管道。

5.  **其他重要模式**
    *   **带取消的生成器 (Generator with Cancellation)**：展示如何创建一个生成数据的 `goroutine`，并能通过 `context` 来通知它停止生成。
    *   **限流 (Rate Limiting)**：
        *   **动机**：解释为什么需要限流（保护下游服务，控制资源消耗）。
        *   **实践**：展示如何使用 `time.Ticker` 或一个带缓冲的 `channel` 来实现一个简单的速率限制器。
    *   **错误处理与 `errgroup`**：
        *   介绍 `golang.org/x/sync/errgroup` 包。
        *   展示如何使用 `errgroup` 来管理一组 `goroutine`，它能保证只要有一个 `goroutine` 出错，就会取消所有其他 `goroutine`，并返回第一个发生的错误。

**写作风格：**
*   **模式导向**：以一个个具体的“模式”作为章节标题，结构清晰。
*   **图示清晰**：强烈建议为“扇出，扇入”和“管道”等模式配上简单的数据流图。
*   **代码即注释**：提供完整、可运行的代码示例，并附上关键的注释来解释代码的意图。
*   **实用性强**：重点介绍在实际项目中最常用、最实用的并发模式（如 `context` 和 `errgroup`）。

请生成这篇文章的完整 Markdown 内容。
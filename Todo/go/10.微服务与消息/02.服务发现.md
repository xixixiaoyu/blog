# Prompt: Go 微服务基石：基于 etcd 实现服务发现

请你扮演一位 Go 分布式系统专家，撰写一篇关于在 Go 微服务体系中，如何基于 etcd 实现服务注册与发现的深度实战教程。

这篇文章的目标是让开发者彻底理解服务发现在微服务架构中的核心作用，并能动手使用 `etcd/client/v3` 库，为 gRPC 服务构建一个健壮的服务注册与发现机制，包括健康检查和客户端负载均衡。

## 1. 文章核心目标

- **原理透彻**：清晰地解释服务发现的“为什么”和“是什么”，以及基于 etcd 实现的底层工作原理（K/V 存储、Watch、Lease）。
- **实战导向**：提供从服务注册到服务发现、再到负载均衡的完整 Go 代码实现，并与 gRPC 服务无缝集成。
- **健壮性设计**：重点讲解如何利用 etcd 的租约（Lease）机制实现高效、自动的服务健康检查和故障摘除。
- **代码优雅**：封装出可复用的 `ServiceRegistry` 和 `ServiceDiscovery` 模块，方便在实际项目中直接使用。

## 2. 内容结构要求

请按照以下结构组织文章，确保逻辑连贯，代码详实：

### 引言：在动态的微服务世界里找到你

- 从一个问题开始：当一个 gRPC 服务水平扩展出多个实例，IP 和端口都在动态变化时，客户端如何准确地找到并调用它们？
- 引出服务发现机制是解决这一问题的关键，并介绍 etcd 作为云原生时代首选的元数据存储，非常适合扮演“服务注册中心”的角色。
- 明确本文将通过实战，教你如何为 Go gRPC 服务插上服务发现的“翅膀”。

### 一、核心原理：etcd 如何支撑服务发现

- **1. K/V 存储模型**：解释服务注册的本质，就是将服务信息（服务名、地址、端口等）作为一个 Key-Value 对写入 etcd。例如，Key 可以是 `/services/user-service/node-1`，Value 是 `{"host": "10.0.0.1", "port": 8080}`。
- **2. 租约机制 (Lease)**：
    - **核心**：这是实现健康检查和自动故障转移的关键。解释服务在注册时，会创建一个带有 TTL（存活时间）的租约，并将自己的 Key 绑定到这个租约上。
    - 服务需要定期向 etcd “续约”（KeepAlive），证明自己还活着。
    - 如果服务宕机，无法续约，租约到期后 etcd 会自动删除该租约以及所有与之绑定的 Key，从而实现服务节点的自动摘除。
- **3. 监视机制 (Watch)**：
    - 解释客户端（服务消费者）如何通过 Watch API 监视服务目录（如 `/services/user-service/`）下的变化。
    - 当有新节点注册（PUT 事件）或旧节点下线（DELETE 事件）时，客户端会收到通知，并动态更新本地的服务地址列表。

### 二、实战：服务注册模块 (`ServiceRegistry`)

- **1. 封装 `ServiceRegistry` 结构体**：包含 etcd 客户端实例、租约 ID 等字段。
- **2. 实现 `NewServiceRegistry` 函数**：初始化 etcd 客户端连接。
- **3. 实现 `RegisterService` 方法**：
    - 步骤 1: 通过 `client.Grant()` 创建一个租约。
    - 步骤 2: 通过 `client.KeepAlive()` 启动一个 goroutine 自动为租约续期。
    - 步骤 3: 将服务信息（地址、端口）序列化为 JSON 字符串。
    - 步骤 4: 使用 `client.Put()` 将服务信息的 Key-Value 对与租约绑定，写入 etcd。
- **4. 实现 `UnregisterService` 方法**：在服务正常关闭时，撤销租约并删除 Key。
- **5. 与 gRPC 服务集成**：展示如何在 gRPC 服务启动时调用 `RegisterService`，并使用 `defer` 在服务关闭时调用 `UnregisterService`。

### 三、实战：服务发现与负载均衡 (`ServiceDiscovery`)

- **1. 封装 `ServiceDiscovery` 结构体**：包含 etcd 客户端实例和本地的服务地址列表（`[]string`）。
- **2. 实现 `NewServiceDiscovery` 函数**：
    - 初始化 etcd 客户端。
    - **核心**：立即执行一次 `client.Get()`，获取指定服务前缀下的所有当前可用节点，并填充到本地地址列表。
    - 启动一个 `watcher` goroutine。
- **3. 实现 `watcher` 方法**：
    - 使用 `client.Watch()` 监视服务目录。
    - 在 `for...range` 循环中处理 Watch 事件：
        - 如果是 `PUT` 事件，将新节点地址添加到本地列表。
        - 如果是 `DELETE` 事件，从本地列表中移除对应的节点地址。
- **4. 集成 gRPC 客户端负载均衡**：
    - **gRPC Naming Resolver**: 解释 gRPC 的 `resolver` 机制允许我们自定义服务发现的逻辑。
    - **实现自定义 `Resolver`**: 创建一个符合 `resolver.Builder` 和 `resolver.Resolver` 接口的结构体。
    - 在 `ResolveNow` 和 `watch` 逻辑中，将从 `ServiceDiscovery` 获取到的地址列表通过 `cc.UpdateState()` 更新到 gRPC 的连接状态中。
    - **客户端调用**：演示如何在 `grpc.Dial` 时，使用 `resolver.Register` 注册我们的自定义 resolver，并使用自定义的 scheme（如 `etcd:///user-service`）来创建连接，同时配置负载均衡策略（如 `round_robin`）。

### 四、完整代码与项目结构

- 提供一个完整的、可运行的项目，包含：
    - `proto/`
    - `registry/` (包含 `service_registry.go` 和 `service_discovery.go`)
    - `server/main.go` (启动 gRPC 服务并注册自己)
    - `client/main.go` (通过服务发现和负载均衡调用 gRPC 服务)

### 结论

- 总结基于 etcd 的服务发现机制是构建健壮、可扩展 Go 微服务体系的基石。
- 强调租约（Lease）和监视（Watch）是这套机制的灵魂。
- 鼓励读者将这套模式应用到自己的项目中，并可以进一步探索更完善的服务治理框架，如 go-micro 或 kratos。

## 3. 文章风格要求

- **原理与实践并重**：既要讲清楚 etcd 的 Lease/Watch 原理，也要给出能直接运行的 Go 代码。
- **代码模块化**：封装的 `ServiceRegistry` 和 `ServiceDiscovery` 应具备高内聚、低耦合的特点。
- **逻辑严谨**：清晰地展示服务注册、续约、下线、客户端发现、地址更新的完整生命周期。

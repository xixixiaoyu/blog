# AI Prompt: 深入 Go 任务队列：基于 Asynq 的实战指南

请你扮演一位资深的 Go 开发者和技术博主。

我希望你能撰写一篇关于 Go 任务队列的深度解析文章，以流行的 `Asynq` 库为例。文章应深入浅出，从基本概念讲起，逐步深入到高级特性和生产环境中的最佳实践，并提供完整、可运行的代码示例。

**文章目标：**

为 Go 开发者提供一个关于 `Asynq` 的完整学习路径，使他们能够充满信心地在项目中使用 `Asynq` 构建稳定、可扩展的异步任务处理系统。

**核心内容与要求：**

1.  **任务队列基础（概念回顾）**
    *   简要介绍什么是任务队列及其核心组件：生产者（Producer）、消费者（Worker）、任务（Task）、代理（Broker）。
    *   阐述其在现代 Web 应用中的典型应用场景，如发送邮件/通知、处理耗时计算、数据ETL等。

2.  **Asynq 快速入门**
    *   介绍 `Asynq` 及其设计哲学（基于 Redis、简单、高效、可靠）。
    *   **环境准备**：如何安装 `Asynq` 和 `asynqmon`（Web UI）。
    *   **第一个 Asynq 应用**：
        *   **定义任务**：创建一个任务载荷（`Payload`），例如 `type EmailTaskPayload struct { UserID int, Template string }`。
        *   **客户端（生产者）**：初始化 `asynq.Client`，封装并分发一个新任务（`asynq.NewTask`）。
        *   **服务端（消费者）**：
            *   创建 `asynq.Server` 并配置 Redis 连接。
            *   实现一个任务处理器（`Handler`），该处理器接受 `context.Context` 和 `*asynq.Task`，并处理任务逻辑。
            *   注册处理器到 `ServeMux`，并启动服务。

3.  **核心特性与任务生命周期管理**
    *   **任务选项（Task Options）**：在分发任务时，如何配置以下选项，并解释其作用：
        *   `asynq.Queue("critical")`：指定队列。
        *   `asynq.MaxRetry(5)`：设置最大重试次数。
        *   `asynq.Timeout(3 * time.Minute)`：设置任务执行超时。
        *   `asynq.Deadline(time.Now().Add(24 * time.Hour))`：设置任务截止日期。
        *   `asynq.ProcessIn(10 * time.Second)`：延迟执行任务。
    *   **错误处理与重试**：
        *   在 `Handler` 中返回 `error` 会触发自动重试。
        *   解释 `Asynq` 默认的重试策略（指数退避）。
        *   如何自定义重试延迟。

4.  **高级用法与最佳实践**
    *   **唯一任务（Unique Tasks）**：如何使用 `asynq.Unique` 选项确保在特定时间窗口内只有一个同类任务被入队，实现任务幂等性。
    *   **周期性任务（Periodic Tasks）**：
        *   介绍 `asynq.PeriodicTaskManager`。
        *   如何使用 Cron 表达式注册一个周期性任务（例如，`"*/10 * * * *"`）。
    *   **中间件（Middleware）**：
        *   解释 `Asynq` 服务端中间件的概念和用途（如日志记录、Panic 恢复、性能监控）。
        *   提供一个自定义日志中间件的示例。
    *   **优雅停机（Graceful Shutdown）**：如何在收到系统信号（如 `SIGINT`, `SIGTERM`）时，让 `Server` 等待当前正在执行的任务完成后再退出。
    *   **Web UI (`asynqmon`)**：如何启动和使用 `asynqmon` 来监控队列状态、查看任务详情、手动重试或归档任务。

5.  **生产环境考量**
    *   **任务幂等性**：深入探讨为什么幂等性至关重要，并提供在业务逻辑层面实现幂等性的策略（例如，基于任务 ID 或业务唯一标识进行检查）。
    *   **配置与性能**：
        *   `asynq.Config` 中的重要配置项，特别是 `Concurrency`（并发度）。
        *   如何根据业务负载和服务器资源合理设置并发度。
    *   **避免大任务载荷**：解释为什么不应在任务 `Payload` 中传递大量数据，以及替代方案（如传递 ID，由 Worker 自行获取数据）。

**代码示例要求：**

*   提供一个完整、独立的 Go 项目示例。
*   **场景**：一个用户注册后异步发送欢迎邮件的场景。
*   **`client/main.go`**：一个简单的 HTTP 服务器，当访问 `/register` 时，向 `Asynq` 队列中添加一个发送邮件的任务。
*   **`worker/main.go`**：`Asynq` 的 `Server` 和 `Worker`。
    *   实现 `HandleEmailTask` 处理器，模拟发送邮件（可以只是打印日志）。
    *   配置合理的并发度和队列优先级。
    *   实现优雅停机逻辑。
    *   添加一个简单的日志中间件。
*   代码需遵循 Go 语言的最佳实践，注释清晰，逻辑明确。

**总结：**

在文章末尾，总结 `Asynq` 的主要优点，并回顾在生产环境中使用任务队列时需要注意的关键点。鼓励读者将 `Asynq` 应用到自己的项目中。


# `encoding/json`：Go 与 JSON 的高效协作

请你扮演一位 Go 语言的 API 设计与数据序列化专家，为一篇名为《`encoding/json`：Go 与 JSON 的高效协作》的教程生成内容。

**文章目标：** 帮助 Go 开发者完全掌握 `encoding/json` 标准库，能够自如地在 Go 结构体与 JSON 字符串之间进行转换。读者将精通 struct tag 的高级用法、流式处理的性能优势，并学会处理各种复杂的 JSON 场景。

**核心概念：**

1.  **基本操作：序列化 (Marshal) 与反序列化 (Unmarshal)**
    *   **`json.Marshal(v any) ([]byte, error)`：**
        *   将 Go 的数据结构（通常是 struct 或 map）转换为 JSON 字节切片。
        *   强调只有**可导出的（首字母大写）**结构体字段才会被编码。
        *   提供一个简单的 `struct` 到 `[]byte` 的示例。
    *   **`json.Unmarshal(data []byte, v any) error`：**
        *   将 JSON 字节切片解析到 Go 的数据结构中（通常是指向 struct 或 map 的指针）。
        *   强调 `v` 必须是一个指针，否则无法修改原始变量。
        *   提供一个 `[]byte` 到 `struct` 的示例。

2.  **Struct Field Tag：精细控制 JSON 输出**
    *   这是 `encoding/json` 包的精髓。通过一个表格和示例详细讲解 `json` tag 的各种用法：
        *   **重命名字段：** `` `json:"fieldName"` ``
        *   **忽略字段：** `` `json:"-"` ``
        *   **忽略空值字段：** `` `json:"fieldName,omitempty"` `` (适用于 `false`, `0`, `nil` 指针, `nil` 接口, 空数组/切片/map/字符串)
        *   **将字段编码为字符串：** `` `json:"fieldName,string"` `` (常用于需要将数字或布尔值表示为 JSON 字符串的场景)
    *   提供一个复杂的结构体示例，综合运用上述所有 tag，并展示其 JSON 输出结果。

3.  **流式处理：`Encoder` 和 `Decoder`**
    *   **动机：** 为什么要使用流式处理？
        *   **性能与内存效率：** `Marshal` 和 `Unmarshal` 需要将整个 JSON 对象读入内存。对于非常大的 JSON 文件或网络流，`Encoder` 和 `Decoder` 可以边读边处理，内存占用极低。
    *   **`json.NewEncoder(w io.Writer).Encode(v any)`：**
        *   演示如何将一个 Go 结构体直接编码并写入到一个 `io.Writer`（如 `os.Stdout`, `http.ResponseWriter`, `bytes.Buffer`）中。
    *   **`json.NewDecoder(r io.Reader).Decode(v any)`：**
        *   演示如何从一个 `io.Reader`（如 `os.File`, `http.Request.Body`, `strings.Reader`）中直接解码 JSON 到 Go 结构体。
    *   提供一个处理 HTTP 请求体和响应的经典示例，展示 `Encoder`/`Decoder` 的优雅之处。

4.  **自定义编解码：`Marshaler` 和 `Unmarshaler` 接口**
    *   **场景：** 当默认的编解码行为不满足需求时（例如，需要将 `time.Time` 格式化为 Unix 时间戳，或者处理非标准的枚举值）。
    *   **`Marshaler` 接口：**
        *   实现 `MarshalJSON() ([]byte, error)` 方法来自定义类型的序列化逻辑。
    *   **`Unmarshaler` 接口：**
        *   实现 `UnmarshalJSON(data []byte) error` 方法来自定义类型的反序列化逻辑。
    *   提供一个 `time.Time` 的例子，使其可以被编码为 Unix 时间戳（数字），也能从时间戳解码回来。

5.  **处理未知和动态 JSON**
    *   **`map[string]any` (或 `map[string]interface{}`)：**
        *   当 JSON 结构不固定时，可以将其解码到一个 map 中。演示如何操作这个 map 并进行类型断言。
    *   **`json.RawMessage`：**
        *   当需要延迟解析 JSON 的某一部分时，`json.RawMessage` 非常有用。它可以将 JSON 的一个字段作为原始的 `[]byte` 保存下来，留待后续处理。
        *   提供一个示例：解析一个通用的事件信封，根据 `"type"` 字段的值，再将 `"payload"` 字段（`json.RawMessage` 类型）解码到不同的具体结构体中。

6.  **常见陷阱与最佳实践**
    *   **Unexported Fields：** 再次强调未导出的字段会被忽略。
    *   **JSON `null` vs. Go `nil`：** 解码时，JSON 的 `null` 会被正确地赋给 Go 的指针、接口或切片类型的 `nil` 值。
    *   **数字类型处理：** 解码到 `any` (`interface{}`) 时，所有 JSON 数字默认都是 `float64` 类型。介绍如何使用 `Decoder.UseNumber()` 来将其解码为 `json.Number` 类型，从而可以无损地转换为 `int64` 或 `float64`。
    *   **错误处理：** 详细说明 `Unmarshal` 过程中可能遇到的错误，如 `json.SyntaxError`, `json.UnmarshalTypeError`，并给出处理建议。
    *   **性能对比：** 简要提及 `json-iterator/go` 等高性能第三方库，并说明在什么场景下可以考虑替换标准库。

**代码示例要求：**
*   所有代码都必须是完整、可运行的 Go 程序。
*   注释清晰，解释每个关键步骤和 tag 的作用。
*   提供 HTTP server/client 的示例来展示流式处理的实际应用。

**总结：**
回顾 `encoding/json` 包的强大功能和灵活性，从简单的 `Marshal`/`Unmarshal` 到复杂的自定义类型和流式处理，它为 Go 开发者提供了处理 JSON 的全套解决方案。鼓励读者根据具体场景选择最合适的工具。

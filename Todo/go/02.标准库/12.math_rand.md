# `math/rand`：Go 中的伪随机数生成艺术

请你扮演一位对密码学和统计学有深入理解的 Go 语言专家，为一篇名为《`math/rand`：Go 中的伪随机数生成艺术》的教程生成内容。

**文章目标：** 帮助 Go 开发者深入理解 `math/rand` 包的工作原理，掌握正确的伪随机数生成方法，并能清晰地辨别它与 `crypto/rand` 的应用场景。读者将学会如何避免常见错误（如忘记播种），并了解 Go 1.22 中 `math/rand/v2` 带来的改进。

**核心概念：**

1.  **伪随机 vs. 真随机：开篇明义**
    *   **`math/rand` (伪随机)：**
        *   解释其生成的数字是确定性的、可复现的。给定相同的种子（Seed），它将产生完全相同的数字序列。
        *   适用于：模拟、游戏、测试、无安全需求的随机化场景。
    *   **`crypto/rand` (真随机/密码学安全随机)：**
        *   解释其数据源自操作系统的熵（如硬件事件），是不可预测的。
        *   适用于：生成密钥、token、盐值（salt）、验证码等一切对安全性有要求的场景。
    *   **黄金法则：** 只要你的随机数与安全相关，就**必须**使用 `crypto/rand`，否则请使用 `math/rand`。

2.  **`math/rand` (Go 1.22 之前)：播种的必要性**
    *   **`rand.Seed(int64)`：**
        *   详细解释为什么必须调用 `rand.Seed()`。如果不播种，默认种子是 `1`，导致每次程序运行生成的“随机”序列都完全一样。
        *   **最佳实践：** 使用 `rand.Seed(time.Now().UnixNano())` 作为种子，确保每次运行的序列都不同。
        *   强调 `rand.Seed()` 只需在程序启动时调用一次，并且它不是并发安全的。
    *   **全局 `rand` vs. 自定义 `rand.Rand`：**
        *   介绍 `rand.Intn()` 等全局函数，它们使用一个全局的、共享的 `rand.Source`。这在并发环境下会导致锁竞争，影响性能。
        *   **并发最佳实践：** 在需要高并发性能的场景下，为每个 goroutine 创建一个独立的 `rand.New(rand.NewSource(seed))` 实例。这样可以避免锁争用。

3.  **生成随机数：核心函数**
    *   `rand.Intn(n)`：生成 `[0, n)` 范围内的整数。
    *   `rand.Int63n(n)`：生成 `[0, n)` 范围内的 `int64`。
    *   `rand.Float64()`：生成 `[0.0, 1.0)` 范围内的浮点数。
    *   `rand.Perm(n)`：生成一个 `[0, n)` 的随机置换（洗牌后）的切片。
    *   `rand.Shuffle(n, swap)`：一个更通用的洗牌函数，可以用于任何支持索引和交换的集合。
    *   提供清晰的代码示例，演示上述函数的用法，并包含正确的播种逻辑。

4.  **Go 1.22 的新篇章：`math/rand/v2`**
    *   **自动播种：** 这是最大的改进！`math/rand/v2` 包中的函数不再需要手动播种，它在程序启动时会自动使用来自 `crypto/rand` 的高质量种子进行初始化。
    *   **API 变更：**
        *   `rand.Seed()` 已被移除。
        *   `rand.Intn(n)` 变成了 `rand.N(n)`。
        *   `rand.Int63n(n)` 变成了 `rand.N(int64)`。
    *   **性能提升：** 新的实现算法性能更好。
    *   **代码对比：** 提供 Go 1.22 之前和之后的代码片段，清晰地展示 `math/rand/v2` 如何简化代码并避免错误。
    *   **迁移建议：** 鼓励所有 Go 1.22 及以上的项目直接使用 `math/rand/v2`。

5.  **常见陷阱与最佳实践回顾**
    *   **陷阱 1：忘记播种（Go 1.22 之前）。** 再次强调其后果。
    *   **陷阱 2：在并发代码中使用全局 `rand`。** 解释其性能问题，并给出使用 `rand.New` 的正确范式。
    *   **陷阱 3：用 `math/rand` 实现安全功能。** 再次警告这是严重的安全漏洞。
    *   **最佳实践：** 根据 Go 版本选择正确的 `rand` 包，优先使用 `math/rand/v2`。在并发场景中创建独立的 `rand.Rand` 实例。

**代码示例要求：**
*   提供 Go 1.22 之前 (`math/rand`) 和之后 (`math/rand/v2`) 的对比代码。
*   包含一个使用 `crypto/rand` 生成安全随机字节的示例，以作对比。
*   并发示例需要展示如何为 goroutine 创建独立的 `rand.Rand` 实例。

**总结：**
总结 `math/rand` 和 `math/rand/v2` 的演进，强调 Go 社区在提升开发者体验和代码安全性方面的努力。重申“为正确的任务选择正确的工具”这一核心原则。

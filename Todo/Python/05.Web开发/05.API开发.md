# Python API 开发

## 最佳提示词

```
请详细介绍 Python 的 API 开发，包括以下内容：

1. API 基础：
   - RESTful API 设计原则
   - HTTP 方法与状态码
   - API 版本管理
   - 数据格式选择

2. FastAPI 框架：
   - FastAPI 安装与配置
   - 路由定义与参数处理
   - 请求体与响应模型
   - 自动文档生成

3. Flask API 开发：
   - Flask-RESTful 扩展
   - 请求解析与验证
   - 错误处理机制
   - 中间件使用

4. Django REST Framework：
   - 序列化器设计
   - 视图集与路由器
   - 认证与权限
   - 分页与过滤

5. API 安全：
   - 身份认证机制
   - JWT 令牌处理
   - API 限流
   - CORS 配置

6. API 测试与文档：
   - 单元测试编写
   - 集成测试策略
   - API 文档生成
   - 性能测试

请为每个功能提供详细的代码示例，包括实际应用场景和最佳实践。
```

## 学习要点

- 理解 RESTful API 的设计原则
- 掌握不同框架的 API 开发方法
- 学会 API 安全和认证机制
- 了解 API 文档和测试的重要性
- 掌握 API 性能优化技巧
- 学会构建生产级的 API 服务

## 实践练习

1. 使用 FastAPI 创建 RESTful API
2. 实现 JWT 认证系统
3. 开发 API 限流中间件
4. 构建 API 文档和测试
5. 部署 API 服务到生产环境

## 代码示例模板

```python
from fastapi import FastAPI, HTTPException, Depends, status, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, EmailStr, validator
from typing import List, Optional
import jwt
import hashlib
import datetime
import redis
from functools import wraps
import time
import asyncio
import aiohttp
from flask import Flask, request, jsonify
from flask_restful import Api, Resource
from marshmallow import Schema, fields, validate
from rest_framework import serializers, viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.authentication import TokenAuthentication
from rest_framework.permissions import IsAuthenticated
import requests
import unittest
from unittest.mock import patch

# FastAPI 示例
app = FastAPI(
    title="用户管理 API",
    description="一个简单的用户管理系统",
    version="1.0.0"
)

# CORS 中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Redis 连接用于限流
redis_client = redis.Redis(host='localhost', port=6379, db=0)

# Pydantic 模型
class UserBase(BaseModel):
    username: str
    email: EmailStr
    age: Optional[int] = None
    
    @validator('username')
    def validate_username(cls, v):
        if len(v) < 3:
            raise ValueError('用户名至少3个字符')
        return v

class UserCreate(UserBase):
    password: str
    
    @validator('password')
    def validate_password(cls, v):
        if len(v) < 6:
            raise ValueError('密码至少6个字符')
        return v

class UserResponse(UserBase):
    id: int
    created_at: datetime.datetime
    
    class Config:
        orm_mode = True

class UserLogin(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

# JWT 配置
SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# 模拟数据库
fake_db = {}
user_id_counter = 1

# 工具函数
def hash_password(password: str) -> str:
    """密码哈希"""
    return hashlib.sha256(password.encode()).hexdigest()

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """验证密码"""
    return hash_password(plain_password) == hashed_password

def create_access_token(data: dict, expires_delta: Optional[datetime.timedelta] = None):
    """创建访问令牌"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.datetime.utcnow() + expires_delta
    else:
        expire = datetime.datetime.utcnow() + datetime.timedelta(minutes=15)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str):
    """验证令牌"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="无效的认证凭据",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return username
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的认证凭据",
            headers={"WWW-Authenticate": "Bearer"},
        )

# 限流装饰器
def rate_limit(max_requests: int, window_seconds: int):
    """API 限流装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(request: Request, *args, **kwargs):
            client_ip = request.client.host
            key = f"rate_limit:{client_ip}"
            
            current_requests = redis_client.get(key)
            if current_requests is None:
                redis_client.setex(key, window_seconds, 1)
            else:
                current_requests = int(current_requests)
                if current_requests >= max_requests:
                    raise HTTPException(
                        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                        detail="请求过于频繁，请稍后再试"
                    )
                redis_client.incr(key)
            
            return await func(request, *args, **kwargs)
        return wrapper
    return decorator

# 依赖注入
security = HTTPBearer()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """获取当前用户"""
    token = credentials.credentials
    username = verify_token(token)
    
    user = None
    for user_id, user_data in fake_db.items():
        if user_data['username'] == username:
            user = user_data
            break
    
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户不存在"
        )
    
    return user

# API 路由
@app.post("/register", response_model=UserResponse)
@rate_limit(max_requests=5, window_seconds=60)
async def register(user: UserCreate):
    """用户注册"""
    global user_id_counter
    
    # 检查用户名是否已存在
    for existing_user in fake_db.values():
        if existing_user['username'] == user.username:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="用户名已存在"
            )
        if existing_user['email'] == user.email:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="邮箱已存在"
            )
    
    # 创建用户
    user_data = {
        "id": user_id_counter,
        "username": user.username,
        "email": user.email,
        "age": user.age,
        "hashed_password": hash_password(user.password),
        "created_at": datetime.datetime.utcnow()
    }
    
    fake_db[user_id_counter] = user_data
    user_id_counter += 1
    
    return user_data

@app.post("/login", response_model=Token)
@rate_limit(max_requests=10, window_seconds=60)
async def login(user_credentials: UserLogin):
    """用户登录"""
    # 验证用户
    authenticated_user = None
    for user_data in fake_db.values():
        if (user_data['username'] == user_credentials.username and
            verify_password(user_credentials.password, user_data['hashed_password'])):
            authenticated_user = user_data
            break
    
    if not authenticated_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 创建访问令牌
    access_token_expires = datetime.timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": authenticated_user['username']}, 
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me", response_model=UserResponse)
async def read_users_me(current_user: dict = Depends(get_current_user)):
    """获取当前用户信息"""
    return current_user

@app.get("/users", response_model=List[UserResponse])
async def get_users(current_user: dict = Depends(get_current_user)):
    """获取所有用户（需要认证）"""
    return list(fake_db.values())

@app.put("/users/{user_id}", response_model=UserResponse)
async def update_user(
    user_id: int, 
    user_update: UserBase,
    current_user: dict = Depends(get_current_user)
):
    """更新用户信息"""
    if user_id not in fake_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="用户不存在"
        )
    
    # 检查权限（只能更新自己的信息）
    if current_user['id'] != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="没有权限更新此用户"
        )
    
    # 更新用户信息
    user_data = fake_db[user_id]
    user_data.update(user_update.dict(exclude_unset=True))
    
    return user_data

@app.delete("/users/{user_id}")
async def delete_user(
    user_id: int,
    current_user: dict = Depends(get_current_user)
):
    """删除用户"""
    if user_id not in fake_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="用户不存在"
        )
    
    # 检查权限
    if current_user['id'] != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="没有权限删除此用户"
        )
    
    del fake_db[user_id]
    return {"message": "用户删除成功"}

# Flask API 示例
flask_app = Flask(__name__)
api = Api(flask_app)

# Marshmallow Schema
class UserSchema(Schema):
    id = fields.Int(dump_only=True)
    username = fields.Str(required=True, validate=validate.Length(min=3))
    email = fields.Email(required=True)
    age = fields.Int()
    created_at = fields.DateTime(dump_only=True)

# Flask 资源
class UserResource(Resource):
    def get(self, user_id=None):
        """获取用户"""
        if user_id:
            user = fake_db.get(user_id)
            if not user:
                return {'message': '用户不存在'}, 404
            return UserSchema().dump(user)
        else:
            users = list(fake_db.values())
            return UserSchema(many=True).dump(users)
    
    def post(self):
        """创建用户"""
        user_data = request.get_json()
        errors = UserSchema().validate(user_data)
        
        if errors:
            return {'errors': errors}, 400
        
        # 创建用户逻辑...
        return {'message': '用户创建成功'}, 201

api.add_resource(UserResource, '/users', '/users/<int:user_id>')

# Django REST Framework 示例
class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = None  # 实际使用时需要定义模型
        fields = ['id', 'username', 'email', 'age', 'created_at']

class UserViewSet(viewsets.ModelViewSet):
    queryset = None  # 实际使用时需要定义查询集
    serializer_class = UserSerializer
    permission_classes = [IsAuthenticated]
    
    @action(detail=False, methods=['get'])
    def me(self, request):
        """获取当前用户"""
        serializer = self.get_serializer(request.user)
        return Response(serializer.data)

# API 测试示例
class TestUserAPI(unittest.TestCase):
    def setUp(self):
        self.app = app.test_client()
        self.app.testing = True
    
    def test_register_user(self):
        """测试用户注册"""
        user_data = {
            'username': 'testuser',
            'email': 'test@example.com',
            'password': 'testpassword123',
            'age': 25
        }
        
        response = self.app.post('/register', json=user_data)
        self.assertEqual(response.status_code, 200)
        
        data = response.get_json()
        self.assertEqual(data['username'], 'testuser')
        self.assertEqual(data['email'], 'test@example.com')
    
    def test_login_user(self):
        """测试用户登录"""
        # 先注册用户
        user_data = {
            'username': 'testuser2',
            'email': 'test2@example.com',
            'password': 'testpassword123'
        }
        self.app.post('/register', json=user_data)
        
        # 登录
        login_data = {
            'username': 'testuser2',
            'password': 'testpassword123'
        }
        
        response = self.app.post('/login', json=login_data)
        self.assertEqual(response.status_code, 200)
        
        data = response.get_json()
        self.assertIn('access_token', data)
        self.assertIn('token_type', data)
    
    def test_get_current_user(self):
        """测试获取当前用户"""
        # 注册并登录用户
        user_data = {
            'username': 'testuser3',
            'email': 'test3@example.com',
            'password': 'testpassword123'
        }
        self.app.post('/register', json=user_data)
        
        login_data = {
            'username': 'testuser3',
            'password': 'testpassword123'
        }
        
        login_response = self.app.post('/login', json=login_data)
        token = login_response.get_json()['access_token']
        
        # 获取当前用户
        headers = {'Authorization': f'Bearer {token}'}
        response = self.app.get('/users/me', headers=headers)
        
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertEqual(data['username'], 'testuser3')

# 异步 API 客户端示例
class APIClient:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def register_user(self, user_data: dict):
        """注册用户"""
        async with self.session.post(
            f"{self.base_url}/register",
            json=user_data
        ) as response:
            return await response.json()
    
    async def login_user(self, username: str, password: str):
        """用户登录"""
        login_data = {
            'username': username,
            'password': password
        }
        
        async with self.session.post(
            f"{self.base_url}/login",
            json=login_data
        ) as response:
            return await response.json()
    
    async def get_current_user(self, token: str):
        """获取当前用户"""
        headers = {'Authorization': f'Bearer {token}'}
        
        async with self.session.get(
            f"{self.base_url}/users/me",
            headers=headers
        ) as response:
            return await response.json()

# 使用示例
async def main():
    # 使用异步客户端
    async with APIClient("http://localhost:8000") as client:
        # 注册用户
        user_data = {
            'username': 'async_user',
            'email': 'async@example.com',
            'password': 'password123',
            'age': 30
        }
        
        register_result = await client.register_user(user_data)
        print(f"注册结果: {register_result}")
        
        # 登录
        login_result = await client.login_user('async_user', 'password123')
        print(f"登录结果: {login_result}")
        
        # 获取当前用户
        token = login_result['access_token']
        current_user = await client.get_current_user(token)
        print(f"当前用户: {current_user}")

# API 文档生成
def generate_api_documentation():
    """生成 API 文档"""
    docs = {
        "title": "用户管理 API",
        "version": "1.0.0",
        "description": "一个简单的用户管理系统 API",
        "endpoints": [
            {
                "path": "/register",
                "method": "POST",
                "description": "用户注册",
                "request_body": {
                    "username": "string (required)",
                    "email": "string (required)",
                    "password": "string (required)",
                    "age": "integer (optional)"
                },
                "responses": {
                    "200": "用户创建成功",
                    "400": "请求参数错误",
                    "429": "请求过于频繁"
                }
            },
            {
                "path": "/login",
                "method": "POST",
                "description": "用户登录",
                "request_body": {
                    "username": "string (required)",
                    "password": "string (required)"
                },
                "responses": {
                    "200": "登录成功，返回访问令牌",
                    "401": "用户名或密码错误"
                }
            }
        ]
    }
    
    return docs

if __name__ == "__main__":
    # 运行 FastAPI 应用
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
    
    # 运行异步客户端示例
    # asyncio.run(main())
    
    # 生成 API 文档
    docs = generate_api_documentation()
    print(f"API 文档: {docs}")
```

## 扩展资源

- [FastAPI 官方文档](https://fastapi.tiangolo.com/)
- [Flask-RESTful 文档](https://flask-restful.readthedocs.io/)
- [Django REST Framework 文档](https://www.django-rest-framework.org/)
- [JWT 官方网站](https://jwt.io/)
- [OpenAPI 规范](https://swagger.io/specification/)
- [API 测试最佳实践](https://martinfowler.com/articles/practical-test-pyramid.html)
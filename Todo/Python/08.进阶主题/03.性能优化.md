# Python 性能优化

## 最佳提示词

```
请详细介绍 Python 的性能优化，包括以下内容：

1. 性能分析基础：
   - 性能测量工具
   - 时间复杂度分析
   - 内存使用分析
   - 瓶颈识别方法

2. 代码优化技巧：
   - 算法选择与优化
   - 数据结构优化
   - 循环优化
   - 字符串处理优化

3. 内存管理：
   - 内存泄漏检测
   - 对象生命周期管理
   - 缓存策略
   - 垃圾回收优化

4. 并发与并行：
   - 多线程优化
   - 多进程优化
   - 异步编程优化
   - GIL 影响分析

5. 编译与加速：
   - Cython 使用
   - Numba JIT 编译
   - PyPy 解释器
   - C 扩展开发

6. 系统级优化：
   - 操作系统调优
   - 网络优化
   - I/O 优化
   - 数据库查询优化

请为每个优化技术提供详细的代码示例，包括实际应用场景和性能对比。
```

## 学习要点

- 理解性能分析的基本方法和工具
- 掌握代码级别的优化技巧
- 学会内存管理和泄漏检测
- 了解并发编程的性能影响
- 掌握编译加速技术
- 学会系统级的性能调优

## 实践练习

1. 使用性能分析工具识别瓶颈
2. 优化算法和数据结构
3. 实现高效的缓存机制
4. 使用 Cython 加速关键代码
5. 进行系统级性能调优

## 代码示例模板

```python
import time
import cProfile
import pstats
import memory_profiler
import tracemalloc
import gc
import numpy as np
from functools import lru_cache
from collections import defaultdict
import multiprocessing
import threading
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import dis
import sys
from typing import List, Dict, Any
import weakref

# 性能分析基础
def performance_profiling_example():
    """性能分析示例"""
    
    def slow_function():
        """慢函数示例"""
        total = 0
        for i in range(1000000):
            total += i * i
        return total
    
    # 时间测量
    start_time = time.time()
    result = slow_function()
    end_time = time.time()
    
    print(f"执行结果: {result}")
    print(f"执行时间: {end_time - start_time:.4f}秒")
    
    # cProfile 分析
    cProfile.run('slow_function()', 'profile_stats')
    
    # 分析结果
    stats = pstats.Stats('profile_stats')
    stats.sort_stats('cumulative')
    print("\n性能分析结果:")
    stats.print_stats(10)

# 内存分析
@memory_profiler.profile
def memory_analysis_example():
    """内存分析示例"""
    
    # 创建大列表
    large_list = [i for i in range(1000000)]
    
    # 创建字典
    large_dict = {i: f"value_{i}" for i in range(100000)}
    
    # 内存使用情况
    print(f"列表大小: {sys.getsizeof(large_list)} 字节")
    print(f"字典大小: {sys.getsizeof(large_dict)} 字节")
    
    # 删除对象
    del large_list
    del large_dict
    
    # 强制垃圾回收
    gc.collect()

# 内存泄漏检测
def memory_leak_detection():
    """内存泄漏检测示例"""
    
    # 启动内存跟踪
    tracemalloc.start()
    
    # 记录初始内存
    snapshot1 = tracemalloc.take_snapshot()
    
    # 创建可能导致内存泄漏的代码
    leaked_objects = []
    
    for i in range(10000):
        # 创建对象但不释放
        obj = {'data': f"item_{i}" * 100}
        leaked_objects.append(obj)
    
    # 记录当前内存
    snapshot2 = tracemalloc.take_snapshot()
    
    # 比较内存快照
    top_stats = snapshot2.compare_to(snapshot1, 'lineno')
    print("\n内存增长前10:")
    for stat in top_stats[:10]:
        print(stat)

# 算法优化
def algorithm_optimization():
    """算法优化示例"""
    
    # 低效的查找算法
    def inefficient_search(arr, target):
        """线性搜索"""
        for item in arr:
            if item == target:
                return True
        return False
    
    # 高效的查找算法
    def efficient_search(arr, target):
        """二分搜索（假设数组已排序）"""
        left, right = 0, len(arr) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                return True
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return False
    
    # 测试数据
    sorted_array = list(range(1000000))
    target = 999999
    
    # 性能对比
    start_time = time.time()
    result1 = inefficient_search(sorted_array, target)
    time1 = time.time() - start_time
    
    start_time = time.time()
    result2 = efficient_search(sorted_array, target)
    time2 = time.time() - start_time
    
    print(f"线性搜索结果: {result1}, 时间: {time1:.6f}秒")
    print(f"二分搜索结果: {result2}, 时间: {time2:.6f}秒")
    print(f"性能提升: {time1/time2:.2f}倍")

# 数据结构优化
def data_structure_optimization():
    """数据结构优化示例"""
    
    # 低效的字符串连接
    def inefficient_concatenation(strings):
        """使用 + 连接字符串"""
        result = ""
        for s in strings:
            result += s
        return result
    
    # 高效的字符串连接
    def efficient_concatenation(strings):
        """使用 join 连接字符串"""
        return "".join(strings)
    
    # 测试数据
    strings = [f"string_{i}" for i in range(10000)]
    
    # 性能对比
    start_time = time.time()
    result1 = inefficient_concatenation(strings)
    time1 = time.time() - start_time
    
    start_time = time.time()
    result2 = efficient_concatenation(strings)
    time2 = time.time() - start_time
    
    print(f"低效连接时间: {time1:.6f}秒")
    print(f"高效连接时间: {time2:.6f}秒")
    print(f"性能提升: {time1/time2:.2f}倍")
    
    # 列表 vs 集合查找
    large_list = list(range(100000))
    large_set = set(range(100000))
    
    # 列表查找
    start_time = time.time()
    for i in range(1000):
        _ = i in large_list
    list_time = time.time() - start_time
    
    # 集合查找
    start_time = time.time()
    for i in range(1000):
        _ = i in large_set
    set_time = time.time() - start_time
    
    print(f"\n列表查找时间: {list_time:.6f}秒")
    print(f"集合查找时间: {set_time:.6f}秒")
    print(f"性能提升: {list_time/set_time:.2f}倍")

# 循环优化
def loop_optimization():
    """循环优化示例"""
    
    # 低效的循环
    def inefficient_loop():
        total = 0
        for i in range(1000000):
            total += i * i
        return total
    
    # 优化的循环（使用内置函数）
    def optimized_loop():
        return sum(i * i for i in range(1000000))
    
    # NumPy 优化
    def numpy_optimized():
        arr = np.arange(1000000)
        return np.sum(arr * arr)
    
    # 性能对比
    start_time = time.time()
    result1 = inefficient_loop()
    time1 = time.time() - start_time
    
    start_time = time.time()
    result2 = optimized_loop()
    time2 = time.time() - start_time
    
    start_time = time.time()
    result3 = numpy_optimized()
    time3 = time.time() - start_time
    
    print(f"低效循环时间: {time1:.6f}秒")
    print(f"优化循环时间: {time2:.6f}秒")
    print(f"NumPy优化时间: {time3:.6f}秒")
    print(f"循环优化提升: {time1/time2:.2f}倍")
    print(f"NumPy优化提升: {time1/time3:.2f}倍")

# 缓存优化
@lru_cache(maxsize=128)
def fibonacci_cached(n):
    """带缓存的斐波那契数列"""
    if n < 2:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

def fibonacci_uncached(n):
    """不带缓存的斐波那契数列"""
    if n < 2:
        return n
    return fibonacci_uncached(n-1) + fibonacci_uncached(n-2)

def caching_optimization():
    """缓存优化示例"""
    
    # 测试数据
    n = 35
    
    # 无缓存版本
    start_time = time.time()
    result1 = fibonacci_uncached(n)
    time1 = time.time() - start_time
    
    # 清除缓存
    fibonacci_cached.cache_clear()
    
    # 有缓存版本
    start_time = time.time()
    result2 = fibonacci_cached(n)
    time2 = time.time() - start_time
    
    print(f"无缓存结果: {result1}, 时间: {time1:.6f}秒")
    print(f"有缓存结果: {result2}, 时间: {time2:.6f}秒")
    print(f"性能提升: {time1/time2:.2f}倍")
    print(f"缓存信息: {fibonacci_cached.cache_info()}")

# 并发优化
def concurrency_optimization():
    """并发优化示例"""
    
    def cpu_bound_task(n):
        """CPU密集型任务"""
        total = 0
        for i in range(n):
            total += i * i
        return total
    
    def io_bound_task(duration):
        """I/O密集型任务"""
        time.sleep(duration)
        return f"任务完成，耗时{duration}秒"
    
    # 顺序执行
    start_time = time.time()
    results1 = [cpu_bound_task(100000) for _ in range(4)]
    sequential_time = time.time() - start_time
    
    # 多线程执行（适合I/O密集型）
    start_time = time.time()
    with ThreadPoolExecutor(max_workers=4) as executor:
        results2 = list(executor.map(io_bound_task, [0.1, 0.1, 0.1, 0.1]))
    thread_time = time.time() - start_time
    
    # 多进程执行（适合CPU密集型）
    start_time = time.time()
    with ProcessPoolExecutor(max_workers=4) as executor:
        results3 = list(executor.map(cpu_bound_task, [100000] * 4))
    process_time = time.time() - start_time
    
    print(f"顺序执行时间: {sequential_time:.6f}秒")
    print(f"多线程执行时间: {thread_time:.6f}秒")
    print(f"多进程执行时间: {process_time:.6f}秒")
    print(f"多进程优化提升: {sequential_time/process_time:.2f}倍")

# 字节码分析
def bytecode_analysis():
    """字节码分析示例"""
    
    def example_function(x, y):
        """示例函数"""
        result = x + y
        if result > 10:
            result *= 2
        return result
    
    # 反汇编字节码
    print("函数字节码:")
    dis.dis(example_function)

# 内存视图优化
def memory_view_optimization():
    """内存视图优化示例"""
    
    # 创建大字节数据
    data = bytearray(range(1000000))
    
    # 低效的数据复制
    start_time = time.time()
    copied_data = bytes(data)
    sum1 = sum(copied_data)
    time1 = time.time() - start_time
    
    # 高效的内存视图
    start_time = time.time()
    memory_view = memoryview(data)
    sum2 = sum(memory_view)
    time2 = time.time() - start_time
    
    print(f"数据复制时间: {time1:.6f}秒")
    print(f"内存视图时间: {time2:.6f}秒")
    print(f"性能提升: {time1/time2:.2f}倍")

# 生成器优化
def generator_optimization():
    """生成器优化示例"""
    
    # 低效的列表创建
    def inefficient_list():
        """创建大列表"""
        return [i * i for i in range(1000000)]
    
    # 高效的生成器
    def efficient_generator():
        """创建生成器"""
        for i in range(1000000):
            yield i * i
    
    # 内存使用对比
    start_time = time.time()
    list_result = inefficient_list()
    list_time = time.time() - start_time
    list_size = sys.getsizeof(list_result)
    
    start_time = time.time()
    gen_result = list(efficient_generator())
    gen_time = time.time() - start_time
    gen_size = sys.getsizeof(gen_result)
    
    print(f"列表创建时间: {list_time:.6f}秒，内存: {list_size}字节")
    print(f"生成器时间: {gen_time:.6f}秒，内存: {gen_size}字节")

# 弱引用优化
def weak_reference_optimization():
    """弱引用优化示例"""
    
    class CacheItem:
        """缓存项类"""
        def __init__(self, data):
            self.data = data
    
    # 使用弱引用的缓存
    cache = weakref.WeakValueDictionary()
    
    def get_cached_item(key):
        """获取缓存项"""
        item = cache.get(key)
        if item is None:
            item = CacheItem(f"data_for_{key}")
            cache[key] = item
        return item
    
    # 测试缓存
    for i in range(1000):
        item = get_cached_item(i)
        _ = item.data  # 访问数据
    
    print(f"缓存大小: {len(cache)}")
    
    # 删除强引用
    strong_refs = [cache[i] for i in list(cache.keys())[:100]]
    del strong_refs
    
    # 强制垃圾回收
    gc.collect()
    print(f"垃圾回收后缓存大小: {len(cache)}")

# 性能监控装饰器
def performance_monitor(func):
    """性能监控装饰器"""
    def wrapper(*args, **kwargs):
        start_time = time.time()
        start_memory = tracemalloc.get_traced_memory()[0]
        
        result = func(*args, **kwargs)
        
        end_time = time.time()
        end_memory = tracemalloc.get_traced_memory()[0]
        
        execution_time = end_time - start_time
        memory_used = (end_memory - start_memory) / 1024  # KB
        
        print(f"函数 {func.__name__}:")
        print(f"  执行时间: {execution_time:.6f}秒")
        print(f"  内存使用: {memory_used:.2f}KB")
        
        return result
    return wrapper

@performance_monitor
def example_function():
    """示例函数"""
    total = 0
    for i in range(100000):
        total += i
    return total

# Cython 优化示例（伪代码）
def cython_optimization_example():
    """Cython 优化示例"""
    
    # 纯 Python 版本
    def python_sum(n):
        total = 0
        for i in range(n):
            total += i * i
        return total
    
    # Cython 版本（假设已编译）
    # def cython_sum(int n):
    #     cdef int total = 0
    #     cdef int i
    #     for i in range(n):
    #         total += i * i
    #     return total
    
    # 性能对比
    n = 1000000
    
    start_time = time.time()
    result1 = python_sum(n)
    python_time = time.time() - start_time
    
    # start_time = time.time()
    # result2 = cython_sum(n)
    # cython_time = time.time() - start_time
    
    print(f"Python版本时间: {python_time:.6f}秒")
    # print(f"Cython版本时间: {cython_time:.6f}秒")
    # print(f"Cython优化提升: {python_time/cython_time:.2f}倍")

# 主函数
def main():
    """主函数，运行所有优化示例"""
    print("=== 性能分析基础 ===")
    performance_profiling_example()
    
    print("\n=== 内存分析 ===")
    memory_analysis_example()
    
    print("\n=== 内存泄漏检测 ===")
    memory_leak_detection()
    
    print("\n=== 算法优化 ===")
    algorithm_optimization()
    
    print("\n=== 数据结构优化 ===")
    data_structure_optimization()
    
    print("\n=== 循环优化 ===")
    loop_optimization()
    
    print("\n=== 缓存优化 ===")
    caching_optimization()
    
    print("\n=== 并发优化 ===")
    concurrency_optimization()
    
    print("\n=== 字节码分析 ===")
    bytecode_analysis()
    
    print("\n=== 内存视图优化 ===")
    memory_view_optimization()
    
    print("\n=== 生成器优化 ===")
    generator_optimization()
    
    print("\n=== 弱引用优化 ===")
    weak_reference_optimization()
    
    print("\n=== 性能监控 ===")
    example_function()
    
    print("\n=== Cython 优化 ===")
    cython_optimization_example()

if __name__ == "__main__":
    # 启动内存跟踪
    tracemalloc.start()
    
    try:
        main()
    finally:
        # 停止内存跟踪
        tracemalloc.stop()
```

## 扩展资源

- [cProfile 文档](https://docs.python.org/3/library/profile.html)
- [memory_profiler 文档](https://pypi.org/project/memory-profiler/)
- [line_profiler 文档](https://pypi.org/project/line_profiler/)
- [Cython 文档](https://cython.readthedocs.io/)
- [Numba 文档](https://numba.pydata.org/)
- [Python 性能优化指南](https://wiki.python.org/moin/PythonSpeed/PerformanceTips)
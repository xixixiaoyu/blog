# Python 异步编程

## 最佳提示词

```
请详细介绍 Python 的异步编程，包括以下内容：

1. 异步编程基础：
   - 异步编程概念
   - 协程与生成器
   - 事件循环机制
   - 并发与并行区别

2. asyncio 模块：
   - 事件循环管理
   - 协程创建与调度
   - 任务与 Future
   - 异步上下文管理

3. 异步 I/O 操作：
   - 异步文件操作
   - 异步网络编程
   - 异步数据库访问
   - 异步 HTTP 客户端

4. 异步框架集成：
   - FastAPI 异步处理
   - aiohttp Web 框架
   - 异步数据库 ORM
   - 异步任务队列

5. 异步模式与最佳实践：
   - 异步生成器
   - 异步迭代器
   - 异步上下文管理器
   - 异步装饰器

6. 性能优化与调试：
   - 异步性能分析
   - 常见陷阱与解决方案
   - 异步代码测试
   - 调试技巧

请为每个概念提供详细的代码示例，包括实际应用场景和最佳实践。
```

## 学习要点

- 理解异步编程的基本概念和优势
- 掌握 asyncio 模块的核心功能
- 学会编写异步 I/O 操作
- 了解异步框架的使用方法
- 掌握异步编程的设计模式
- 学会优化和调试异步代码

## 实践练习

1. 实现基本的协程和事件循环
2. 创建异步 HTTP 客户端
3. 开发异步 Web 服务器
4. 实现异步数据库操作
5. 构建异步任务处理系统

## 代码示例模板

```python
import asyncio
import aiohttp
import aiofiles
import asyncpg
import time
from typing import List, Dict, AsyncGenerator
from contextlib import asynccontextmanager
import logging
from functools import wraps

# 异步编程基础概念
async def basic_coroutine():
    """基本协程示例"""
    print("协程开始")
    await asyncio.sleep(1)  # 模拟异步操作
    print("协程结束")
    return "协程结果"

async def coroutine_with_exception():
    """带异常的协程"""
    print("协程开始")
    await asyncio.sleep(0.5)
    raise ValueError("协程异常")

async def exception_handling():
    """异常处理示例"""
    try:
        result = await coroutine_with_exception()
        print(f"结果: {result}")
    except ValueError as e:
        print(f"捕获异常: {e}")
    finally:
        print("清理资源")

# 事件循环管理
def event_loop_management():
    """事件循环管理示例"""
    # 获取当前事件循环
    loop = asyncio.get_event_loop()
    print(f"当前事件循环: {loop}")
    
    # 运行协程
    result = loop.run_until_complete(basic_coroutine())
    print(f"协程结果: {result}")
    
    # 创建新的事件循环
    new_loop = asyncio.new_event_loop()
    asyncio.set_event_loop(new_loop)
    
    try:
        result = new_loop.run_until_complete(basic_coroutine())
        print(f"新循环结果: {result}")
    finally:
        new_loop.close()

# 任务与 Future
async def task_management():
    """任务管理示例"""
    # 创建任务
    task1 = asyncio.create_task(basic_coroutine())
    task2 = asyncio.create_task(basic_coroutine())
    
    print("任务已创建")
    
    # 等待任务完成
    result1 = await task1
    result2 = await task2
    
    print(f"任务1结果: {result1}")
    print(f"任务2结果: {result2}")
    
    # 并发执行多个任务
    tasks = [
        asyncio.create_task(basic_coroutine()),
        asyncio.create_task(basic_coroutine()),
        asyncio.create_task(basic_coroutine())
    ]
    
    results = await asyncio.gather(*tasks)
    print(f"并发任务结果: {results}")
    
    # 带异常处理的并发执行
    tasks_with_exception = [
        asyncio.create_task(basic_coroutine()),
        asyncio.create_task(coroutine_with_exception()),
        asyncio.create_task(basic_coroutine())
    ]
    
    results = await asyncio.gather(*tasks_with_exception, return_exceptions=True)
    print(f"带异常的并发结果: {results}")

# 异步生成器
async def async_generator():
    """异步生成器示例"""
    for i in range(5):
        await asyncio.sleep(0.5)
        yield f"值 {i}"

async def async_generator_consumer():
    """异步生成器消费者"""
    async for value in async_generator():
        print(f"接收到: {value}")

# 异步迭代器
class AsyncCounter:
    """异步迭代器类"""
    
    def __init__(self, limit: int):
        self.limit = limit
        self.count = 0
    
    def __aiter__(self):
        return self
    
    async def __anext__(self):
        if self.count < self.limit:
            await asyncio.sleep(0.1)
            self.count += 1
            return self.count
        else:
            raise StopAsyncIteration

async def async_iterator_example():
    """异步迭代器示例"""
    counter = AsyncCounter(5)
    
    async for value in counter:
        print(f"计数器值: {value}")

# 异步上下文管理器
class AsyncTimer:
    """异步计时器上下文管理器"""
    
    def __init__(self):
        self.start_time = None
    
    async def __aenter__(self):
        self.start_time = time.time()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        end_time = time.time()
        print(f"执行时间: {end_time - self.start_time:.2f}秒")

@asynccontextmanager
async def async_file_manager(filename: str, mode: str = 'r'):
    """异步文件管理器"""
    file = await aiofiles.open(filename, mode)
    try:
        yield file
    finally:
        await file.close()

async def async_context_example():
    """异步上下文管理器示例"""
    async with AsyncTimer():
        print("开始异步操作")
        await asyncio.sleep(1)
        print("异步操作完成")
    
    async with async_file_manager('example.txt', 'w') as f:
        await f.write('异步写入的内容')

# 异步装饰器
def async_retry(max_attempts: int = 3, delay: float = 1.0):
    """异步重试装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    if attempt < max_attempts - 1:
                        print(f"尝试 {attempt + 1} 失败，{delay}秒后重试...")
                        await asyncio.sleep(delay)
            
            raise last_exception
        return wrapper
    return decorator

@async_retry(max_attempts=3, delay=0.5)
async def unreliable_operation():
    """不可靠操作示例"""
    import random
    if random.random() < 0.7:  # 70% 失败率
        raise ConnectionError("连接失败")
    return "操作成功"

# 异步 HTTP 客户端
class AsyncHTTPClient:
    """异步 HTTP 客户端"""
    
    def __init__(self):
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def get(self, url: str) -> Dict:
        """GET 请求"""
        async with self.session.get(url) as response:
            return await response.json()
    
    async def post(self, url: str, data: Dict) -> Dict:
        """POST 请求"""
        async with self.session.post(url, json=data) as response:
            return await response.json()

async def fetch_multiple_urls(urls: List[str]) -> List[Dict]:
    """并发获取多个 URL"""
    async with AsyncHTTPClient() as client:
        tasks = [client.get(url) for url in urls]
        return await asyncio.gather(*tasks)

# 异步文件操作
async def async_file_operations():
    """异步文件操作示例"""
    # 写入文件
    async with aiofiles.open('async_example.txt', 'w') as f:
        await f.write('异步写入的内容\n')
        await f.write('第二行内容\n')
    
    # 读取文件
    async with aiofiles.open('async_example.txt', 'r') as f:
        content = await f.read()
        print(f"文件内容: {content}")
    
    # 逐行读取
    async with aiofiles.open('async_example.txt', 'r') as f:
        async for line in f:
            print(f"行: {line.strip()}")

# 异步数据库操作
class AsyncDatabaseManager:
    """异步数据库管理器"""
    
    def __init__(self, connection_string: str):
        self.connection_string = connection_string
        self.connection = None
    
    async def __aenter__(self):
        self.connection = await asyncpg.connect(self.connection_string)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.connection:
            await self.connection.close()
    
    async def create_table(self):
        """创建表"""
        await self.connection.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id SERIAL PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                email VARCHAR(100) UNIQUE NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
    
    async def insert_user(self, name: str, email: str):
        """插入用户"""
        result = await self.connection.fetchval(
            'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id',
            name, email
        )
        return result
    
    async def get_user(self, user_id: int):
        """获取用户"""
        result = await self.connection.fetchrow(
            'SELECT * FROM users WHERE id = $1',
            user_id
        )
        return dict(result) if result else None
    
    async def get_all_users(self):
        """获取所有用户"""
        result = await self.connection.fetch('SELECT * FROM users ORDER BY created_at')
        return [dict(row) for row in result]

async def async_database_example():
    """异步数据库示例"""
    connection_string = "postgresql://user:password@localhost/testdb"
    
    async with AsyncDatabaseManager(connection_string) as db:
        await db.create_table()
        
        # 插入用户
        user_id = await db.insert_user('Alice', 'alice@example.com')
        print(f"插入用户ID: {user_id}")
        
        # 获取用户
        user = await db.get_user(user_id)
        print(f"获取用户: {user}")
        
        # 获取所有用户
        all_users = await db.get_all_users()
        print(f"所有用户: {all_users}")

# 异步 Web 服务器
from aiohttp import web

async def handle_hello(request):
    """处理 hello 请求"""
    name = request.match_info.get('name', 'World')
    return web.Response(text=f"Hello, {name}!")

async def handle_users(request):
    """处理用户列表请求"""
    # 模拟数据库查询
    await asyncio.sleep(0.1)
    users = [
        {'id': 1, 'name': 'Alice'},
        {'id': 2, 'name': 'Bob'},
        {'id': 3, 'name': 'Charlie'}
    ]
    return web.json_response(users)

async def handle_create_user(request):
    """处理创建用户请求"""
    data = await request.json()
    
    # 模拟数据库插入
    await asyncio.sleep(0.1)
    user = {
        'id': 4,
        'name': data.get('name'),
        'email': data.get('email')
    }
    
    return web.json_response(user, status=201)

def create_async_web_app():
    """创建异步 Web 应用"""
    app = web.Application()
    
    # 路由配置
    app.router.add_get('/', handle_hello)
    app.router.add_get('/hello/{name}', handle_hello)
    app.router.add_get('/users', handle_users)
    app.router.add_post('/users', handle_create_user)
    
    return app

# 异步任务队列
import asyncio
from typing import Callable, Any
from collections import deque

class AsyncTaskQueue:
    """异步任务队列"""
    
    def __init__(self, max_workers: int = 3):
        self.queue = asyncio.Queue()
        self.max_workers = max_workers
        self.workers = []
        self.running = False
    
    async def add_task(self, func: Callable, *args, **kwargs):
        """添加任务到队列"""
        task = {
            'func': func,
            'args': args,
            'kwargs': kwargs,
            'future': asyncio.Future()
        }
        await self.queue.put(task)
        return task['future']
    
    async def worker(self):
        """工作协程"""
        while self.running:
            try:
                task = await asyncio.wait_for(self.queue.get(), timeout=1.0)
                func = task['func']
                args = task['args']
                kwargs = task['kwargs']
                
                try:
                    result = await func(*args, **kwargs)
                    task['future'].set_result(result)
                except Exception as e:
                    task['future'].set_exception(e)
                
                self.queue.task_done()
                
            except asyncio.TimeoutError:
                continue
    
    async def start(self):
        """启动工作协程"""
        self.running = True
        self.workers = [
            asyncio.create_task(self.worker())
            for _ in range(self.max_workers)
        ]
    
    async def stop(self):
        """停止工作协程"""
        self.running = False
        await asyncio.gather(*self.workers)

# 示例任务函数
async def example_task(task_id: int, duration: float):
    """示例任务函数"""
    print(f"任务 {task_id} 开始")
    await asyncio.sleep(duration)
    print(f"任务 {task_id} 完成")
    return f"任务 {task_id} 结果"

async def async_task_queue_example():
    """异步任务队列示例"""
    queue = AsyncTaskQueue(max_workers=2)
    await queue.start()
    
    try:
        # 添加任务
        tasks = [
            queue.add_task(example_task, i, i * 0.5)
            for i in range(1, 6)
        ]
        
        # 等待所有任务完成
        results = await asyncio.gather(*tasks)
        print(f"所有任务结果: {results}")
        
    finally:
        await queue.stop()

# 性能监控
class AsyncPerformanceMonitor:
    """异步性能监控器"""
    
    def __init__(self):
        self.metrics = {}
    
    def track_execution_time(self, func_name: str):
        """执行时间跟踪装饰器"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                start_time = time.time()
                try:
                    result = await func(*args, **kwargs)
                    execution_time = time.time() - start_time
                    self.record_metric(func_name, execution_time, 'success')
                    return result
                except Exception as e:
                    execution_time = time.time() - start_time
                    self.record_metric(func_name, execution_time, 'error')
                    raise e
            return wrapper
        return decorator
    
    def record_metric(self, func_name: str, execution_time: float, status: str):
        """记录指标"""
        if func_name not in self.metrics:
            self.metrics[func_name] = {
                'total_calls': 0,
                'total_time': 0.0,
                'success_calls': 0,
                'error_calls': 0,
                'avg_time': 0.0
            }
        
        metrics = self.metrics[func_name]
        metrics['total_calls'] += 1
        metrics['total_time'] += execution_time
        
        if status == 'success':
            metrics['success_calls'] += 1
        else:
            metrics['error_calls'] += 1
        
        metrics['avg_time'] = metrics['total_time'] / metrics['total_calls']
    
    def get_metrics(self) -> Dict:
        """获取指标"""
        return self.metrics

# 使用性能监控
monitor = AsyncPerformanceMonitor()

@monitor.track_execution_time('monitored_function')
async def monitored_function(duration: float):
    """被监控的函数"""
    await asyncio.sleep(duration)
    return "监控函数完成"

async def performance_monitoring_example():
    """性能监控示例"""
    # 执行多次被监控的函数
    for i in range(5):
        try:
            await monitored_function(i * 0.1)
        except Exception:
            pass
    
    # 获取性能指标
    metrics = monitor.get_metrics()
    print(f"性能指标: {metrics}")

# 主函数
async def main():
    """主函数，运行所有示例"""
    print("=== 异步编程基础 ===")
    await basic_coroutine()
    await exception_handling()
    
    print("\n=== 事件循环管理 ===")
    event_loop_management()
    
    print("\n=== 任务管理 ===")
    await task_management()
    
    print("\n=== 异步生成器 ===")
    await async_generator_consumer()
    
    print("\n=== 异步迭代器 ===")
    await async_iterator_example()
    
    print("\n=== 异步上下文管理器 ===")
    await async_context_example()
    
    print("\n=== 异步装饰器 ===")
    try:
        await unreliable_operation()
    except Exception as e:
        print(f"最终异常: {e}")
    
    print("\n=== 异步 HTTP 客户端 ===")
    urls = [
        'https://jsonplaceholder.typicode.com/todos/1',
        'https://jsonplaceholder.typicode.com/todos/2',
        'https://jsonplaceholder.typicode.com/todos/3'
    ]
    
    try:
        results = await fetch_multiple_urls(urls)
        print(f"HTTP 请求结果: {len(results)} 个响应")
    except Exception as e:
        print(f"HTTP 请求错误: {e}")
    
    print("\n=== 异步文件操作 ===")
    await async_file_operations()
    
    print("\n=== 异步任务队列 ===")
    await async_task_queue_example()
    
    print("\n=== 性能监控 ===")
    await performance_monitoring_example()

if __name__ == "__main__":
    # 运行异步主函数
    asyncio.run(main())
    
    # 或者运行 Web 服务器
    # app = create_async_web_app()
    # web.run_app(app, host='0.0.0.0', port=8080)
```

## 扩展资源

- [asyncio 官方文档](https://docs.python.org/3/library/asyncio.html)
- [aiohttp 文档](https://aiohttp.readthedocs.io/)
- [aiofiles 文档](https://aiofiles.readthedocs.io/)
- [asyncpg 文档](https://magicstack.github.io/asyncpg/)
- [FastAPI 异步文档](https://fastapi.tiangolo.com/async/)
- [Python 异步编程指南](https://docs.python.org/3/library/asyncio-task.html)
# Python 内置数据结构

## 最佳提示词

```
请详细介绍 Python 的内置数据结构，包括以下内容：

1. 列表（List）：
   - 列表的创建与初始化
   - 列表的索引与切片操作
   - 列表的常用方法（append、extend、insert、remove、pop等）
   - 列表的排序与反转
   - 列表推导式
   - 列表的性能特点与适用场景
   - 列表与数组的区别

2. 元组（Tuple）：
   - 元组的创建与特性
   - 元组的不可变性
   - 元组的解包操作
   - 命名元组（namedtuple）
   - 元组的性能优势
   - 元组的适用场景

3. 字典（Dictionary）：
   - 字典的创建与初始化
   - 字典的键值对操作
   - 字典的常用方法（get、setdefault、update等）
   - 字典的遍历方式
   - 字典推导式
   - 字典的内部实现原理
   - OrderedDict 和 defaultdict

4. 集合（Set）：
   - 集合的创建与特性
   - 集合的数学运算（并集、交集、差集、对称差集）
   - 集合的常用方法
   - frozenset 不可变集合
   - 集合的性能特点
   - 集合的适用场景

5. 数据结构的选择：
   - 不同数据结构的性能对比
   - 时间复杂度分析
   - 空间复杂度分析
   - 实际应用场景的选择指南

6. 高级技巧：
   - 数据结构的嵌套使用
   - 深拷贝与浅拷贝
   - 数据结构的序列化
   - 内存优化技巧

请为每种数据结构提供详细的代码示例，包括实际应用场景和性能分析。解释数据结构的内部实现原理和最佳实践。
```

## 学习要点

- 掌握 Python 四种主要内置数据结构的特点和用法
- 理解每种数据结构的适用场景和性能特点
- 学会使用各种数据结构的常用方法和操作
- 掌握列表推导式和字典推导式的使用
- 理解可变与不可变数据结构的区别
- 了解数据结构的内部实现原理
- 学会根据需求选择合适的数据结构
- 掌握数据结构的嵌套和高级操作
- 理解深拷贝和浅拷贝的区别
- 了解数据结构的性能优化技巧

## 实践练习

1. 创建不同类型的列表并练习各种操作
2. 使用列表推导式解决实际问题
3. 比较列表和元组的性能差异
4. 实现一个使用字典的简单数据库
5. 使用集合进行数据去重和集合运算
6. 创建嵌套数据结构并操作
7. 实现深拷贝和浅拷贝的例子
8. 分析不同数据结构的时间复杂度

## 代码示例模板

```python
# 列表操作示例
def list_operations():
    """演示列表的各种操作"""
    # 创建列表
    numbers = [1, 2, 3, 4, 5]
    mixed = [1, "hello", 3.14, True]
    
    # 列表推导式
    squares = [x**2 for x in range(10)]
    even_squares = [x**2 for x in range(10) if x % 2 == 0]
    
    # 列表方法
    numbers.append(6)        # 添加元素
    numbers.extend([7, 8])   # 扩展列表
    numbers.insert(0, 0)     # 插入元素
    numbers.remove(3)        # 删除元素
    popped = numbers.pop()   # 弹出最后一个元素
    
    # 列表排序
    numbers.sort()           # 原地排序
    sorted_numbers = sorted(numbers)  # 返回新列表
    
    # 列表切片
    subset = numbers[2:5]    # 切片操作
    every_other = numbers[::2]  # 步长切片

# 元组操作示例
def tuple_operations():
    """演示元组的各种操作"""
    # 创建元组
    point = (3, 4)
    single_element = (1,)    # 单元素元组
    
    # 元组解包
    x, y = point
    coordinates = [(1, 2), (3, 4), (5, 6)]
    for x, y in coordinates:
        print(f"坐标: ({x}, {y})")
    
    # 命名元组
    from collections import namedtuple
    Point = namedtuple('Point', ['x', 'y'])
    p = Point(1, 2)
    print(f"X坐标: {p.x}, Y坐标: {p.y}")

# 字典操作示例
def dict_operations():
    """演示字典的各种操作"""
    # 创建字典
    person = {
        "name": "张三",
        "age": 25,
        "city": "北京"
    }
    
    # 字典方法
    name = person.get("name", "未知")  # 安全获取
    person.setdefault("gender", "男")  # 设置默认值
    person.update({"age": 26, "job": "工程师"})  # 更新字典
    
    # 字典遍历
    for key in person:
        print(f"{key}: {person[key]}")
    
    for key, value in person.items():
        print(f"{key}: {value}")
    
    # 字典推导式
    squares = {x: x**2 for x in range(5)}
    
    # defaultdict
    from collections import defaultdict
    word_count = defaultdict(int)
    words = ["hello", "world", "hello", "python"]
    for word in words:
        word_count[word] += 1

# 集合操作示例
def set_operations():
    """演示集合的各种操作"""
    # 创建集合
    set1 = {1, 2, 3, 4, 5}
    set2 = {4, 5, 6, 7, 8}
    
    # 集合运算
    union = set1 | set2           # 并集
    intersection = set1 & set2    # 交集
    difference = set1 - set2      # 差集
    symmetric_diff = set1 ^ set2  # 对称差集
    
    # 集合方法
    set1.add(6)                   # 添加元素
    set1.remove(1)                # 删除元素（不存在会报错）
    set1.discard(2)               # 删除元素（不存在不报错）
    
    # 集合推导式
    squares = {x**2 for x in range(5)}
    
    # frozenset
    immutable_set = frozenset([1, 2, 3])

# 数据结构性能比较
def performance_comparison():
    """比较不同数据结构的性能"""
    import time
    
    # 列表 vs 集合的成员测试
    large_list = list(range(100000))
    large_set = set(range(100000))
    
    # 测试列表的成员测试
    start = time.time()
    99999 in large_list
    list_time = time.time() - start
    
    # 测试集合的成员测试
    start = time.time()
    99999 in large_set
    set_time = time.time() - start
    
    print(f"列表成员测试时间: {list_time:.6f}秒")
    print(f"集合成员测试时间: {set_time:.6f}秒")

# 深拷贝与浅拷贝
def copy_examples():
    """演示深拷贝与浅拷贝"""
    import copy
    
    # 浅拷贝
    original = [1, [2, 3], 4]
    shallow = original.copy()
    shallow[1][0] = 99  # 修改嵌套列表
    
    print(f"原始列表: {original}")  # 嵌套列表也被修改
    print(f"浅拷贝: {shallow}")
    
    # 深拷贝
    deep = copy.deepcopy(original)
    deep[1][0] = 88  # 修改嵌套列表
    
    print(f"原始列表: {original}")  # 原始列表不受影响
    print(f"深拷贝: {deep}")

# 实际应用示例
def real_world_examples():
    """实际应用中的数据结构使用"""
    # 学生成绩管理系统
    students = [
        {"name": "张三", "scores": {"math": 90, "english": 85}},
        {"name": "李四", "scores": {"math": 80, "english": 95}},
        {"name": "王五", "scores": {"math": 85, "english": 90}}
    ]
    
    # 计算平均分
    for student in students:
        avg_score = sum(student["scores"].values()) / len(student["scores"])
        student["average"] = avg_score
    
    # 按平均分排序
    sorted_students = sorted(students, key=lambda x: x["average"], reverse=True)
    
    # 找出所有科目
    all_subjects = set()
    for student in students:
        all_subjects.update(student["scores"].keys())
    
    print(f"所有科目: {all_subjects}")
    print("学生排名:")
    for i, student in enumerate(sorted_students, 1):
        print(f"{i}. {student['name']}: {student['average']:.1f}")
```

## 扩展资源

- [Python 数据结构文档](https://docs.python.org/3/tutorial/datastructures.html)
- [collections 模块文档](https://docs.python.org/3/library/collections.html)
- [copy 模块文档](https://docs.python.org/3/library/copy.html)
- [算法复杂度分析](https://wiki.python.org/moin/TimeComplexity)
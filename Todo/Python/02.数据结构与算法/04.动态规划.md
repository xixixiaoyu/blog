# Python 动态规划

## 最佳提示词

```
请详细介绍 Python 动态规划，包括以下内容：

1. 动态规划基础：
   - 动态规划的概念与原理
   - 最优子结构与重叠子问题
   - 自顶向下与自底向上方法
   - 记忆化搜索技术

2. 经典动态规划问题：
   - 斐波那契数列
   - 背包问题（0-1背包、完全背包）
   - 最长递增子序列
   - 最长公共子序列
   - 编辑距离

3. 动态规划优化技巧：
   - 状态压缩
   - 滚动数组
   - 空间优化
   - 路径记录

4. 动态规划应用：
   - 股票买卖问题
   - 硬币找零问题
   - 矩阵链乘法
   - 正则表达式匹配

请为每个问题提供详细的代码实现，包括状态转移方程和复杂度分析。
```

## 学习要点

- 理解动态规划的核心思想
- 掌握最优子结构的识别方法
- 学会分析重叠子问题
- 掌握记忆化搜索的实现
- 理解状态转移方程的设计
- 学会动态规划的优化技巧
- 了解常见动态规划问题的模式

## 实践练习

1. 实现斐波那契数列的动态规划解法
2. 解决 0-1 背包问题
3. 实现最长递增子序列算法
4. 解决编辑距离问题
5. 应用动态规划解决股票买卖问题
6. 优化动态规划的空间复杂度

## 代码示例模板

```python
# 斐波那契数列（动态规划）
def fibonacci(n):
    """动态规划计算斐波那契数列"""
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

# 0-1 背包问题
def knapsack(weights, values, capacity):
    """0-1 背包问题动态规划解法"""
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(
                    values[i-1] + dp[i-1][w - weights[i-1]],
                    dp[i-1][w]
                )
            else:
                dp[i][w] = dp[i-1][w]
    
    return dp[n][capacity]

# 最长递增子序列
def lis_length(nums):
    """最长递增子序列长度"""
    if not nums:
        return 0
    
    dp = [1] * len(nums)
    
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)

# 编辑距离
def edit_distance(word1, word2):
    """计算两个单词的编辑距离"""
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 初始化边界条件
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    # 填充 DP 表
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(
                    dp[i-1][j] + 1,    # 删除
                    dp[i][j-1] + 1,    # 插入
                    dp[i-1][j-1] + 1   # 替换
                )
    
    return dp[m][n]

# 记忆化搜索示例
def memoization_example():
    """记忆化搜索示例"""
    from functools import lru_cache
    
    @lru_cache(maxsize=None)
    def fib(n):
        if n <= 1:
            return n
        return fib(n-1) + fib(n-2)
    
    return fib(100)
```

## 扩展资源

- [动态规划教程](https://www.geeksforgeeks.org/dynamic-programming/)
- [LeetCode 动态规划题目](https://leetcode.com/tag/dynamic-programming/)
- [算法竞赛入门经典](https://book.douban.com/subject/26825839/)
- [动态规划可视化](https://dynamicprogramming.vercel.app/)
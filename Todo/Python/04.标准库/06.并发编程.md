# Python 并发编程

## 最佳提示词

```
请详细介绍 Python 的并发编程，包括以下内容：

1. 并发概念：
   - 并发与并行
   - 进程与线程
   - GIL 全局解释器锁
   - 同步与异步

2. threading 模块：
   - 线程创建与管理
   - 线程同步机制
   - 线程间通信
   - 线程池

3. multiprocessing 模块：
   - 进程创建与管理
   - 进程间通信
   - 进程池
   - 共享内存

4. asyncio 模块：
   - 异步编程基础
   - 协程与事件循环
   - 异步I/O操作
   - 异步上下文管理

5. concurrent.futures 模块：
   - ThreadPoolExecutor
   - ProcessPoolExecutor
   - Future 对象
   - 异步结果处理

6. 同步原语：
   - 锁机制
   - 信号量
   - 事件
   - 条件变量

请为每个概念提供详细的代码示例，包括实际应用场景和最佳实践。
```

## 学习要点

- 理解并发编程的基本概念
- 掌握多线程编程技术
- 学会使用多进程处理
- 了解异步编程模型
- 掌握进程间和线程间通信
- 学会选择合适的并发模型

## 实践练习

1. 实现多线程下载器
2. 创建多进程数据处理工具
3. 开发异步网络爬虫
4. 实现生产者-消费者模式
5. 构建并发Web服务器

## 代码示例模板

```python
import threading
import multiprocessing
import asyncio
import concurrent.futures
import time
import queue
from threading import Lock, Semaphore, Event, Condition

# 多线程示例
class ThreadExample:
    def __init__(self):
        self.counter = 0
        self.lock = Lock()
    
    def increment(self):
        """线程安全的计数器"""
        with self.lock:
            current = self.counter
            time.sleep(0.001)  # 模拟耗时操作
            self.counter = current + 1
    
    def worker(self, thread_id):
        """工作线程"""
        for _ in range(1000):
            self.increment()
        print(f"线程 {thread_id} 完成")
    
    def run_example(self):
        """运行多线程示例"""
        threads = []
        start_time = time.time()
        
        # 创建并启动线程
        for i in range(5):
            thread = threading.Thread(target=self.worker, args=(i,))
            threads.append(thread)
            thread.start()
        
        # 等待所有线程完成
        for thread in threads:
            thread.join()
        
        end_time = time.time()
        print(f"最终计数器值: {self.counter}")
        print(f"执行时间: {end_time - start_time:.2f}秒")

# 线程池示例
def thread_pool_example():
    """线程池示例"""
    def task(n):
        """任务函数"""
        print(f"处理任务 {n}")
        time.sleep(1)
        return n * n
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
        # 提交任务
        futures = [executor.submit(task, i) for i in range(10)]
        
        # 获取结果
        for future in concurrent.futures.as_completed(futures):
            result = future.result()
            print(f"任务结果: {result}")

# 多进程示例
class ProcessExample:
    def __init__(self):
        self.result_queue = multiprocessing.Queue()
    
    def worker(self, start, end):
        """工作进程"""
        total = sum(range(start, end + 1))
        self.result_queue.put(total)
        print(f"进程 {start}-{end} 完成，总和: {total}")
    
    def run_example(self):
        """运行多进程示例"""
        processes = []
        start_time = time.time()
        
        # 分配任务
        ranges = [(1, 2500), (2501, 5000), (5001, 7500), (7501, 10000)]
        
        # 创建并启动进程
        for start, end in ranges:
            process = multiprocessing.Process(
                target=self.worker, 
                args=(start, end)
            )
            processes.append(process)
            process.start()
        
        # 等待所有进程完成
        for process in processes:
            process.join()
        
        # 收集结果
        total_sum = 0
        while not self.result_queue.empty():
            total_sum += self.result_queue.get()
        
        end_time = time.time()
        print(f"总和: {total_sum}")
        print(f"执行时间: {end_time - start_time:.2f}秒")

# 进程池示例
def process_pool_example():
    """进程池示例"""
    def cpu_intensive_task(n):
        """CPU密集型任务"""
        total = 0
        for i in range(n):
            total += i ** 2
        return total
    
    with concurrent.futures.ProcessPoolExecutor(max_workers=4) as executor:
        # 提交任务
        numbers = [10000, 20000, 30000, 40000]
        futures = [executor.submit(cpu_intensive_task, n) for n in numbers]
        
        # 获取结果
        for future, n in zip(futures, numbers):
            result = future.result()
            print(f"任务 {n} 结果: {result}")

# 异步编程示例
class AsyncExample:
    async def fetch_data(self, url, delay):
        """模拟异步获取数据"""
        print(f"开始获取 {url}")
        await asyncio.sleep(delay)
        print(f"完成获取 {url}")
        return f"数据来自 {url}"
    
    async def fetch_multiple(self):
        """并发获取多个数据源"""
        urls = [
            ("https://api1.com", 1),
            ("https://api2.com", 2),
            ("https://api3.com", 1.5)
        ]
        
        # 并发执行
        tasks = [self.fetch_data(url, delay) for url, delay in urls]
        results = await asyncio.gather(*tasks)
        
        for result in results:
            print(f"结果: {result}")
    
    def run_example(self):
        """运行异步示例"""
        asyncio.run(self.fetch_multiple())

# 异步上下文管理器
class AsyncTimer:
    def __init__(self):
        self.start_time = None
    
    async def __aenter__(self):
        self.start_time = time.time()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        end_time = time.time()
        print(f"执行时间: {end_time - self.start_time:.2f}秒")

async def async_context_example():
    """异步上下文管理器示例"""
    async with AsyncTimer():
        print("开始异步操作")
        await asyncio.sleep(2)
        print("完成异步操作")

# 生产者-消费者模式
class ProducerConsumer:
    def __init__(self, max_size=10):
        self.buffer = queue.Queue(maxsize=max_size)
        self.producer_event = Event()
        self.consumer_event = Event()
    
    def producer(self, items):
        """生产者"""
        for item in items:
            self.buffer.put(item)
            print(f"生产: {item}")
            self.consumer_event.set()  # 通知消费者
            self.producer_event.wait()  # 等待消费者通知
            self.producer_event.clear()
        
        # 发送结束信号
        self.buffer.put(None)
        self.consumer_event.set()
    
    def consumer(self):
        """消费者"""
        while True:
            self.consumer_event.wait()  # 等待生产者通知
            self.consumer_event.clear()
            
            item = self.buffer.get()
            if item is None:  # 结束信号
                break
            
            print(f"消费: {item}")
            self.producer_event.set()  # 通知生产者
    
    def run_example(self):
        """运行生产者-消费者示例"""
        items = [f"产品{i}" for i in range(10)]
        
        producer_thread = threading.Thread(
            target=self.producer, 
            args=(items,)
        )
        consumer_thread = threading.Thread(target=self.consumer)
        
        producer_thread.start()
        consumer_thread.start()
        
        producer_thread.join()
        consumer_thread.join()

# 信号量示例
def semaphore_example():
    """信号量控制并发访问"""
    semaphore = Semaphore(3)  # 最多3个并发访问
    
    def worker(worker_id):
        with semaphore:
            print(f"工作者 {worker_id} 开始工作")
            time.sleep(2)
            print(f"工作者 {worker_id} 完成工作")
    
    threads = []
    for i in range(10):
        thread = threading.Thread(target=worker, args=(i,))
        threads.append(thread)
        thread.start()
    
    for thread in threads:
        thread.join()

# 条件变量示例
def condition_example():
    """条件变量示例"""
    buffer = []
    buffer_size = 5
    condition = Condition()
    
    def producer():
        for i in range(10):
            with condition:
                while len(buffer) >= buffer_size:
                    print("缓冲区满，生产者等待")
                    condition.wait()
                
                buffer.append(f"产品{i}")
                print(f"生产: 产品{i}")
                condition.notify_all()
    
    def consumer():
        for _ in range(10):
            time.sleep(0.1)  # 消费者稍慢
            with condition:
                while not buffer:
                    print("缓冲区空，消费者等待")
                    condition.wait()
                
                item = buffer.pop(0)
                print(f"消费: {item}")
                condition.notify_all()
    
    producer_thread = threading.Thread(target=producer)
    consumer_thread = threading.Thread(target=consumer)
    
    producer_thread.start()
    consumer_thread.start()
    
    producer_thread.join()
    consumer_thread.join()

# 性能比较
def performance_comparison():
    """比较不同并发模型的性能"""
    def cpu_task(n):
        """CPU密集型任务"""
        total = 0
        for i in range(n):
            total += i ** 2
        return total
    
    def io_task():
        """I/O密集型任务"""
        time.sleep(0.1)
        return "完成"
    
    # 测试CPU密集型任务
    print("CPU密集型任务测试:")
    start_time = time.time()
    
    # 顺序执行
    for _ in range(10):
        cpu_task(10000)
    sequential_time = time.time() - start_time
    
    # 多线程执行
    start_time = time.time()
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        futures = [executor.submit(cpu_task, 10000) for _ in range(10)]
        for future in futures:
            future.result()
    thread_time = time.time() - start_time
    
    # 多进程执行
    start_time = time.time()
    with concurrent.futures.ProcessPoolExecutor(max_workers=4) as executor:
        futures = [executor.submit(cpu_task, 10000) for _ in range(10)]
        for future in futures:
            future.result()
    process_time = time.time() - start_time
    
    print(f"顺序执行: {sequential_time:.2f}秒")
    print(f"多线程执行: {thread_time:.2f}秒")
    print(f"多进程执行: {process_time:.2f}秒")

# 使用示例
if __name__ == "__main__":
    print("=== 多线程示例 ===")
    thread_example = ThreadExample()
    thread_example.run_example()
    
    print("\n=== 线程池示例 ===")
    thread_pool_example()
    
    print("\n=== 多进程示例 ===")
    process_example = ProcessExample()
    process_example.run_example()
    
    print("\n=== 进程池示例 ===")
    process_pool_example()
    
    print("\n=== 异步编程示例 ===")
    async_example = AsyncExample()
    async_example.run_example()
    
    print("\n=== 生产者-消费者示例 ===")
    pc = ProducerConsumer()
    pc.run_example()
    
    print("\n=== 性能比较 ===")
    performance_comparison()
```

## 扩展资源

- [threading 模块文档](https://docs.python.org/3/library/threading.html)
- [multiprocessing 模块文档](https://docs.python.org/3/library/multiprocessing.html)
- [asyncio 模块文档](https://docs.python.org/3/library/asyncio.html)
- [concurrent.futures 模块文档](https://docs.python.org/3/library/concurrent.futures.html)
- [queue 模块文档](https://docs.python.org/3/library/queue.html)
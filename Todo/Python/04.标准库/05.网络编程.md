# Python 网络编程

## 最佳提示词

```
请详细介绍 Python 的网络编程，包括以下内容：

1. 网络基础：
   - TCP/IP 协议
   - 套接字概念
   - 客户端/服务器模型
   - 网络地址与端口

2. socket 模块：
   - 套接字创建
   - TCP 套接字编程
   - UDP 套接字编程
   - 套接字选项

3. HTTP 编程：
   - http.client 模块
   - urllib 包
   - HTTP 请求处理
   - HTTP 响应解析

4. 高级网络功能：
   - SSL/TLS 安全通信
   - 异步网络编程
   - 多线程服务器
   - 协议设计

5. 网络工具：
   - 网络诊断
   - 端口扫描
   - 网络监控
   - 性能优化

6. 实际应用：
   - Web 服务器实现
   - 聊天程序
   - 文件传输
   - API 客户端

请为每个功能提供详细的代码示例，包括实际应用场景和最佳实践。
```

## 学习要点

- 理解网络编程的基本概念
- 掌握 socket 编程的基础知识
- 学会实现 TCP 和 UDP 通信
- 了解 HTTP 协议的处理方法
- 掌握网络安全编程技巧
- 学会构建实际的网络应用

## 实践练习

1. 实现简单的 TCP 服务器和客户端
2. 创建 UDP 广播程序
3. 开发 HTTP 客户端工具
4. 实现安全的 SSL 通信
5. 构建多线程网络服务器

## 代码示例模板

```python
import socket
import threading
import ssl
import urllib.request
import urllib.parse
import json
from http.server import HTTPServer, BaseHTTPRequestHandler

# TCP 服务器
class TCPServer:
    def __init__(self, host='localhost', port=8888):
        self.host = host
        self.port = port
        self.server_socket = None
    
    def start(self):
        """启动TCP服务器"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.bind((self.host, self.port))
        self.server_socket.listen(5)
        print(f"TCP服务器启动在 {self.host}:{self.port}")
        
        try:
            while True:
                client_socket, address = self.server_socket.accept()
                print(f"连接来自: {address}")
                client_thread = threading.Thread(
                    target=self.handle_client, 
                    args=(client_socket, address)
                )
                client_thread.start()
        except KeyboardInterrupt:
            print("服务器关闭")
        finally:
            self.server_socket.close()
    
    def handle_client(self, client_socket, address):
        """处理客户端请求"""
        try:
            while True:
                data = client_socket.recv(1024)
                if not data:
                    break
                
                message = data.decode('utf-8')
                print(f"收到消息: {message}")
                
                response = f"服务器回复: {message}"
                client_socket.send(response.encode('utf-8'))
        except Exception as e:
            print(f"处理客户端错误: {e}")
        finally:
            client_socket.close()

# TCP 客户端
class TCPClient:
    def __init__(self, host='localhost', port=8888):
        self.host = host
        self.port = port
        self.client_socket = None
    
    def connect(self):
        """连接到服务器"""
        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.client_socket.connect((self.host, self.port))
        print(f"连接到服务器 {self.host}:{self.port}")
    
    def send_message(self, message):
        """发送消息"""
        self.client_socket.send(message.encode('utf-8'))
        response = self.client_socket.recv(1024)
        print(f"服务器回复: {response.decode('utf-8')}")
    
    def close(self):
        """关闭连接"""
        if self.client_socket:
            self.client_socket.close()

# UDP 通信
class UDPCommunication:
    def __init__(self, host='localhost', port=9999):
        self.host = host
        self.port = port
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind((host, port))
    
    def send_message(self, message, target_host, target_port):
        """发送UDP消息"""
        self.socket.sendto(message.encode('utf-8'), (target_host, target_port))
    
    def receive_message(self):
        """接收UDP消息"""
        data, address = self.socket.recvfrom(1024)
        message = data.decode('utf-8')
        print(f"收到来自 {address} 的消息: {message}")
        return message, address

# HTTP 客户端
class HTTPClient:
    @staticmethod
    def get_request(url):
        """发送GET请求"""
        try:
            with urllib.request.urlopen(url) as response:
                data = response.read()
                return data.decode('utf-8')
        except Exception as e:
            print(f"GET请求错误: {e}")
            return None
    
    @staticmethod
    def post_request(url, data):
        """发送POST请求"""
        try:
            data_bytes = data.encode('utf-8')
            req = urllib.request.Request(
                url, 
                data=data_bytes,
                headers={'Content-Type': 'application/json'}
            )
            with urllib.request.urlopen(req) as response:
                return response.read().decode('utf-8')
        except Exception as e:
            print(f"POST请求错误: {e}")
            return None

# 简单HTTP服务器
class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        """处理GET请求"""
        if self.path == '/':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            response = "<h1>Hello, Python HTTP Server!</h1>"
            self.wfile.write(response.encode('utf-8'))
        elif self.path == '/api/data':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            data = {'message': 'Hello from API', 'status': 'success'}
            self.wfile.write(json.dumps(data).encode('utf-8'))
        else:
            self.send_response(404)
            self.end_headers()
    
    def do_POST(self):
        """处理POST请求"""
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length)
        
        try:
            data = json.loads(post_data.decode('utf-8'))
            response_data = {'received': data, 'status': 'success'}
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(response_data).encode('utf-8'))
        except Exception as e:
            self.send_response(400)
            self.end_headers()

# SSL/TLS 安全通信
class SecureServer:
    def __init__(self, host='localhost', port=8443):
        self.host = host
        self.port = port
        self.context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    
    def start(self):
        """启动安全服务器"""
        # 创建socket
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.bind((self.host, self.port))
        server_socket.listen(5)
        
        # 包装SSL
        secure_socket = self.context.wrap_socket(
            server_socket, 
            server_side=True
        )
        
        print(f"安全服务器启动在 {self.host}:{self.port}")
        
        try:
            while True:
                client_socket, address = secure_socket.accept()
                print(f"安全连接来自: {address}")
                
                data = client_socket.recv(1024)
                print(f"收到安全数据: {data.decode('utf-8')}")
                
                response = "安全服务器回复"
                client_socket.send(response.encode('utf-8'))
                client_socket.close()
        except KeyboardInterrupt:
            print("安全服务器关闭")
        finally:
            secure_socket.close()

# 网络工具函数
def check_port(host, port):
    """检查端口是否开放"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((host, port))
        sock.close()
        return result == 0
    except Exception:
        return False

def get_local_ip():
    """获取本地IP地址"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.connect(("8.8.8.8", 80))
        ip = sock.getsockname()[0]
        sock.close()
        return ip
    except Exception:
        return "127.0.0.1"

def scan_ports(host, start_port, end_port):
    """扫描端口"""
    open_ports = []
    for port in range(start_port, end_port + 1):
        if check_port(host, port):
            open_ports.append(port)
            print(f"端口 {port} 开放")
    return open_ports

# 使用示例
if __name__ == "__main__":
    # 获取本地IP
    print(f"本地IP: {get_local_ip()}")
    
    # 检查端口
    print(f"端口80是否开放: {check_port('localhost', 80)}")
    
    # HTTP客户端示例
    # client = HTTPClient()
    # response = client.get_request('https://httpbin.org/get')
    # print(f"HTTP响应: {response}")
```

## 扩展资源

- [socket 模块文档](https://docs.python.org/3/library/socket.html)
- [urllib 包文档](https://docs.python.org/3/library/urllib.html)
- [http.server 模块文档](https://docs.python.org/3/library/http.server.html)
- [ssl 模块文档](https://docs.python.org/3/library/ssl.html)
- [asyncio 网络编程](https://docs.python.org/3/library/asyncio-stream.html)
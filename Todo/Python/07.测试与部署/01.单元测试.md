# Python 单元测试

## 最佳提示词

```
请详细介绍 Python 的单元测试，包括以下内容：

1. 测试基础：
   - 单元测试概念
   - 测试驱动开发（TDD）
   - 测试金字塔
   - 测试覆盖率

2. unittest 框架：
   - TestCase 类
   - 断言方法
   - 测试固件
   - 测试套件

3. pytest 框架：
   - pytest 安装与配置
   - 测试发现规则
   - 参数化测试
   - 固件与依赖注入

4. Mock 对象：
   - unittest.mock 模块
   - Mock 对象创建
   - 打补丁技术
   - 异步测试

5. 测试最佳实践：
   - 测试命名规范
   - 测试组织结构
   - 测试数据管理
   - 持续集成

6. 高级测试技巧：
   - 性能测试
   - 并发测试
   - 异常测试
   - 边界条件测试

请为每个概念提供详细的代码示例，包括实际应用场景和最佳实践。
```

## 学习要点

- 理解单元测试的重要性和基本原则
- 掌握 unittest 和 pytest 框架的使用
- 学会使用 Mock 对象进行隔离测试
- 了解测试驱动开发的流程
- 掌握测试覆盖率的评估方法
- 学会编写高质量的测试代码

## 实践练习

1. 使用 unittest 编写测试用例
2. 使用 pytest 进行参数化测试
3. 使用 Mock 对象隔离依赖
4. 实现测试驱动开发
5. 提高测试覆盖率

## 代码示例模板

```python
import unittest
import pytest
from unittest.mock import Mock, patch, MagicMock
import tempfile
import os
import time
import threading
from typing import List, Dict
import asyncio
import aiohttp
import requests
from dataclasses import dataclass

# 被测试的代码
class Calculator:
    """简单计算器类"""
    
    def add(self, a, b):
        """加法"""
        return a + b
    
    def subtract(self, a, b):
        """减法"""
        return a - b
    
    def multiply(self, a, b):
        """乘法"""
        return a * b
    
    def divide(self, a, b):
        """除法"""
        if b == 0:
            raise ValueError("除数不能为零")
        return a / b
    
    def power(self, base, exponent):
        """幂运算"""
        return base ** exponent

class DataProcessor:
    """数据处理器"""
    
    def __init__(self, data_source):
        self.data_source = data_source
    
    def process_data(self):
        """处理数据"""
        raw_data = self.data_source.fetch_data()
        return self._transform_data(raw_data)
    
    def _transform_data(self, data):
        """转换数据"""
        if not data:
            return []
        
        return [
            {
                'id': item['id'],
                'name': item['name'].upper(),
                'value': item['value'] * 2
            }
            for item in data
        ]

class FileHandler:
    """文件处理器"""
    
    def read_file(self, filepath):
        """读取文件"""
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    
    def write_file(self, filepath, content):
        """写入文件"""
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
    
    def append_file(self, filepath, content):
        """追加文件"""
        with open(filepath, 'a', encoding='utf-8') as f:
            f.write(content)

class APIClient:
    """API 客户端"""
    
    def __init__(self, base_url):
        self.base_url = base_url
    
    def get_user(self, user_id):
        """获取用户信息"""
        response = requests.get(f"{self.base_url}/users/{user_id}")
        response.raise_for_status()
        return response.json()
    
    def create_user(self, user_data):
        """创建用户"""
        response = requests.post(
            f"{self.base_url}/users",
            json=user_data
        )
        response.raise_for_status()
        return response.json()

# unittest 示例
class TestCalculator(unittest.TestCase):
    """计算器测试类"""
    
    def setUp(self):
        """测试前准备"""
        self.calculator = Calculator()
    
    def tearDown(self):
        """测试后清理"""
        pass
    
    def test_add_positive_numbers(self):
        """测试正数加法"""
        result = self.calculator.add(2, 3)
        self.assertEqual(result, 5)
    
    def test_add_negative_numbers(self):
        """测试负数加法"""
        result = self.calculator.add(-2, -3)
        self.assertEqual(result, -5)
    
    def test_add_mixed_numbers(self):
        """测试混合数加法"""
        result = self.calculator.add(5, -3)
        self.assertEqual(result, 2)
    
    def test_subtract(self):
        """测试减法"""
        result = self.calculator.subtract(10, 3)
        self.assertEqual(result, 7)
    
    def test_multiply(self):
        """测试乘法"""
        result = self.calculator.multiply(4, 5)
        self.assertEqual(result, 20)
    
    def test_divide(self):
        """测试除法"""
        result = self.calculator.divide(10, 2)
        self.assertEqual(result, 5)
    
    def test_divide_by_zero(self):
        """测试除零异常"""
        with self.assertRaises(ValueError):
            self.calculator.divide(10, 0)
    
    def test_power(self):
        """测试幂运算"""
        result = self.calculator.power(2, 3)
        self.assertEqual(result, 8)
    
    def test_floating_point_operations(self):
        """测试浮点数运算"""
        result = self.calculator.add(0.1, 0.2)
        self.assertAlmostEqual(result, 0.3, places=7)

class TestDataProcessor(unittest.TestCase):
    """数据处理器测试类"""
    
    def setUp(self):
        """测试前准备"""
        self.mock_data_source = Mock()
        self.processor = DataProcessor(self.mock_data_source)
    
    def test_process_data_with_valid_data(self):
        """测试处理有效数据"""
        # 设置 Mock 返回值
        test_data = [
            {'id': 1, 'name': 'alice', 'value': 10},
            {'id': 2, 'name': 'bob', 'value': 20}
        ]
        self.mock_data_source.fetch_data.return_value = test_data
        
        # 执行测试
        result = self.processor.process_data()
        
        # 验证结果
        expected = [
            {'id': 1, 'name': 'ALICE', 'value': 20},
            {'id': 2, 'name': 'BOB', 'value': 40}
        ]
        self.assertEqual(result, expected)
        
        # 验证 Mock 调用
        self.mock_data_source.fetch_data.assert_called_once()
    
    def test_process_data_with_empty_data(self):
        """测试处理空数据"""
        self.mock_data_source.fetch_data.return_value = []
        
        result = self.processor.process_data()
        
        self.assertEqual(result, [])
        self.mock_data_source.fetch_data.assert_called_once()

class TestFileHandler(unittest.TestCase):
    """文件处理器测试类"""
    
    def setUp(self):
        """测试前准备"""
        self.temp_dir = tempfile.mkdtemp()
        self.file_handler = FileHandler()
        self.test_file = os.path.join(self.temp_dir, 'test.txt')
    
    def tearDown(self):
        """测试后清理"""
        if os.path.exists(self.test_file):
            os.remove(self.test_file)
        os.rmdir(self.temp_dir)
    
    def test_write_and_read_file(self):
        """测试文件写入和读取"""
        content = "Hello, World!"
        
        # 写入文件
        self.file_handler.write_file(self.test_file, content)
        
        # 读取文件
        result = self.file_handler.read_file(self.test_file)
        
        self.assertEqual(result, content)
    
    def test_append_file(self):
        """测试文件追加"""
        initial_content = "Hello"
        append_content = ", World!"
        
        # 写入初始内容
        self.file_handler.write_file(self.test_file, initial_content)
        
        # 追加内容
        self.file_handler.append_file(self.test_file, append_content)
        
        # 读取完整内容
        result = self.file_handler.read_file(self.test_file)
        
        self.assertEqual(result, initial_content + append_content)

# pytest 示例
@pytest.fixture
def calculator():
    """计算器固件"""
    return Calculator()

@pytest.fixture
def mock_data_source():
    """模拟数据源固件"""
    return Mock()

@pytest.fixture
def data_processor(mock_data_source):
    """数据处理器固件"""
    return DataProcessor(mock_data_source)

@pytest.fixture
def temp_file():
    """临时文件固件"""
    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
        yield f.name
    os.unlink(f.name)

def test_calculator_add(calculator):
    """测试计算器加法"""
    assert calculator.add(2, 3) == 5
    assert calculator.add(-1, 1) == 0

@pytest.mark.parametrize("a,b,expected", [
    (2, 3, 5),
    (-2, -3, -5),
    (5, -3, 2),
    (0, 0, 0)
])
def test_calculator_add_parametrized(calculator, a, b, expected):
    """参数化测试计算器加法"""
    assert calculator.add(a, b) == expected

def test_calculator_divide_by_zero(calculator):
    """测试计算器除零异常"""
    with pytest.raises(ValueError, match="除数不能为零"):
        calculator.divide(10, 0)

def test_data_processor_with_mock(data_processor, mock_data_source):
    """使用 Mock 测试数据处理器"""
    # 设置 Mock 返回值
    test_data = [{'id': 1, 'name': 'test', 'value': 5}]
    mock_data_source.fetch_data.return_value = test_data
    
    # 执行测试
    result = data_processor.process_data()
    
    # 验证结果
    expected = [{'id': 1, 'name': 'TEST', 'value': 10}]
    assert result == expected
    
    # 验证 Mock 调用
    mock_data_source.fetch_data.assert_called_once()

def test_file_operations(temp_file):
    """测试文件操作"""
    file_handler = FileHandler()
    content = "Test content"
    
    # 写入文件
    file_handler.write_file(temp_file, content)
    
    # 读取文件
    result = file_handler.read_file(temp_file)
    
    assert result == content

# Mock 和 Patch 示例
class TestAPIClient(unittest.TestCase):
    """API 客户端测试类"""
    
    def setUp(self):
        """测试前准备"""
        self.client = APIClient("https://api.example.com")
    
    @patch('requests.get')
    def test_get_user_success(self, mock_get):
        """测试成功获取用户"""
        # 设置 Mock 响应
        mock_response = Mock()
        mock_response.json.return_value = {'id': 1, 'name': 'Alice'}
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
        
        # 执行测试
        result = self.client.get_user(1)
        
        # 验证结果
        expected = {'id': 1, 'name': 'Alice'}
        self.assertEqual(result, expected)
        
        # 验证请求
        mock_get.assert_called_once_with("https://api.example.com/users/1")
    
    @patch('requests.post')
    def test_create_user_success(self, mock_post):
        """测试成功创建用户"""
        # 设置 Mock 响应
        mock_response = Mock()
        mock_response.json.return_value = {'id': 2, 'name': 'Bob', 'created': True}
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        # 执行测试
        user_data = {'name': 'Bob', 'email': 'bob@example.com'}
        result = self.client.create_user(user_data)
        
        # 验证结果
        expected = {'id': 2, 'name': 'Bob', 'created': True}
        self.assertEqual(result, expected)
        
        # 验证请求
        mock_post.assert_called_once_with(
            "https://api.example.com/users",
            json=user_data
        )

# 异步测试示例
class AsyncDataFetcher:
    """异步数据获取器"""
    
    async def fetch_data(self, url):
        """异步获取数据"""
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.json()

@pytest.mark.asyncio
async def test_async_data_fetcher():
    """测试异步数据获取器"""
    # 使用 Mock 替代实际网络请求
    with patch('aiohttp.ClientSession') as mock_session_class:
        # 设置 Mock
        mock_session = Mock()
        mock_response = Mock()
        mock_response.json.return_value = {'data': 'test'}
        
        mock_session.__aenter__.return_value.get.return_value.__aenter__.return_value = mock_response
        mock_session_class.return_value = mock_session
        
        # 执行测试
        fetcher = AsyncDataFetcher()
        result = await fetcher.fetch_data('https://api.example.com/data')
        
        # 验证结果
        assert result == {'data': 'test'}

# 性能测试示例
def test_performance():
    """性能测试示例"""
    calculator = Calculator()
    
    # 测试大量计算的性能
    start_time = time.time()
    for i in range(10000):
        calculator.add(i, i + 1)
    end_time = time.time()
    
    # 验证性能要求
    execution_time = end_time - start_time
    assert execution_time < 1.0, f"执行时间过长: {execution_time}秒"

# 并发测试示例
def test_concurrent_access():
    """并发访问测试"""
    file_handler = FileHandler()
    temp_file = tempfile.mktemp()
    
    def write_worker(worker_id):
        """写入工作线程"""
        for i in range(10):
            content = f"Worker {worker_id}: {i}\n"
            file_handler.append_file(temp_file, content)
            time.sleep(0.01)
    
    # 创建多个线程
    threads = []
    for i in range(5):
        thread = threading.Thread(target=write_worker, args=(i,))
        threads.append(thread)
        thread.start()
    
    # 等待所有线程完成
    for thread in threads:
        thread.join()
    
    # 验证结果
    with open(temp_file, 'r') as f:
        content = f.read()
    
    lines = content.strip().split('\n')
    assert len(lines) == 50  # 5个线程 × 10次写入
    
    # 清理
    os.remove(temp_file)

# 边界条件测试
class TestBoundaryConditions(unittest.TestCase):
    """边界条件测试"""
    
    def setUp(self):
        """测试前准备"""
        self.calculator = Calculator()
    
    def test_large_numbers(self):
        """测试大数运算"""
        large_num = 10**100
        result = self.calculator.add(large_num, 1)
        self.assertEqual(result, large_num + 1)
    
    def test_very_small_numbers(self):
        """测试极小数运算"""
        small_num = 1e-10
        result = self.calculator.add(small_num, small_num)
        self.assertAlmostEqual(result, 2e-10)
    
    def test_string_input(self):
        """测试字符串输入"""
        with self.assertRaises(TypeError):
            self.calculator.add("2", "3")

# 测试套件示例
def create_test_suite():
    """创建测试套件"""
    suite = unittest.TestSuite()
    
    # 添加测试类
    suite.addTest(unittest.makeSuite(TestCalculator))
    suite.addTest(unittest.makeSuite(TestDataProcessor))
    suite.addTest(unittest.makeSuite(TestFileHandler))
    suite.addTest(unittest.makeSuite(TestAPIClient))
    suite.addTest(unittest.makeSuite(TestBoundaryConditions))
    
    return suite

if __name__ == '__main__':
    # 运行 unittest
    unittest.main(verbosity=2)
    
    # 或者运行自定义测试套件
    # suite = create_test_suite()
    # runner = unittest.TextTestRunner(verbosity=2)
    # runner.run(suite)
```

## 扩展资源

- [unittest 官方文档](https://docs.python.org/3/library/unittest.html)
- [pytest 官方文档](https://docs.pytest.org/)
- [unittest.mock 文档](https://docs.python.org/3/library/unittest.mock.html)
- [测试覆盖率工具 coverage.py](https://coverage.readthedocs.io/)
- [测试驱动开发实践](https://python-testing-cookbook.readthedocs.io/)
- [Python 测试最佳实践](https://realpython.com/python-testing/)
# Python 集成测试

## 最佳提示词

```
请详细介绍 Python 的集成测试，包括以下内容：

1. 集成测试基础：
   - 集成测试概念
   - 与单元测试的区别
   - 测试策略与层次
   - 测试环境搭建

2. Web 应用集成测试：
   - Flask 测试客户端
   - Django 测试框架
   - FastAPI 测试工具
   - API 端点测试

3. 数据库集成测试：
   - 测试数据库配置
   - 数据库迁移测试
   - 事务回滚测试
   - 数据一致性验证

4. 外部服务集成测试：
   - HTTP 服务模拟
   - 消息队列测试
   - 缓存系统测试
   - 第三方 API 测试

5. 端到端测试：
   - Selenium 自动化
   - 浏览器自动化
   - 用户场景测试
   - 视觉回归测试

6. 测试工具与框架：
   - pytest 集成测试
   - 测试容器化
   - 测试数据管理
   - 持续集成集成

请为每个测试类型提供详细的代码示例，包括实际应用场景和最佳实践。
```

## 学习要点

- 理解集成测试的重要性和应用场景
- 掌握 Web 应用的集成测试方法
- 学会数据库相关的集成测试
- 了解外部服务测试的模拟技术
- 掌握端到端测试的实现方法
- 学会构建完整的测试策略

## 实践练习

1. 实现 Flask 应用的集成测试
2. 编写数据库操作的集成测试
3. 创建 API 端点的集成测试
4. 使用 Selenium 进行端到端测试
5. 构建完整的集成测试套件

## 代码示例模板

```python
import pytest
import unittest
import requests
import json
import tempfile
import os
from unittest.mock import Mock, patch
from flask import Flask
from django.test import TestCase, Client
from django.urls import reverse
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
import redis
import time
from dataclasses import dataclass
from typing import Dict, List

# Flask 应用示例
def create_flask_app():
    """创建 Flask 应用"""
    app = Flask(__name__)
    
    # 内存数据库
    app.config['TESTING'] = True
    app.config['DATABASE'] = {}
    
    @app.route('/users', methods=['GET'])
    def get_users():
        users = app.config['DATABASE'].get('users', [])
        return jsonify(users)
    
    @app.route('/users', methods=['POST'])
    def create_user():
        user_data = request.get_json()
        users = app.config['DATABASE'].setdefault('users', [])
        user_data['id'] = len(users) + 1
        users.append(user_data)
        return jsonify(user_data), 201
    
    @app.route('/users/<int:user_id>', methods=['GET'])
    def get_user(user_id):
        users = app.config['DATABASE'].get('users', [])
        user = next((u for u in users if u['id'] == user_id), None)
        if user:
            return jsonify(user)
        return jsonify({'error': 'User not found'}), 404
    
    return app

# FastAPI 应用示例
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str

def create_fastapi_app():
    """创建 FastAPI 应用"""
    app = FastAPI()
    
    # 内存数据库
    app.users = []
    
    @app.get("/users", response_model=List[User])
    async def get_users():
        return app.users
    
    @app.post("/users", response_model=User)
    async def create_user(user: User):
        app.users.append(user)
        return user
    
    @app.get("/users/{user_id}", response_model=User)
    async def get_user(user_id: int):
        user = next((u for u in app.users if u.id == user_id), None)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        return user
    
    return app

# 数据库模型示例
from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class UserModel(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(50), nullable=False)
    email = Column(String(100), nullable=False)

# Flask 集成测试
class TestFlaskIntegration(unittest.TestCase):
    """Flask 集成测试"""
    
    def setUp(self):
        """测试前准备"""
        self.app = create_flask_app()
        self.client = self.app.test_client()
        self.app_context = self.app.app_context()
        self.app_context.push()
    
    def tearDown(self):
        """测试后清理"""
        self.app_context.pop()
    
    def test_get_users_empty(self):
        """测试获取空用户列表"""
        response = self.client.get('/users')
        self.assertEqual(response.status_code, 200)
        
        data = json.loads(response.data)
        self.assertEqual(data, [])
    
    def test_create_user(self):
        """测试创建用户"""
        user_data = {
            'name': 'Alice',
            'email': 'alice@example.com'
        }
        
        response = self.client.post(
            '/users',
            data=json.dumps(user_data),
            content_type='application/json'
        )
        
        self.assertEqual(response.status_code, 201)
        
        data = json.loads(response.data)
        self.assertEqual(data['name'], 'Alice')
        self.assertEqual(data['email'], 'alice@example.com')
        self.assertIn('id', data)
    
    def test_get_users_after_creation(self):
        """测试创建用户后获取列表"""
        # 创建用户
        user_data = {
            'name': 'Bob',
            'email': 'bob@example.com'
        }
        self.client.post(
            '/users',
            data=json.dumps(user_data),
            content_type='application/json'
        )
        
        # 获取用户列表
        response = self.client.get('/users')
        self.assertEqual(response.status_code, 200)
        
        data = json.loads(response.data)
        self.assertEqual(len(data), 1)
        self.assertEqual(data[0]['name'], 'Bob')
    
    def test_get_user_by_id(self):
        """测试根据ID获取用户"""
        # 创建用户
        user_data = {
            'name': 'Charlie',
            'email': 'charlie@example.com'
        }
        create_response = self.client.post(
            '/users',
            data=json.dumps(user_data),
            content_type='application/json'
        )
        created_user = json.loads(create_response.data)
        
        # 获取用户
        response = self.client.get(f'/users/{created_user["id"]}')
        self.assertEqual(response.status_code, 200)
        
        data = json.loads(response.data)
        self.assertEqual(data['name'], 'Charlie')
    
    def test_get_nonexistent_user(self):
        """测试获取不存在的用户"""
        response = self.client.get('/users/999')
        self.assertEqual(response.status_code, 404)
        
        data = json.loads(response.data)
        self.assertIn('error', data)

# FastAPI 集成测试
@pytest.fixture
def fastapi_client():
    """FastAPI 测试客户端固件"""
    app = create_fastapi_app()
    return TestClient(app)

def test_fastapi_get_users_empty(fastapi_client):
    """测试 FastAPI 获取空用户列表"""
    response = fastapi_client.get("/users")
    assert response.status_code == 200
    assert response.json() == []

def test_fastapi_create_user(fastapi_client):
    """测试 FastAPI 创建用户"""
    user_data = {
        "id": 1,
        "name": "Alice",
        "email": "alice@example.com"
    }
    
    response = fastapi_client.post("/users", json=user_data)
    assert response.status_code == 200
    
    data = response.json()
    assert data["name"] == "Alice"
    assert data["email"] == "alice@example.com"

def test_fastapi_get_user_by_id(fastapi_client):
    """测试 FastAPI 根据ID获取用户"""
    # 先创建用户
    user_data = {
        "id": 1,
        "name": "Bob",
        "email": "bob@example.com"
    }
    fastapi_client.post("/users", json=user_data)
    
    # 获取用户
    response = fastapi_client.get("/users/1")
    assert response.status_code == 200
    
    data = response.json()
    assert data["name"] == "Bob"

def test_fastapi_get_nonexistent_user(fastapi_client):
    """测试 FastAPI 获取不存在的用户"""
    response = fastapi_client.get("/users/999")
    assert response.status_code == 404

# 数据库集成测试
class TestDatabaseIntegration(unittest.TestCase):
    """数据库集成测试"""
    
    def setUp(self):
        """测试前准备"""
        # 创建内存数据库
        self.engine = create_engine('sqlite:///:memory:')
        Base.metadata.create_all(self.engine)
        
        # 创建会话
        Session = sessionmaker(bind=self.engine)
        self.session = Session()
    
    def tearDown(self):
        """测试后清理"""
        self.session.close()
    
    def test_create_user_in_database(self):
        """测试在数据库中创建用户"""
        user = UserModel(name='Alice', email='alice@example.com')
        self.session.add(user)
        self.session.commit()
        
        # 验证用户已创建
        retrieved_user = self.session.query(UserModel).filter_by(name='Alice').first()
        self.assertIsNotNone(retrieved_user)
        self.assertEqual(retrieved_user.email, 'alice@example.com')
    
    def test_update_user_in_database(self):
        """测试更新数据库中的用户"""
        # 创建用户
        user = UserModel(name='Bob', email='bob@example.com')
        self.session.add(user)
        self.session.commit()
        
        # 更新用户
        user.email = 'bob.new@example.com'
        self.session.commit()
        
        # 验证更新
        retrieved_user = self.session.query(UserModel).filter_by(name='Bob').first()
        self.assertEqual(retrieved_user.email, 'bob.new@example.com')
    
    def test_delete_user_from_database(self):
        """测试从数据库删除用户"""
        # 创建用户
        user = UserModel(name='Charlie', email='charlie@example.com')
        self.session.add(user)
        self.session.commit()
        
        # 删除用户
        self.session.delete(user)
        self.session.commit()
        
        # 验证删除
        retrieved_user = self.session.query(UserModel).filter_by(name='Charlie').first()
        self.assertIsNone(retrieved_user)

# 外部服务集成测试
class TestExternalServiceIntegration(unittest.TestCase):
    """外部服务集成测试"""
    
    @patch('requests.get')
    def test_external_api_integration(self, mock_get):
        """测试外部 API 集成"""
        # 设置 Mock 响应
        mock_response = Mock()
        mock_response.json.return_value = {
            'id': 1,
            'name': 'External User',
            'email': 'external@example.com'
        }
        mock_response.status_code = 200
        mock_get.return_value = mock_response
        
        # 调用外部 API
        response = requests.get('https://api.example.com/users/1')
        
        # 验证响应
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(data['name'], 'External User')
        
        # 验证 API 调用
        mock_get.assert_called_once_with('https://api.example.com/users/1')
    
    def test_redis_integration(self):
        """测试 Redis 集成"""
        # 连接到 Redis（假设本地运行）
        try:
            redis_client = redis.Redis(host='localhost', port=6379, db=0)
            
            # 设置值
            redis_client.set('test_key', 'test_value')
            
            # 获取值
            value = redis_client.get('test_key')
            
            # 验证
            self.assertEqual(value.decode('utf-8'), 'test_value')
            
            # 清理
            redis_client.delete('test_key')
            
        except redis.ConnectionError:
            self.skipTest("Redis 服务器未运行")

# 端到端测试
class TestEndToEndIntegration(unittest.TestCase):
    """端到端集成测试"""
    
    def setUp(self):
        """测试前准备"""
        # 设置 Chrome 选项
        chrome_options = Options()
        chrome_options.add_argument('--headless')  # 无头模式
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        
        # 创建 WebDriver
        try:
            self.driver = webdriver.Chrome(options=chrome_options)
        except Exception:
            self.skipTest("Chrome WebDriver 未配置")
        
        self.driver.implicitly_wait(10)
    
    def tearDown(self):
        """测试后清理"""
        if hasattr(self, 'driver'):
            self.driver.quit()
    
    def test_web_application_workflow(self):
        """测试 Web 应用工作流"""
        # 启动本地应用（假设）
        app = create_flask_app()
        
        # 访问首页
        self.driver.get('http://localhost:5000')
        self.assertIn('Welcome', self.driver.title)
        
        # 查找并点击用户管理链接
        user_link = self.driver.find_element(By.LINK_TEXT, 'Users')
        user_link.click()
        
        # 等待用户列表页面加载
        WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.ID, 'user-list'))
        )
        
        # 点击添加用户按钮
        add_button = self.driver.find_element(By.ID, 'add-user')
        add_button.click()
        
        # 填写用户表单
        name_input = self.driver.find_element(By.ID, 'name')
        email_input = self.driver.find_element(By.ID, 'email')
        
        name_input.send_keys('E2E Test User')
        email_input.send_keys('e2e@example.com')
        
        # 提交表单
        submit_button = self.driver.find_element(By.ID, 'submit')
        submit_button.click()
        
        # 验证用户已创建
        WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.XPATH, "//td[text()='E2E Test User']"))
        )
        
        # 验证用户列表包含新用户
        user_table = self.driver.find_element(By.ID, 'user-list')
        self.assertIn('E2E Test User', user_table.text)
        self.assertIn('e2e@example.com', user_table.text)

# API 集成测试
class TestAPIIntegration(unittest.TestCase):
    """API 集成测试"""
    
    def setUp(self):
        """测试前准备"""
        self.base_url = 'http://localhost:5000/api'
        self.app = create_flask_app()
        self.app_context = self.app.app_context()
        self.app_context.push()
    
    def tearDown(self):
        """测试后清理"""
        self.app_context.pop()
    
    def test_complete_user_workflow(self):
        """测试完整的用户工作流"""
        # 1. 获取初始用户列表
        response = requests.get(f'{self.base_url}/users')
        self.assertEqual(response.status_code, 200)
        initial_users = response.json()
        initial_count = len(initial_users)
        
        # 2. 创建新用户
        new_user = {
            'name': 'Integration Test User',
            'email': 'integration@example.com'
        }
        response = requests.post(
            f'{self.base_url}/users',
            json=new_user
        )
        self.assertEqual(response.status_code, 201)
        created_user = response.json()
        
        # 3. 验证用户已创建
        self.assertEqual(created_user['name'], new_user['name'])
        self.assertEqual(created_user['email'], new_user['email'])
        self.assertIn('id', created_user)
        
        # 4. 获取更新后的用户列表
        response = requests.get(f'{self.base_url}/users')
        self.assertEqual(response.status_code, 200)
        updated_users = response.json()
        self.assertEqual(len(updated_users), initial_count + 1)
        
        # 5. 根据ID获取用户
        response = requests.get(f'{self.base_url}/users/{created_user["id"]}')
        self.assertEqual(response.status_code, 200)
        retrieved_user = response.json()
        self.assertEqual(retrieved_user['id'], created_user['id'])
        
        # 6. 验证用户在列表中
        user_ids = [user['id'] for user in updated_users]
        self.assertIn(created_user['id'], user_ids)

# 性能集成测试
class TestPerformanceIntegration(unittest.TestCase):
    """性能集成测试"""
    
    def test_api_response_time(self):
        """测试 API 响应时间"""
        app = create_flask_app()
        client = app.test_client()
        
        # 测试多次请求的响应时间
        response_times = []
        for _ in range(10):
            start_time = time.time()
            response = client.get('/users')
            end_time = time.time()
            
            self.assertEqual(response.status_code, 200)
            response_times.append(end_time - start_time)
        
        # 计算平均响应时间
        avg_response_time = sum(response_times) / len(response_times)
        
        # 验证响应时间在可接受范围内
        self.assertLess(avg_response_time, 0.1, "平均响应时间过长")
    
    def test_concurrent_requests(self):
        """测试并发请求"""
        import threading
        import queue
        
        app = create_flask_app()
        client = app.test_client()
        results = queue.Queue()
        
        def make_request():
            response = client.get('/users')
            results.put(response.status_code)
        
        # 创建多个线程并发请求
        threads = []
        for _ in range(20):
            thread = threading.Thread(target=make_request)
            threads.append(thread)
            thread.start()
        
        # 等待所有线程完成
        for thread in threads:
            thread.join()
        
        # 验证所有请求都成功
        success_count = 0
        while not results.empty():
            if results.get() == 200:
                success_count += 1
        
        self.assertEqual(success_count, 20, "部分并发请求失败")

# 测试配置和工具
@pytest.fixture(scope="session")
def test_database():
    """测试数据库固件"""
    engine = create_engine('sqlite:///:memory:')
    Base.metadata.create_all(engine)
    
    Session = sessionmaker(bind=engine)
    session = Session()
    
    yield session
    
    session.close()

@pytest.fixture
def api_client():
    """API 客户端固件"""
    app = create_flask_app()
    return app.test_client()

# 集成测试套件
def create_integration_test_suite():
    """创建集成测试套件"""
    suite = unittest.TestSuite()
    
    # 添加测试类
    suite.addTest(unittest.makeSuite(TestFlaskIntegration))
    suite.addTest(unittest.makeSuite(TestDatabaseIntegration))
    suite.addTest(unittest.makeSuite(TestExternalServiceIntegration))
    suite.addTest(unittest.makeSuite(TestAPIIntegration))
    suite.addTest(unittest.makeSuite(TestPerformanceIntegration))
    
    return suite

if __name__ == '__main__':
    # 运行集成测试
    unittest.main(verbosity=2)
    
    # 或者运行自定义测试套件
    # suite = create_integration_test_suite()
    # runner = unittest.TextTestRunner(verbosity=2)
    # runner.run(suite)
```

## 扩展资源

- [Flask 测试文档](https://flask.palletsprojects.com/en/1.1.x/testing/)
- [Django 测试文档](https://docs.djangoproject.com/en/stable/topics/testing/)
- [FastAPI 测试文档](https://fastapi.tiangolo.com/tutorial/testing/)
- [Selenium 文档](https://selenium-python.readthedocs.io/)
- [pytest 文档](https://docs.pytest.org/)
- [requests-mock 文档](https://requests-mock.readthedocs.io/)
# Python 特殊方法

## 最佳提示词

```
请详细介绍 Python 的特殊方法，包括以下内容：

1. 常见特殊方法：
   - __init__、__del__ 构造与析构
   - __str__、__repr__ 字符串表示
   - __len__、__bool__ 长度与布尔值
   - __call__ 使对象可调用

2. 比较操作符：
   - __eq__、__ne__ 等于与不等于
   - __lt__、__le__、__gt__、__ge__ 大小比较
   - __hash__ 哈希值

3. 容器操作：
   - __getitem__、__setitem__、__delitem__ 索引操作
   - __iter__、__next__ 迭代器协议
   - __contains__ 成员测试

4. 数值操作：
   - __add__、__sub__、__mul__ 算术运算
   - __radd__、__rsub__ 反向运算
   - __iadd__、__isub__ 增量赋值

5. 属性访问：
   - __getattr__、__getattribute__ 属性获取
   - __setattr__、__delattr__ 属性设置与删除
   - __dir__ 目录列表

请为每个特殊方法提供详细的代码示例，包括实际应用场景和注意事项。
```

## 学习要点

- 理解特殊方法的概念和作用
- 掌握常用特殊方法的定义和使用
- 学会自定义对象的字符串表示
- 理解比较操作符的实现
- 掌握容器协议的实现
- 学会自定义数值运算
- 理解属性访问控制机制
- 了解特殊方法的性能考虑

## 实践练习

1. 实现自定义类的字符串表示
2. 创建支持比较操作的自定义类
3. 实现容器协议（索引、迭代等）
4. 创建支持数值运算的自定义类
5. 实现属性访问控制
6. 创建可调用对象
7. 实现上下文管理器协议
8. 创建支持序列化的自定义类

## 代码示例模板

```python
# 基本特殊方法示例
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        """用户友好的字符串表示"""
        return f"{self.name} ({self.age} years old)"
    
    def __repr__(self):
        """开发者友好的字符串表示"""
        return f"Person('{self.name}', {self.age})"
    
    def __len__(self):
        """返回年龄作为长度"""
        return self.age
    
    def __bool__(self):
        """布尔值判断"""
        return self.age >= 18
    
    def __call__(self, greeting):
        """使对象可调用"""
        return f"{self.name} says: {greeting}"

# 比较操作符示例
class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score
    
    def __eq__(self, other):
        """等于比较"""
        if isinstance(other, Student):
            return self.score == other.score
        return False
    
    def __lt__(self, other):
        """小于比较"""
        if isinstance(other, Student):
            return self.score < other.score
        return NotImplemented
    
    def __le__(self, other):
        """小于等于比较"""
        return self == other or self < other
    
    def __hash__(self):
        """哈希值，用于集合和字典"""
        return hash((self.name, self.score))

# 容器操作示例
class CustomList:
    def __init__(self, initial_data=None):
        self._data = list(initial_data) if initial_data else []
    
    def __getitem__(self, index):
        """索引访问"""
        return self._data[index]
    
    def __setitem__(self, index, value):
        """索引设置"""
        self._data[index] = value
    
    def __delitem__(self, index):
        """索引删除"""
        del self._data[index]
    
    def __len__(self):
        """长度"""
        return len(self._data)
    
    def __iter__(self):
        """迭代器"""
        return iter(self._data)
    
    def __contains__(self, item):
        """成员测试"""
        return item in self._data

# 数值操作示例
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        """加法运算"""
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented
    
    def __radd__(self, other):
        """反向加法"""
        return self.__add__(other)
    
    def __iadd__(self, other):
        """增量加法"""
        if isinstance(other, Vector):
            self.x += other.x
            self.y += other.y
            return self
        return NotImplemented
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# 属性访问控制示例
class ControlledAccess:
    def __init__(self):
        self._data = {}
    
    def __getattr__(self, name):
        """获取不存在的属性时调用"""
        if name.startswith('get_'):
            attr_name = name[4:]
            return self._data.get(attr_name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
    
    def __setattr__(self, name, value):
        """设置属性时调用"""
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            if not hasattr(self, '_data'):
                super().__setattr__('_data', {})
            self._data[name] = value

# 上下文管理器示例
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        """进入上下文"""
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文"""
        if self.file:
            self.file.close()
        return False  # 不抑制异常

# 使用示例
with FileManager('example.txt', 'w') as f:
    f.write('Hello, World!')
```

## 扩展资源

- [Python 特殊方法文档](https://docs.python.org/3/reference/datamodel.html#special-method-names)
- [Python 数据模型](https://docs.python.org/3/reference/datamodel.html)
- [上下文管理器](https://docs.python.org/3/library/contextlib.html)
- [Python 迭代器协议](https://docs.python.org/3/library/stdtypes.html#typeiter)
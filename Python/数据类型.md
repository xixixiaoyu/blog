Python 的设计哲学强调代码的可读性和简洁性，其数据类型系统体现了“**一切皆对象**”的思想。Python 是**动态强类型**语言：
*   **动态**：变量无需声明类型，类型取决于绑定的对象。
*   **强类型**：不同类型之间通常不允许进行隐式转换（例如不能直接将字符串与整数相加），保证了操作的安全性。

下面我们将深入剖析 Python 的数据类型。

---

### 1. 基本数据类型 (Basic Data Types)

这些是构建程序的原子单位，它们通常是不可变的（Immutable）。

#### 整数 (int)
Python 3 的整数没有大小限制（仅受限于内存），它自动处理大数运算，不再区分 `int` 和 `long`。

*   **内部原理**：Python 的 `int` 是一个 C 结构体，内部使用数组来存储数字的“位”，因此可以表示任意精度的整数。

```python
# 1. 不同进制表示
num_dec = 10        # 十进制
num_bin = 0b1010    # 二进制 (0b 开头)
num_oct = 0o12      # 八进制 (0o 开头)
num_hex = 0xA       # 十六进制 (0x 开头)

print(f'{num_bin} {num_oct} {num_hex}')  # 输出均为 10

# 2. 大数运算
big_num = 2 ** 100
print(f'2的100次方: {big_num}') 

# 3. 地板除 (//)
print(10 // 3)  # 输出 3，只保留整数部分
```

#### 浮点数 (float)
Python 的浮点数对应 C 语言的 `double`，遵循 IEEE 754 标准。

*   **精度问题**：计算机使用二进制存储小数，无法精确表示某些十进制小数（如 0.1）。
*   **科学计数法**：使用 `e` 或 `E` 表示 10 的幂。

```python
# 1. 精度陷阱
val = 0.1 + 0.2
print(val)           # 输出 0.30000000000000004
print(val == 0.3)    # False

# 解决方案：涉及金钱计算请使用 decimal 模块
from decimal import Decimal
print(Decimal('0.1') + Decimal('0.2') == Decimal('0.3')) # True

# 2. 科学计数法
sci_num = 1.23e-4    # 等于 0.000123
```

#### 布尔值 (bool)
布尔值只有 `True` 和 `False`。

*   **本质**：`bool` 是 `int` 的子类。`True` 对应 `1`，`False` 对应 `0`。这意味着它们可以参与数学运算（虽然不推荐这样做）。

```python
is_valid = True
print(is_valid + 1)  # 输出 2 (1 + 1)

# 逻辑运算
print(True and False) # False
print(True or False)  # True
print(not True)       # False
```

#### 字符串 (str)
字符串是 Unicode 字符的不可变序列。

*   **内部原理**：Python 3 字符串默认是 Unicode。根据字符串内容，Python 内部会灵活使用 Latin-1、UCS-2 或 UCS-4 编码来节省内存。

```python
# 1. 创建方式
s1 = '单引号'
s2 = "双引号"
s3 = """三引号
可以换行"""

# 2. 转义与原始字符串
path = 'C:\\Windows\\System32'  # 需要转义反斜杠
raw_path = r'C:\Windows\System32' # r 前缀表示原始字符串，忽略转义

# 3. 常用操作
text = " Python "
print(text.strip())      # 去除首尾空格: "Python"
print(text.replace('P', 'J')) # 替换: " Jython "
# 注意：因为不可变，上述操作都会返回新字符串，原 text 不变
```

---

### 2. 复合数据类型 (Composite Data Types)

这些类型用于组织和存储一组数据。

#### 列表 (list)
有序、可变的数据集合。

*   **内部原理**：**动态数组**。它存储的是对象的指针（引用）。为了实现 $O(1)$ 的追加操作，列表通常会预分配比实际需求更多的内存（Over-allocation）。

```python
# 1. 创建与操作
fruits = ['apple', 'banana']
fruits.append('cherry')  # 追加
fruits.insert(0, 'pear') # 插入

# 2. 索引与切片 [start:end:step]
nums = [0, 1, 2, 3, 4, 5]
print(nums[1:4])    # [1, 2, 3] (左闭右开)
print(nums[::-1])   # [5, 4, 3, 2, 1, 0] (反转)

# 3. 列表推导式 (Pythonic)
squares = [x**2 for x in range(5)] # [0, 1, 4, 9, 16]
```

#### 元组 (tuple)
有序、**不可变**的数据集合。

*   **使用场景**：数据不应被修改（如配置项、数据库查询结果）；作为字典的键（因为不可变，所以可哈希）。
*   **特点**：内存占用比列表略小，创建速度更快。

```python
# 1. 创建
point = (10, 20)
single = (1,)  # 单个元素元组必须加逗号，否则会被视为括号运算

# 2. 解包 (Unpacking)
x, y = point
print(f'x={x}, y={y}')
```

#### 字典 (dict)
无序（Python 3.7+ 保持插入顺序）、可变的键值对集合。

*   **内部原理**：**哈希表 (Hash Table)**。通过计算 Key 的哈希值来确定存储位置，查找速度接近 $O(1)$。Key 必须是**可哈希的**（不可变类型，如 int, str, tuple）。

```python
# 1. 创建与访问
user = {'name': 'Alice', 'age': 25}
print(user['name'])
print(user.get('height', 170)) # 安全获取，若不存在返回默认值

# 2. 常用操作
user['city'] = 'Beijing' # 新增
keys = user.keys()       # 获取所有键
values = user.values()   # 获取所有值
items = user.items()     # 获取所有键值对

# 3. 字典推导式
swapped = {v: k for k, v in user.items()} # 键值互换
```

#### 集合 (set)
无序、不重复的元素集合。

*   **内部原理**：类似于只有 Key 没有 Value 的哈希表。主要用于去重和数学集合运算。

```python
# 1. 去重
nums = [1, 2, 2, 3, 3, 3]
unique_nums = list(set(nums)) # [1, 2, 3]

# 2. 集合运算
a = {1, 2, 3}
b = {3, 4, 5}

print(a | b)  # 并集: {1, 2, 3, 4, 5}
print(a & b)  # 交集: {3}
print(a - b)  # 差集: {1, 2}
```

---

### 3. 类型转换

#### 隐式类型转换
Python 会在不丢失精度的情况下自动转换类型（主要是数字之间）。

```python
res = 1 + 2.5  # int + float -> float
print(type(res)) # <class 'float'>
```

#### 显式类型转换
强制将一种类型转换为另一种。

```python
# int()
print(int(3.9))      # 3 (截断，非四舍五入)
print(int("10"))     # 10
# print(int("10.5")) # 报错！字符串转 int 必须是整数格式

# str()
print(str(123))      # "123"
print(str([1, 2]))   # "[1, 2]"

# list() / tuple()
print(list((1, 2)))  # 元组转列表
```

**注意事项**：
1.  转换必须符合逻辑（例如不能直接把非数字字符串转为整数）。
2.  浮点转整数会丢失小数部分。

---

### 4. 类型检查与判断

#### `type()` vs `isinstance()`

*   `type(obj)`：返回对象的具体类型类。
*   `isinstance(obj, class_or_tuple)`：检查对象是否是该类或其子类的实例。

**区别核心**：`isinstance` 支持继承关系判断，而 `type` 不支持。

```python
class Animal: pass
class Dog(Animal): pass

d = Dog()

# type() 严格匹配
print(type(d) == Animal)     # False
print(type(d) == Dog)        # True

# isinstance() 支持继承 (推荐使用)
print(isinstance(d, Animal)) # True
print(isinstance(d, (int, str, Animal))) # 检查是否属于元组中的任意一种类型
```

---

### 5. None 类型

`None` 是 Python 中一个特殊的常量，表示“无”、“空”或“缺失”。

*   **单例模式**：在 Python 解释器生命周期中，只有一个 `None` 对象。
*   **比较**：永远使用 `is` 而不是 `==` 来判断 `None`。

```python
val = None

# 正确写法
if val is None:
    print("It is None")

# 错误写法 (虽然通常能工作，但对于重载了 __eq__ 的对象可能失效)
if val == None:
    pass
```

---

### 6. 数据类型的选择原则

作为良师益友，我建议你在编码时遵循以下原则：

1.  **可变性 (Mutability)**：
    *   如果数据创建后不应改变，优先使用 `tuple` 而非 `list`。这不仅更安全，而且 `tuple` 内存占用更小，且可作为字典的 Key。
    *   字符串处理频繁拼接时，考虑使用 `list` 收集后用 `''.join()`，或者使用 `io.StringIO`，避免产生大量临时字符串对象。

2.  **查找性能**：
    *   如果需要频繁判断“元素是否存在”，请使用 `set` 或 `dict`（时间复杂度 $O(1)$），不要使用 `list`（时间复杂度 $O(n)$）。

3.  **语义化**：
    *   如果数据结构复杂，不要单纯嵌套字典和列表。考虑使用 `dataclasses` 或 `NamedTuple` 来定义数据结构，提高代码可读性。

4.  **真值测试**：
    *   利用 Python 的隐式布尔值：空列表 `[]`、空字符串 `""`、`0`、`None` 都会被视为 `False`。
    *   写法推荐：`if my_list:` (如果列表不为空) 而不是 `if len(my_list) > 0:`。

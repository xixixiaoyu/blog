控制结构是编程语言的骨架，它们决定了代码执行的流向。Python 以其“优雅”和“明确”著称，其控制结构的设计也深刻体现了这一哲学。

我们将不仅仅停留在语法层面，而是深入到执行逻辑、内存效率以及 Pythonic（Python 风格）的最佳实践中去。

---

### 1. 条件语句：决策的逻辑

Python 的条件语句通过判断真值（Truthiness）来决定代码的分支。

#### 1.1 基本语法与多重判断
Python 使用缩进来划分代码块，这强制了代码的可读性。

```python
def check_status(code):
    # if-elif-else 结构
    if code == 200:
        print('请求成功')
    elif code == 404:
        print('未找到资源')
    elif code == 500:
        print('服务器内部错误')
    else:
        print(f'未知状态码: {code}')

check_status(404)
```

#### 1.2 条件表达式（三元运算符）
Python 没有 C 语言风格的 `? :`，而是使用更具可读性的英文语序。

```python
score = 85
# 语法: value_if_true if condition else value_if_false
result = '及格' if score >= 60 else '不及格'
print(result)
```

#### 1.3 深入本质：真值测试（Truth Value Testing）
这是新手常忽略的**核心概念**。在 Python 中，不仅仅是 `True` 和 `False`，任何对象都可以进行布尔值测试。
*   **被视为 False 的值**：`None`, `False`, 0, 0.0, `''` (空字符串), `[]` (空列表), `()` (空元组), `{}` (空字典)。
*   **其他值通常视为 True**。

**最佳实践**：不要显式地与 `True` 或 `False` 比较。

```python
user_list = []

# ❌ 不推荐：冗余且不 Pythonic
if len(user_list) > 0:
    pass

# ✅ 推荐：利用空列表隐式为 False 的特性
if user_list:
    print('列表不为空')
else:
    print('列表为空')
```

#### 1.4 嵌套与 Guard Clauses（卫语句）
深层嵌套是代码可读性的杀手。

**❌ 糟糕的嵌套：**
```python
def process_payment(user, amount):
    if user.is_active:
        if amount > 0:
            if user.balance >= amount:
                user.balance -= amount
                print('支付成功')
```

**✅ 最佳实践（卫语句）：** 尽早返回，减少缩进。
```python
def process_payment(user, amount):
    if not user.is_active:
        return
    if amount <= 0:
        return
    if user.balance < amount:
        print('余额不足')
        return
    
    user.balance -= amount
    print('支付成功')
```

---

### 2. 循环语句：重复的力量

#### 2.1 for 循环与迭代
Python 的 `for` 循环本质上是**遍历迭代器（Iterator）**，而不是像 C 语言那样基于索引计数。

```python
# 遍历序列
names = ['Alice', 'Bob', 'Charlie']
for name in names:
    print(name)

# range() 函数：生成数字序列（左闭右开）
# range(start, stop, step)
for i in range(0, 10, 2):
    print(i, end=' ')  # 输出: 0 2 4 6 8
print()
```

**常见场景与技巧：**
*   需要索引时，使用 `enumerate()`。
*   同时遍历两个列表时，使用 `zip()`。

```python
colors = ['red', 'green', 'blue']
# ✅ 推荐：同时获取索引和值
for index, color in enumerate(colors):
    print(f'{index}: {color}')
```

#### 2.2 while 循环
适用于不知道具体循环次数，只知道终止条件的场景。

```python
count = 3
while count > 0:
    print(f'倒计时: {count}')
    count -= 1
```

#### 2.3 循环控制与 else 子句
*   `break`: 立即终止循环。
*   `continue`: 跳过本次迭代，进入下一次。
*   `pass`: 占位符，什么都不做（用于保持语法结构完整）。

**循环中的 `else`**：这是一个容易被误解的特性。`else` 块仅在**循环正常结束**（即没有被 `break` 打断）时执行。它常用于“搜索”场景。

```python
# 场景：在列表中查找质数
numbers = [4, 6, 8, 9, 11, 12]

for num in numbers:
    if num == 11:
        print('找到了 11！')
        break  # 触发 break，else 不会执行
else:
    # 如果循环完整跑完都没遇到 break，则执行这里
    print('列表中没有找到目标数字')
```

---

### 3. 异常处理：构建健壮的程序

Python 提倡 **EAFP** 原则（Easier to Ask for Forgiveness than Permission，请求原谅比请求许可更容易）。这意味着我们通常先尝试执行代码，出错了再捕获，而不是先做各种检查。

#### 3.1 完整结构：try-except-else-finally

```python
def divide(a, b):
    try:
        # 可能抛出异常的代码
        result = a / b
    except ZeroDivisionError:
        # 捕获特定异常
        print('错误：除数不能为零')
    except TypeError as e:
        # 捕获类型错误，并获取异常对象
        print(f'错误：类型不对 - {e}')
    else:
        # 只有在 try 块没有抛出异常时执行
        print(f'计算成功，结果是: {result}')
    finally:
        # 无论是否发生异常，都会执行（常用于资源清理）
        print('--- 计算结束 ---')

divide(10, 2)
divide(10, 0)
```

#### 3.2 自定义异常
当内置异常无法准确描述业务错误时，应继承 `Exception` 类。

```python
class InsufficientFundsError(Exception):
    """自定义余额不足异常"""
    def __init__(self, balance, amount):
        self.message = f'余额 {balance} 不足以支付 {amount}'
        super().__init__(self.message)

def withdraw(balance, amount):
    if amount > balance:
        raise InsufficientFundsError(balance, amount)
    return balance - amount
```

#### 3.3 最佳实践
1.  **不要捕获所有异常**：避免使用裸露的 `except:`，这会掩盖真正的 Bug（如 `KeyboardInterrupt`）。
2.  **异常传播**：如果在当前层级无法处理异常，最好让它向上抛出，或者记录日志后重新抛出（`raise`）。

---

### 4. 迭代器与生成器：内存效率的艺术

这是 Python 处理大数据的核心机制。

#### 4.1 迭代器协议
任何实现了 `__iter__` 和 `__next__` 方法的对象都是迭代器。

#### 4.2 生成器（Generator）
生成器是一种简单的创建迭代器的方式。它使用 `yield` 关键字。
**核心优势**：**惰性求值（Lazy Evaluation）**。它不会一次性把所有数据加载到内存，而是用一个生成一个。

**场景**：读取一个 10GB 的日志文件。

```python
def read_large_file(file_path):
    """生成器函数：逐行读取文件"""
    with open(file_path, 'r') as f:
        for line in f:
            yield line.strip()

# 使用生成器
# 此时并没有读取文件，只是返回了一个生成器对象
log_gen = read_large_file('system.log') 

# 只有在迭代时，才会真正去读取文件
# for log in log_gen:
#     process(log)
```

#### 4.3 生成器表达式
类似于列表推导式，但使用圆括号 `()`。

```python
import sys

# 列表推导式：立即生成所有数据，占用大量内存
list_comp = [x**2 for x in range(10000)]
print(f'List 占用内存: {sys.getsizeof(list_comp)} bytes')

# 生成器表达式：几乎不占内存
gen_exp = (x**2 for x in range(10000))
print(f'Generator 占用内存: {sys.getsizeof(gen_exp)} bytes')
```

---

### 5. 上下文管理器：优雅的资源管理

#### 5.1 with 语句
`with` 语句用于自动管理资源（如文件、网络连接、锁）。它确保即使发生异常，资源也能被正确释放（自动调用 `close()`）。

```python
# 传统方式（容易忘记 close 或因异常跳过 close）
f = open('test.txt', 'w')
try:
    f.write('Hello')
finally:
    f.close()

# Pythonic 方式
with open('test.txt', 'w') as f:
    f.write('Hello')
# 离开缩进块后，文件自动关闭
```

#### 5.2 自定义上下文管理器
可以通过实现 `__enter__` 和 `__exit__` 方法来创建。

```python
import time

class Timer:
    """用于计时的上下文管理器"""
    def __enter__(self):
        self.start = time.time()
        return self  # 返回的对象会被赋值给 as 后面的变量

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end = time.time()
        print(f'代码块执行耗时: {self.end - self.start:.4f} 秒')
        # 返回 False 表示不压制异常，异常会继续向外抛出
        return False

# 使用自定义管理器
with Timer():
    # 模拟耗时操作
    sum(range(1000000))
```

也可以使用 `contextlib` 装饰器简化写法：

```python
from contextlib import contextmanager

@contextmanager
def temp_list_append(lst, item):
    """尝试添加元素，如果出错则回滚"""
    lst.append(item)
    try:
        yield lst
    except Exception:
        lst.pop() # 出错回滚
        raise

my_list = [1, 2]
try:
    with temp_list_append(my_list, 3):
        print('当前列表:', my_list)
        raise ValueError("故意出错")
except ValueError:
    print('捕获异常，列表状态:', my_list) # 3 被移除了
```

---

### 总结

1.  **条件语句**：利用真值测试简化代码，使用卫语句减少嵌套。
2.  **循环**：优先使用 `for` 迭代，理解 `else` 的搜索语义。
3.  **异常**：遵循 EAFP 原则，精确捕获，善用 `finally` 清理。
4.  **生成器**：处理大量数据时的内存救星，理解 `yield` 的暂停/恢复机制。
5.  **上下文管理器**：`with` 是管理资源的唯一正途。

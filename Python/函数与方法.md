作为一门“多范式”语言，Python 中的函数不仅是代码复用的基础单元，更是“一等公民（First-class Citizen）”。理解它们的底层机制，是你从 Python 使用者进阶为 Python 专家的必经之路。

我们将分六个章节深入剖析。

---

### 1. 函数基础：构建积木

在 Python 中，函数不仅仅是一段代码，它是一个对象。

#### 定义与调用
使用 `def` 关键字。函数体内的代码块通过缩进来界定。

```python
def greet(name):
    """这是一个简单的问候函数"""
    return f"Hello, {name}!"

# 调用
print(greet("Python"))
```

#### 参数传递机制
Python 的参数传递既不是“传值”，也不是“传引用”，而是**“传对象引用”（Call by Object Reference）**。
- 如果传递的是**不可变对象**（如 `int`, `str`, `tuple`），函数内修改不会影响外部。
- 如果传递的是**可变对象**（如 `list`, `dict`），函数内修改**会**影响外部。

#### 默认参数值（⚠️ 核心陷阱）
**最佳实践**：默认参数必须指向不可变对象（如 `None`），绝不要使用空列表或空字典。

**为什么？** 因为默认参数在函数**定义时**被计算并创建，而不是在调用时。

```python
# ❌ 错误示范
def append_to(element, target=[]):
    target.append(element)
    return target

print(append_to(1)) # [1]
print(append_to(2)) # [1, 2] -> 惊讶吗？它复用了同一个列表对象！

# ✅ 正确示范
def append_to_safe(element, target=None):
    if target is None:
        target = []
    target.append(element)
    return target
```

#### 可变参数与解包
- `*args`：接收任意数量的位置参数，打包成一个 **元组 (tuple)**。
- `**kwargs`：接收任意数量的关键字参数，打包成一个 **字典 (dict)**。

```python
def mixed_function(a, b, *args, **kwargs):
    print(f"a={a}, b={b}")
    print(f"args={args}")      # tuple
    print(f"kwargs={kwargs}")  # dict

# 参数解包（Unpacking）
nums = [1, 2, 3, 4]
config = {'key': 'value', 'debug': True}

# *nums 将列表解包为位置参数
# **config 将字典解包为关键字参数
mixed_function(*nums, **config)
# 输出:
# a=1, b=2
# args=(3, 4)
# kwargs={'key': 'value', 'debug': True}
```

---

### 2. 函数进阶：函数即对象

#### 函数作为对象
你可以将函数赋值给变量、存入列表、或者作为参数传递给另一个函数。

```python
def shout(text):
    return text.upper()

def whisper(text):
    return text.lower()

# 高阶函数：接收函数作为参数
def speak(func, text):
    # func 在这里只是一个变量名，指向传入的函数对象
    return func(text)

print(speak(shout, "Hello"))  # HELLO
```

#### 闭包（Closure）
闭包是指在一个内部函数中，引用了外部作用域（非全局）的变量，并且该内部函数被返回。
**本质**：闭包将代码和其执行环境（变量）打包在了一起。

```python
def make_multiplier(n):
    # 外部函数的变量 n 被内部函数捕获
    def multiplier(x):
        return x * n
    return multiplier

times3 = make_multiplier(3)
times5 = make_multiplier(5)

print(times3(10))  # 30
print(times5(10))  # 50

# 内部机制：查看闭包捕获的变量
print(times3.__closure__[0].cell_contents)  # 3
```

#### 装饰器（Decorator）
装饰器本质上是一个返回函数的高阶函数，用于在不修改原函数代码的前提下，增加功能（如日志、计时、权限校验）。

```python
import time
import functools

def timer(func):
    """计算函数执行时间的装饰器"""
    # wraps 保持原函数的元数据（如 __name__, __doc__）
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 耗时: {end - start:.4f}s")
        return result
    return wrapper

@timer  # 等价于 slow_add = timer(slow_add)
def slow_add(x, y):
    time.sleep(0.1)
    return x + y

slow_add(1, 2)
```

#### 类型提示（Type Hints）
Python 3.5+ 引入，虽然 Python 运行时不强制校验，但这对于大型项目维护和 IDE 智能提示至关重要。

```python
def calculate_area(radius: float) -> float:
    return 3.14 * radius * radius
```

---

### 3. 作用域与命名空间：LEGB 规则

当你在函数中使用一个变量名时，Python 会按照 **LEGB** 顺序查找：

1.  **L (Local)**: 局部作用域（函数内部）。
2.  **E (Enclosing)**: 嵌套函数的外部作用域（闭包）。
3.  **G (Global)**: 全局作用域（模块级别）。
4.  **B (Built-in)**: 内置作用域（如 `len`, `print`）。

#### global 与 nonlocal
- `global`: 声明变量属于全局作用域，用于在函数内修改全局变量。
- `nonlocal`: 声明变量属于外部嵌套作用域（非全局），常用于闭包中修改外部变量。

```python
x = 0  # Global

def outer():
    x = 1  # Enclosing
    
    def inner():
        nonlocal x  # 引用 outer 的 x
        x = 2
        print(f"Inner: {x}")
    
    inner()
    print(f"Outer: {x}") # 被 inner 修改为 2

outer()
print(f"Global: {x}")    # 仍然是 0
```

---

### 4. 生成器函数：惰性求值的艺术

生成器（Generator）是 Python 处理大量数据时的性能利器。

#### yield 关键字
包含 `yield` 的函数不再是普通函数，调用它会返回一个生成器对象。它不会一次性执行完，而是“暂停”和“恢复”。

**性能考虑**：生成器按需生成数据，**内存占用为 O(1)**，而列表是 O(N)。

```python
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a  # 暂停并返回 a，下次从这里继续
        a, b = b, a + b

# 使用
gen = fibonacci(5)
print(list(gen))  # [0, 1, 1, 2, 3]

# 生成器表达式（类似列表推导式，但用圆括号）
squares_gen = (x**2 for x in range(1000000))
# 此时几乎不占内存，只有在迭代 squares_gen 时才计算
```

---

### 5. 函数式编程：数据流水线

虽然 Python 不是纯函数式语言，但它提供了强大的工具。

#### Map, Filter, Reduce
- `map(func, iterable)`: 对每个元素应用函数。
- `filter(func, iterable)`: 筛选符合条件的元素。
- `reduce(func, iterable)`: 累积计算（需从 `functools` 导入）。

#### 列表推导式（List Comprehension）
**最佳实践**：在 Python 中，列表推导式通常比 `map` 和 `filter` 更易读，且速度相当甚至更快。

```python
data = [1, 2, 3, 4, 5]

# 场景：取出偶数并平方
# 方式 1: Map/Filter
result_mf = list(map(lambda x: x**2, filter(lambda x: x % 2 == 0, data)))

# 方式 2: 列表推导式 (推荐)
result_lc = [x**2 for x in data if x % 2 == 0]

print(result_lc) # [4, 16]
```

---

### 6. 方法：面向对象的函数

在类（Class）中定义的函数称为方法。它们的第一个参数通常具有特殊含义。

#### 实例方法、类方法、静态方法

```python
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    # 1. 实例方法 (Instance Method)
    # 必须包含 self，指向实例本身。可以访问实例属性。
    def format(self):
        return f"{self.year}-{self.month}-{self.day}"

    # 2. 类方法 (Class Method)
    # 使用 @classmethod，第一个参数是 cls (类本身)。
    # 常用于实现“工厂模式”，从不同格式创建实例。
    @classmethod
    def from_string(cls, date_str):
        year, month, day = map(int, date_str.split('-'))
        return cls(year, month, day) # 相当于 Date(year, month, day)

    # 3. 静态方法 (Static Method)
    # 使用 @staticmethod，没有 self 或 cls。
    # 仅仅是放在类命名空间下的普通函数，逻辑上与类相关，但不依赖类或实例的状态。
    @staticmethod
    def is_valid(year, month, day):
        return 1 <= month <= 12 and 1 <= day <= 31

# 使用
d1 = Date(2023, 10, 1)
d2 = Date.from_string("2023-12-25")
is_ok = Date.is_valid(2023, 13, 1) # False
```

#### 方法的绑定机制
当你通过实例访问方法时（如 `d1.format`），Python 会创建一个**绑定方法（Bound Method）**。
它实际上是一个“偏函数（Partial Function）”，自动将 `d1` 作为第一个参数 `self` 填入。

```python
func = d1.format
print(func) # <bound method Date.format of ...>
print(func()) # 调用时不需要传 self，因为已经绑定了
```

---

### 总结与建议

1.  **函数是对象**：利用这一特性可以编写出极具表现力的代码（如装饰器）。
2.  **作用域**：牢记 LEGB 规则，避免变量查找错误。
3.  **生成器**：处理大数据流时，优先考虑生成器以节省内存。
4.  **默认参数**：永远不要使用可变对象作为默认参数。
5.  **代码风格**：虽然函数式编程很酷，但在 Python 中，**可读性**（Readability）永远是第一位的。如果一行 `lambda` 过于复杂，请把它写成普通函数。

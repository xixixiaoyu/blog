作为一门优雅的语言，Python 的异常处理不仅仅是为了“修补错误”，更是其控制流的核心组成部分。

我们将从底层原理出发，逐步构建起完整的知识体系。

---

### 1. 异常基础：不仅仅是报错

#### 概念与类型
在 Python 中，异常（Exception）是一个对象，表示程序执行期间发生的错误或意外情况。当这些情况发生时，Python 会停止当前的执行流，并创建一个异常对象，“抛出”给运行时系统。

#### 异常的层次结构
Python 的异常是类的实例，它们构成了一个继承体系。理解这一点至关重要，因为它决定了 `except` 语句捕获错误的范围。

*   **`BaseException`**: 所有异常的基类。
    *   **`SystemExit`**: 解释器请求退出。
    *   **`KeyboardInterrupt`**: 用户中断执行（通常是 Ctrl+C）。
    *   **`Exception`**: **所有非系统退出类异常的基类**。我们在代码中捕获的通常是这个，而不是 `BaseException`。
        *   `ArithmeticError` (如 `ZeroDivisionError`)
        *   `LookupError` (如 `IndexError`, `KeyError`)
        *   `TypeError`, `ValueError` 等

#### 异常的传播机制（堆栈展开）
当异常发生时，如果当前函数没有处理它，它会向上传递给调用该函数的“上级”，直到被捕获或到达主程序（导致程序崩溃并打印 Traceback）。这被称为**堆栈展开（Stack Unwinding）**。

---

### 2. 核心武器：try-except 语句

这是处理异常的基本工具。

#### 基本语法与捕获特定异常
**原则**：只捕获你预期的、知道如何处理的异常。

```python
def calculate_ratio(a, b):
    try:
        # 尝试执行的代码块
        result = a / b
        return result
    except ZeroDivisionError:
        # 仅捕获除以零的错误
        print('错误：除数不能为零。')
        return None
    except TypeError as e:
        # 捕获类型错误，并获取异常对象 e
        print(f'错误：输入类型不对。详情：{e}')
        return None

# 测试
calculate_ratio(10, 0)  # 命中 ZeroDivisionError
calculate_ratio(10, '2') # 命中 TypeError
```

#### 捕获多种异常
如果你对多种异常的处理逻辑是一样的，可以将它们放在一个元组中。

```python
def process_data(data):
    try:
        value = data['key']
        return int(value)
    except (KeyError, ValueError) as e:
        # 无论是键不存在，还是值无法转为整数，都统一处理
        print(f'数据处理失败: {e}')
        return -1
```

#### 常见错误：裸捕获（Bare Except）
**请尽量避免这样做**，除非是在程序的最顶层作为最后的防线。

```python
# ❌ 糟糕的写法
try:
    do_something()
except:
    print('出错了') 
    # 这种写法会捕获 KeyboardInterrupt，导致你无法通过 Ctrl+C 终止程序！
    # 也会掩盖真正的 bug（如拼写错误）。
```

---

### 3. 高级异常处理：掌控全局

完整的异常处理结构是 `try-except-else-finally`。

#### try-except-else-finally 结构

*   **`else`**: 当 `try` 块**没有**抛出异常时执行。这有助于将“可能出错的代码”与“依赖成功结果的代码”分离开，缩小 `try` 的保护范围。
*   **`finally`**: 无论是否发生异常，也无论是否执行了 `return`，**总是**会执行。通常用于资源清理（关闭文件、释放锁）。

```python
def read_file_contents(filename):
    file = None
    try:
        file = open(filename, 'r', encoding='utf-8')
    except FileNotFoundError:
        print(f'错误：文件 {filename} 未找到。')
        return None
    else:
        # 只有文件成功打开才执行读取
        print('文件打开成功，开始读取...')
        return file.read()
    finally:
        # 无论成功还是失败，都要确保关闭文件句柄
        if file:
            file.close()
            print('资源已释放。')

# 即使在 else 中 return 了，finally 依然会在 return 前执行
```

#### 异常链与 raise
有时候我们需要捕获一个异常，包装后重新抛出，以便上层调用者能更好地理解上下文。Python 3 引入了 `raise ... from ...` 语法来保留原始异常信息。

```python
class DatabaseError(Exception):
    pass

def connect_db():
    try:
        # 模拟底层连接错误
        raise ConnectionRefusedError("连接被拒绝")
    except ConnectionRefusedError as e:
        # 抛出业务层面的异常，同时保留底层异常链
        raise DatabaseError("无法连接到数据库") from e

# 调用
try:
    connect_db()
except DatabaseError as e:
    print(f"捕获到：{e}")
    print(f"原始原因：{e.__cause__}") # 可以访问原始异常
```

---

### 4. 自定义异常：业务逻辑的体现

在构建大型应用时，内置异常往往不足以描述具体的业务错误。

#### 创建自定义异常
最佳实践是继承 `Exception` 类（而不是 `BaseException`）。

```python
class BusinessError(Exception):
    """业务异常基类"""
    pass

class InsufficientFundsError(BusinessError):
    """余额不足异常"""
    def __init__(self, current_balance, amount_needed):
        self.current_balance = current_balance
        self.amount_needed = amount_needed
        message = f"余额不足：当前 {current_balance}，需要 {amount_needed}"
        super().__init__(message)

def withdraw(balance, amount):
    if amount > balance:
        # 抛出带有丰富上下文信息的异常
        raise InsufficientFundsError(balance, amount)
    return balance - amount

# 使用
try:
    withdraw(100, 200)
except InsufficientFundsError as e:
    # 我们可以访问异常中的自定义属性进行逻辑处理
    print(f"交易失败：{e}")
    print(f"差额：{e.amount_needed - e.current_balance}")
```

---

### 5. 最佳实践与性能考量

#### EAFP vs LBYL
Python 社区推崇 **EAFP** (It's Easier to Ask for Forgiveness than Permission，请求原谅比请求许可更容易)。

*   **LBYL (Look Before You Leap)**: 先检查，后执行。
    ```python
    if 'key' in my_dict:
        value = my_dict['key']
    else:
        # handle error
    ```
*   **EAFP (Pythonic)**: 直接执行，出错再捕获。
    ```python
    try:
        value = my_dict['key']
    except KeyError:
        # handle error
    ```
    **理由**：EAFP 通常更快（因为大部分时候是正常的，省去了 `if` 检查的开销），且在并发环境下更安全（避免了检查和访问之间的时间差导致的竞态条件）。

#### 性能考虑
*   **无异常时的开销**：`try-except` 块在**没有**发生异常时，性能开销几乎可以忽略不计（Python 3.11+ 更是实现了零开销异常捕获）。
*   **发生异常时的开销**：抛出和捕获异常是相对昂贵的操作（涉及堆栈展开）。
*   **结论**：不要用异常来控制常规的业务逻辑循环（例如，不要用 `IndexError` 来结束列表遍历，应该用 `for` 循环）。异常应该用于“异常”情况。

#### 日志记录
不要只是 `print` 异常，要使用 `logging` 模块。

```python
import logging

logging.basicConfig(level=logging.ERROR)

try:
    1 / 0
except ZeroDivisionError:
    # logging.exception 会自动包含堆栈跟踪信息 (Traceback)
    logging.exception("计算过程中发生严重错误")
```

---

### 6. 调试技巧

#### 使用 traceback 模块
当你想打印异常的详细堆栈信息，但又不想让程序崩溃时，`traceback` 很有用。

```python
import traceback

try:
    raise ValueError("测试错误")
except ValueError:
    # 获取堆栈信息的字符串，可以写入数据库或发送报警
    error_msg = traceback.format_exc()
    print("捕获到异常，详细堆栈如下：")
    print(error_msg)
```

#### 单元测试中的异常
使用 `pytest` 或 `unittest` 确保你的代码在应该报错时确实报错了。

```python
import pytest

def strict_positive(n):
    if n <= 0:
        raise ValueError("必须是正数")

def test_strict_positive():
    # 断言：代码块必须抛出 ValueError，否则测试失败
    with pytest.raises(ValueError):
        strict_positive(-5)
```

### 总结

Python 的异常处理机制不仅仅是防御性的盾牌，更是构建健壮、清晰逻辑的利器。

1.  **精准捕获**：尽量捕获具体的异常类型，避免掩盖真相。
2.  **清理战场**：使用 `finally` 或 `with` 语句管理资源。
3.  **保留现场**：使用 `raise ... from` 保留原始错误链。
4.  **拥抱 EAFP**：大胆地写代码，优雅地处理错误。

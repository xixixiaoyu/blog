在 Nest 的世界里，提供者（Provider）就像是应用程序的"专业工匠"。

如果把应用比作一座房子，那么提供者就是电工、木匠、水管工这些各司其职的专业人士。

每个提供者都有自己的专长，通过依赖注入的方式为应用提供服务。

## 什么是提供者？
提供者本质上是一个可以被注入到其他类中的类。它们承担着不同的职责：

+ **服务（Service）**：处理业务逻辑和数据操作
+ **仓库（Repository）**：专门负责与数据库打交道
+ **工厂（Factory）**：负责创建复杂对象
+ **辅助类（Helper）**：提供各种通用功能

提供者最大的优势就是可以通过依赖注入（Dependency Injection）的方式被"送达"到需要它们的地方，这让代码变得更加模块化和可测试。



## 创建你的一个服务 (Service)
让我们通过一个管理猫咪信息的例子来了解如何创建服务。假设我们需要一个 `CatsService` 来处理所有关于猫咪的操作：

```typescript
import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable() // 这个装饰器是关键
export class CatsService {
  private readonly cats: Cat[] = []; // 用数组模拟数据库

  create(cat: Cat) {
    this.cats.push(cat);
    console.log('一只新猫咪加入了！现在有', this.cats.length, '只猫咪。');
  }

  findAll(): Cat[] {
    console.log('正在查找所有猫咪...');
    return this.cats;
  }
}
```

`@Injectable()` 装饰器相当于告诉 Nest：CatsService 这个类是个提供者，你可以管理它，也可以把它‘注入’给别人用。



## 在控制器中使用服务
现在我们有了 `CatsService`，接下来看看如何在控制器中使用它：

```typescript
import { Controller, Get, Post, Body } from '@nestjs/common';
import { CreateCatDto } from './dto/create-cat.dto';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

@Controller('cats')
export class CatsController {
  // 通过构造函数注入 CatsService
  constructor(private readonly catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
    return '成功添加了一只猫咪！';
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}
```

这里的关键是构造函数中的 `constructor(private readonly catsService: CatsService)`。

你只需要声明需要什么类型的依赖，NestJS 就会自动创建实例并注入进来。这就是依赖注入的魔法。



## 注册提供者
光定义服务还不够，你还需要告诉 Nest 这个服务的存在。这就需要在模块中注册它：

```typescript
// cats.module.ts
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService], // 在这里注册服务
  exports: [CatsService],   // 如果其他模块需要使用，记得导出
})
export class CatsModule {}
```

然后在主模块中导入这个特性模块：

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule], // 导入特性模块
})
export class AppModule {}
```

当 Nest 初始化 `CatsController` 时，发现它需要 `CatsService`，依赖注入系统就会自动找到已注册的提供者，实例化它并注入到控制器中。



## 异步提供者：处理复杂的初始化
想象一下这样的场景：你的应用需要在启动时连接数据库，只有连接成功后，其他服务才能正常工作。如果用传统方式，你可能需要写一堆回调或者 Promise 链，代码会变得复杂且难以维护。

异步提供者的解决方案非常直观，它使用 `async/await` 配合 `useFactory`：

```typescript
import { DataSource } from 'typeorm';

// 在模块的 providers 中配置
{
  provide: 'DATABASE_CONNECTION',
  useFactory: async (): Promise<DataSource> => {
    const dataSource = new DataSource({
      type: 'postgres',
      host: 'localhost',
      port: 5432,
      database: 'myapp',
      // 其他配置...
    });
    
    await dataSource.initialize();
    console.log('数据库连接建立成功！');
    return dataSource;
  },
}
```

Nest 会智能地检测到你的 `useFactory` 函数是异步的，然后耐心等待 Promise 完成。只有当数据库连接真正建立后，那些依赖这个连接的服务才会开始实例化。

在服务中注入使用：

```typescript
import { Injectable, Inject } from '@nestjs/common';
import { DataSource } from 'typeorm';

@Injectable()
export class UserService {
  constructor(
    @Inject('DATABASE_CONNECTION') 
    private readonly dataSource: DataSource
  ) {}

  async findAllUsers() {
    const userRepository = this.dataSource.getRepository(User);
    return await userRepository.find();
  }

  async createUser(userData: CreateUserDto) {
    const userRepository = this.dataSource.getRepository(User);
    const user = userRepository.create(userData);
    return await userRepository.save(user);
  }
}
```

如果你的工厂函数还需要其他依赖，可以通过 `inject` 参数注入：

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [ConfigModule],
  providers: [
    {
      provide: 'DATABASE_CONNECTION',
      useFactory: async (configService: ConfigService) => {
        // 异步初始化逻辑
      },
      inject: [ConfigService],
    },
    UserService,
  ],
  exports: ['DATABASE_CONNECTION'],
})
export class DatabaseModule {}
```



## 提供者的一些进阶玩法
### 作用域
NestJS 中的提供者默认采用**单例模式**（整个应用共享一个实例），但可以根据业务需求调整作用域。

1. DEFAULT（默认单例）

```typescript
import { Injectable } from '@nestjs/common';

@Injectable() // 等同于 @Injectable({ scope: Scope.DEFAULT })
export class UserService {
  private users: User[] = [];
  
  // 整个应用生命周期内只有一个实例
  // 所有模块共享同一个实例
  constructor() {
    console.log('UserService 实例创建');
  }
}
```

2. REQUEST（请求作用域）：

```typescript
import { Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class RequestScopedService {
  private requestData: any = {};
  
  // 每个 HTTP 请求创建新实例
  // 适合存储请求特有的信息（如用户信息、请求ID等）
  constructor() {
    console.log('RequestScopedService 实例创建');
  }
}
```

3. TRANSIENT（瞬态作用域）：

```typescript
import { Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.TRANSIENT })
export class TransientService {
  private instanceId = Math.random();
  
  // 每次注入都创建新实例
  // 完全独立的状态管理
  constructor() {
    console.log(`TransientService 实例创建，ID: ${this.instanceId}`);
  }
}
```

使用场景对比：

| 作用域 | 性能 | 内存占用 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **DEFAULT** | 最优 | 最低 | 无状态服务、工具类、数据库连接 |
| **REQUEST** | 中等 | 中等 | 用户认证、请求日志、请求上下文 |
| **TRANSIENT** | 较差 | 较高 | 需要完全隔离状态的特殊场景 |


### 可选依赖
有时某些依赖不是必需的，可以使用 `@Optional()` 装饰器：

```typescript
import { Injectable, Optional } from '@nestjs/common';

@Injectable()
export class AppService {
  constructor(
    @Optional() private readonly analyticsService?: AnalyticsService
  ) {
    // analyticsService 可能为 undefined
    if (this.analyticsService) {
      this.analyticsService.track('AppService initialized');
    }
  }
  
  doSomething() {
    // 使用前需要检查是否存在
    this.analyticsService?.track('Action performed');
  }
}
```

这在开发插件系统或可选功能时特别有用。

### 属性注入
除了构造函数注入，Nest 也支持属性注入：

```typescript
import { Injectable, Inject } from '@nestjs/common';

@Injectable()
export class CatsService {
  @Inject(ConfigService)
  private readonly configService: ConfigService;
  
  getSettings() {
    return this.configService.get('cats');
  }
}
```

不过，通常还是推荐用构造函数注入，因为依赖关系更清晰，也更便于测试。

### 手动获取实例
有时需要在运行时动态获取提供者实例，可以使用 `ModuleRef`：

```typescript
import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { UserService } from '../user/user.service';
import { LoggerService } from '../logger/logger.service';

@Injectable()
export class DynamicService {
  constructor(private moduleRef: ModuleRef) {}

  async getUserData(userId: string) {
    // 动态获取用户服务
    const userService = this.moduleRef.get(UserService);
    
    // 获取请求范围的日志服务（每次请求都是新实例）
    const logger = await this.moduleRef.resolve(LoggerService);
    
    logger.log(`Getting user data for ${userId}`);
    return userService.findById(userId);
  }

  async getServiceByName(serviceName: string) {
    try {
      // 根据字符串 token 动态获取服务
      const service = this.moduleRef.get(serviceName, { strict: false });
      return service;
    } catch (error) {
      console.log(`Service ${serviceName} not found`);
      return null;
    }
  }
}
```

### 自定义提供者
<font style="color:rgb(51, 51, 51);">到目前为止，我们看到的提供者都是基于类的。但 Nest 的依赖注入系统非常灵活，它不仅支持提供类作为 Provider，还可以提供：</font>

+ **<font style="color:rgb(51, 51, 51);">普通值 (Value Providers)：</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">使用</font><font style="color:rgb(51, 51, 51);"> </font>`<font style="color:rgb(192, 57, 43);background-color:rgb(236, 240, 241);">useValue</font>`<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">提供常量、配置对象等。</font>
+ **<font style="color:rgb(51, 51, 51);">类 (Class Providers)：</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">使用</font><font style="color:rgb(51, 51, 51);"> </font>`<font style="color:rgb(192, 57, 43);background-color:rgb(236, 240, 241);">useClass</font>`<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">提供一个类的实例（我们之前看到的默认方式）。</font>
+ **<font style="color:rgb(51, 51, 51);">工厂函数 (Factory Providers)：</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">使用</font><font style="color:rgb(51, 51, 51);"> </font>`<font style="color:rgb(192, 57, 43);background-color:rgb(236, 240, 241);">useFactory</font>`<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">根据动态逻辑（可以是同步或异步）创建和提供实例（如之前的数据库连接示例）。</font>
+ **<font style="color:rgb(51, 51, 51);">别名 (Alias Providers)：</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">使用</font><font style="color:rgb(51, 51, 51);"> </font>`<font style="color:rgb(192, 57, 43);background-color:rgb(236, 240, 241);">useExisting</font>`<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">为已存在的提供者创建一个别名或不同的 token。</font>

<font style="color:rgb(51, 51, 51);">这种灵活性使得你可以用非常精细的方式来管理和提供应用程序中的各种依赖，下面会介绍各种自定义提供者的具体使用方式和场景。</font>

## 从熟悉的服务类说起
我们先从最常见的服务类开始。在 Nest 项目中，创建一个服务通常是这样的：

```typescript
// app.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
```

这个 `@Injectable()` 装饰器就像给类贴了个标签，告诉 Nest："这个类可以被管理和注入"。然后在模块中注册：

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { AppService } from './app.service';

@Module({
  providers: [AppService], // 简写形式
})
export class AppModule {}
```

这种简写其实是下面完整形式的缩略版：

```typescript
{
  provide: AppService,    // 令牌 (Token)
  useClass: AppService    // 实际使用的类
}
```

这里的 `provide` 就是我们说的"令牌"，你可以把它理解成这个提供者的身份证。当我们需要某个依赖时，就是通过这个令牌来查找的。

而 `useClass` 则指定了 Nest 应该实例化哪个类来响应这个令牌。Nest 会自动帮我们创建 `AppService` 的实例，并在需要的地方把它“注入”进去。



## 依赖注入的两种方式
### 构造器注入（推荐）：
```typescript
// app.controller.ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  // 构造器注入：在构造函数参数里声明依赖
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

当 Nest 创建 `AppController` 实例时，它看到构造函数需要一个 `AppService` 类型的参数，就会查找与 `AppService` 这个令牌关联的提供者，然后把 `AppService` 的实例传递进来。

这里，`AppService` 类本身既是实际的类，也充当了令牌的角色。

### 属性注入
```typescript
// app.controller.ts (属性注入版本)
import { Controller, Get, Inject } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  @Inject(AppService) // 使用 @Inject 指定令牌
  private readonly appService: AppService;

  // 注意：如果用了属性注入，构造函数就不需要再声明 appService 了
  // constructor() {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

通过 `@Inject()` 装饰器并传入令牌 (这里是 `AppService` 类本身)，就能实现属性注入。



## 令牌不只是类名
令牌不一定非得是类名，字符串和 Symbol 也可以：

```typescript
// app.module.ts
providers: [
  {
    provide: 'APP_CONFIG',  // 字符串令牌
    useClass: AppService
  }
],
```

那么在注入的时候，就必须用 `@Inject()` 来明确指定这个字符串令牌了：

```typescript
constructor(@Inject('APP_CONFIG') private readonly appService: AppService) {}
```



## 动态选择实现类
显式使用 `useClass` 的一个强大之处在于，你可以根据条件动态地决定一个令牌具体由哪个类来实现。

最典型的例子就是根据不同的运行环境 (开发、生产) 加载不同的配置服务：

```typescript
// 抽象基类
export abstract class ConfigService {
  abstract get(key: string): string;
}

// 开发环境实现
@Injectable()
export class DevelopmentConfigService extends ConfigService {
  get(key: string): string {
    return `开发环境_${key}_的值`;
  }
}

// 生产环境实现
@Injectable()
export class ProductionConfigService extends ConfigService {
  get(key: string): string {
    return `生产环境_${key}_的值`;
  }
}

// 模块配置
const configServiceProvider = {
  provide: ConfigService,
  useClass: process.env.NODE_ENV === 'development' 
    ? DevelopmentConfigService 
    : ProductionConfigService,
};

@Module({
  providers: [configServiceProvider],
  exports: [ConfigService],
})
export class AppModule {}
```

这样，当有地方请求 `ConfigService` 这个令牌时，Nest 就会根据当前 `NODE_ENV` 环境变量的值，提供 `DevelopmentConfigService` 或 `ProductionConfigService` 的实例。



## 为什么需要自定义提供者？
虽然类提供者能应付大多数情况，但总有一些特殊需求：

+ **注入常量或配置值**：API 密钥、配置对象等
+ **条件化提供**：根据复杂逻辑选择不同实现
+ **使用现成的实例**：第三方库的实例、手动创建的对象
+ **复杂的初始化逻辑**：需要异步操作或依赖多个服务
+ **模拟 (Mocking)**：用假对象替换真实服务

这时候，Nest 的四种自定义提供者就派上用场了，包括前面已经讨论过的 `useClass`。



## `useValue`：提供一个具体的值
`useValue` 最简单直接，适合注入常量、配置对象或已创建的实例：

```typescript
@Module({
  providers: [
    {
      provide: 'PERSON_INFO',
      useValue: {
        name: '张三',
        age: 25,
        hobbies: ['编程', '阅读']
      }
    },
    {
      provide: 'API_KEY',
      useValue: 'sk-1234567890abcdef'
    }
  ],
})
export class AppModule {}
```

在控制器中使用：

```typescript
interface Person {
  name: string;
  age: number;
  hobbies: string[];
}

@Controller()
export class AppController {
  constructor(
    @Inject('PERSON_INFO') private readonly person: Person,
    @Inject('API_KEY') private readonly apiKey: string
  ) {}

  @Get('person')
  getPersonInfo() {
    return `姓名：${this.person.name}，年龄：${this.person.age}`;
  }
}
```

`useValue` 在测试中特别有用，可以轻松替换真实服务为模拟对象：

```typescript
const mockCatsService = {
  findAll: () => ['模拟猫咪1', '模拟猫咪2'],
  create: (cat) => ({ id: Date.now(), ...cat }),
};

@Module({
  providers: [
    {
      provide: CatsService,
      useValue: mockCatsService,  // 用模拟对象替换真实服务
    },
  ],
})
export class TestModule {}
```

现在，任何依赖注入 `CatsService` 的地方 (比如 `CatsController`)，得到的都会是 `mockCatsService` 这个对象，而不是 Nest 去实例化的 `CatsService` 类。

上面我们用 `'PERSON_INFO'` 和 `'API_KEY'` 作为令牌，它们是字符串。

为了代码更清晰和避免魔法字符串，推荐把这些令牌统一定义在常量文件里：

```typescript
// constants.ts (推荐把令牌统一定义起来)
export const CONFIG_OPTIONS = 'CONFIG_OPTIONS';
export const DATABASE_CONNECTION = Symbol('DATABASE_CONNECTION'); // Symbol 保证唯一性
```

然后在模块里使用这些常量：

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { CONFIG_OPTIONS, DATABASE_CONNECTION } from './constants';

@Module({
  providers: [
    {
      provide: CONFIG_OPTIONS, // 使用导入的字符串常量作为令牌
      useValue: { apiKey: '12345', timeout: 5000 }, // 提供一个配置对象
    },
    {
      provide: DATABASE_CONNECTION, // 使用导入的 Symbol 作为令牌
      useValue: { query: (sql) => `执行了 SQL: ${sql}` }, // 假设这是个模拟的数据库连接实例
    },
  ],
  // 如果其他模块需要用这些提供者，记得导出它们的令牌
  exports: [CONFIG_OPTIONS, DATABASE_CONNECTION],
})
export class AppModule {}
```

注入时，同样需要 `@Inject()` 装饰器：

```typescript
import { Injectable, Inject } from '@nestjs/common';
import { CONFIG_OPTIONS, DATABASE_CONNECTION } from './constants';

@Injectable()
export class SomeService {
  constructor(
    @Inject(CONFIG_OPTIONS) private configOptions: { apiKey: string; timeout: number },
    @Inject(DATABASE_CONNECTION) private dbConnection: { query: (sql: string) => string },
  ) {
    console.log('API Key:', this.configOptions.apiKey);
    console.log(this.dbConnection.query('SELECT * FROM users'));
  }
}
```

指定值，让 IOC 容器来注入：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349744520-15f92451-1319-4b95-8771-5a3cae49fd9d.png)



## `useFactory`：强大的工厂提供者
useFactory 是最灵活强大的提供者类型。它允许你通过工厂函数动态创建提供者的值，这个工厂函数的返回值就是最终被注入的实例。

工厂函数本身支持依赖注入。如果需要依赖其他服务，你需要：

1. **声明依赖**：在 `inject` 数组中列出工厂函数依赖的提供者令牌
2. **参数对应**：工厂函数的参数顺序要与 `inject` 数组中的依赖项一一对应

Nest 会先解析依赖项，然后按顺序传递给工厂函数。

假设我们要创建一个数据库连接服务，需要读取配置选项并支持可选依赖：

```typescript
// options.provider.ts
import { Injectable } from '@nestjs/common';

export interface DatabaseOptions {
  host: string;
  port: number;
  user: string;
}

@Injectable()
export class OptionsProvider {
  getDatabaseOptions(): DatabaseOptions {
    // 实际项目中可能从配置文件、环境变量等读取
    return { 
      host: 'localhost', 
      port: 5432, 
      user: 'admin' 
    };
  }
}
```

再来个模拟的 `DatabaseConnection` 类：

```typescript
// database.connection.ts
import { DatabaseOptions } from './options.provider';

export class DatabaseConnection {
  constructor(private options: DatabaseOptions) {
    console.log(`数据库连接已创建，配置:`, options);
    // 实际的数据库连接逻辑...
  }

  query(sql: string): string {
    return `执行查询: ${sql}`;
  }
}
```

现在，在模块里使用 `useFactory` 来创建 `DatabaseConnection`：

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { OptionsProvider } from './options.provider';
import { DatabaseConnection } from './database.connection';
import { AppController } from './app.controller';

// 定义令牌常量
export const DATABASE_CONNECTION_TOKEN = Symbol('DATABASE_CONNECTION');
export const OPTIONAL_SERVICE_TOKEN = Symbol('OPTIONAL_SERVICE');

@Module({
  controllers: [AppController],
  providers: [
    // 基础提供者
    OptionsProvider,
    
    // 工厂提供者
    {
      provide: DATABASE_CONNECTION_TOKEN,
      useFactory: (
        optionsProvider: OptionsProvider, 
        optionalService?: string
      ) => {
        console.log('可选依赖值:', optionalService || '未提供');
        
        const dbOptions = optionsProvider.getDatabaseOptions();
        // 可以在这里执行复杂的初始化逻辑
        return new DatabaseConnection(dbOptions);
      },
      inject: [
        OptionsProvider, // 必需依赖
        { 
          token: OPTIONAL_SERVICE_TOKEN, 
          optional: true // 可选依赖
        }
      ],
    },
    
    // 取消注释以提供可选依赖
    // { 
    //   provide: OPTIONAL_SERVICE_TOKEN, 
    //   useValue: '可选服务的值' 
    // },
  ],
  exports: [DATABASE_CONNECTION_TOKEN],
})
export class AppModule {}
```

这里有几个关键点：

+ **令牌定义**：`provide` 指定最终产物的注入令牌
+ **工厂函数**：`useFactory` 接收依赖项并返回要注入的值
+ **依赖声明**：`inject` 数组按顺序声明工厂函数需要的依赖
+ **可选依赖**：使用 `{ token: TOKEN, optional: true }` 声明可选依赖，找不到时传入 `undefined`
+ **错误处理**：必需依赖找不到时，Nest 启动会报错

工厂函数甚至可以是异步的 (返回一个 `Promise`)，Nest 会等待 `Promise` 解析完成后再使用其结果：

```typescript
{
  provide: 'ASYNC_CONNECTION',
  useFactory: async (configService: ConfigService) => {
    const config = await configService.getAsyncConfig();
    return new AsyncConnection(config);
  },
  inject: [ConfigService],
}
```

useFactory 来动态创建对象：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349681633-f841e3e3-b9c8-46ae-a9c8-ba089326ab32.png)

useFactory 参数注入：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349622933-ab11ac1d-ed33-4ef9-8bcd-28abe1a6729a.png)

useFactory 异步：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349616292-969a101e-643f-4cfd-81ad-b67e7e6d4a58.png)



## `useExisting`：给提供者起个别名
`useExisting` 为已存在的提供者创建别名，让多个令牌指向同一个实例：

```typescript
@Injectable()
export class LoggerService {
  private prefix = 'LOG';
  
  log(message: string) {
    console.log(`[${this.prefix}]: ${message}`);
  }
  
  setPrefix(prefix: string) {
    this.prefix = prefix;
  }
}

@Module({
  providers: [
    LoggerService,
    {
      provide: 'AliasedLogger',
      useExisting: LoggerService,  // 指向已存在的 LoggerService
    },
  ],
  exports: [LoggerService, 'AliasedLogger'],
})
export class LoggerModule {}
```

现在，在其他地方注入时：

```typescript
constructor(
  private logger1: LoggerService,
  @Inject('AliasedLogger') private logger2: LoggerService
) {
  console.log(this.logger1 === this.logger2); // true
  
  this.logger1.setPrefix('APP');
  this.logger2.log('测试消息'); // [APP]: 测试消息
}
```

你会发现 `logger1` 和 `logger2` 指向的是**同一个** `LoggerService` 实例（假设 `LoggerService` 是默认的单例作用域）。修改其中一个引用的状态会影响到另一个。

用一个新的令牌来引用一个旧的或已存在的服务时，这在比如为了兼容旧代码或者提供一个更通用的接口很好用。

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349578308-abf0cebf-492b-4910-bc28-8f0333c305c0.png)

上面给 asyncPerson 的 provider 起个新的 token，叫做 newPerson。



## 导出自定义提供者
与普通的类提供者一样，如果你想在当前模块之外的其他模块中使用某个自定义提供者，就必须从定义它的模块中将其导出（export）。

导出令牌：

```typescript
// core.module.ts
import { Module } from '@nestjs/common';
import { OptionsProvider } from './options.provider';

// 使用 Symbol 创建唯一令牌，避免字符串冲突
export const DATABASE_CONNECTION_TOKEN = Symbol('DATABASE_CONNECTION');

// 模拟数据库连接创建函数
function createDatabaseConnection(options: any) {
  return {
    query: (sql: string) => Promise.resolve([]),
    close: () => Promise.resolve(),
  };
}

const databaseConnectionFactory = {
  provide: DATABASE_CONNECTION_TOKEN,
  useFactory: (optionsProvider: OptionsProvider) => {
    // 创建数据库连接的逻辑
    const options = optionsProvider.getOptions();
    return createDatabaseConnection(options);
  },
  inject: [OptionsProvider],
};

@Module({
  providers: [databaseConnectionFactory, OptionsProvider],
  exports: [DATABASE_CONNECTION_TOKEN], // 只导出令牌，也可以直接写 databaseConnectionFactory，不过没有必要
})
export class CoreModule {}
```

当其他模块导入 `CoreModule` 后，就可以注入并使用这个自定义提供者：

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { CoreModule } from './core/core.module';
import { SomeService } from './some.service';

@Module({
  imports: [CoreModule],
  providers: [SomeService],
})
export class AppModule {}
```

```typescript
// some.service.ts
import { Injectable, Inject } from '@nestjs/common';
import { DATABASE_CONNECTION_TOKEN } from './core/core.module';

// 定义数据库连接接口以提供更好的类型安全
interface DatabaseConnection {
  query(sql: string): Promise<any[]>;
  close(): Promise<void>;
}

@Injectable()
export class SomeService {
  constructor(
    @Inject(DATABASE_CONNECTION_TOKEN) 
    private readonly dbConnection: DatabaseConnection
  ) {}
  
  // 使用数据库连接
  async getData(): Promise<any[]> {
    try {
      return await this.dbConnection.query('SELECT * FROM users');
    } catch (error) {
      console.error('查询数据失败:', error);
      throw error;
    }
  }
  
  async cleanup(): Promise<void> {
    await this.dbConnection.close();
  }
}
```

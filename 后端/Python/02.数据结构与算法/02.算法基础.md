# Python 算法基础

## 最佳提示词

```
请详细介绍 Python 算法基础，包括以下内容：

1. 算法概念与分析：
   - 算法的定义与特性
   - 时间复杂度分析
   - 空间复杂度分析
   - 大 O 表示法
   - 最优、最坏、平均情况分析
   - 算法效率的衡量标准

2. 递归算法：
   - 递归的概念与原理
   - 递归的三要素
   - 递归与迭代的转换
   - 尾递归优化
   - 递归的栈溢出问题
   - 经典递归问题（阶乘、斐波那契、汉诺塔等）

3. 分治算法：
   - 分治策略的思想
   - 分治算法的步骤
   - 经典分治算法（归并排序、快速排序）
   - 分治算法的复杂度分析
   - 分治算法的适用场景

4. 贪心算法：
   - 贪心策略的思想
   - 贪心算法的特点
   - 贪心算法的正确性证明
   - 经典贪心问题（背包问题、活动选择等）
   - 贪心算法的局限性

5. 动态规划基础：
   - 动态规划的思想
   - 最优子结构与重叠子问题
   - 动态规划与递归的关系
   - 记忆化搜索
   - 动态规划的基本步骤

6. 算法设计技巧：
   - 暴力枚举法
   - 回溯算法
   - 位运算技巧
   - 数学方法在算法中的应用
   - 算法的优化技巧

请为每种算法提供详细的 Python 实现，包括实际应用场景和复杂度分析。解释算法的设计思路和优化方法。
```

## 学习要点

- 理解算法的基本概念和特性
- 掌握时间复杂度和空间复杂度的分析方法
- 学会使用大 O 表示法描述算法效率
- 掌握递归算法的设计和实现
- 理解分治算法的思想和应用
- 学会贪心算法的设计和分析
- 了解动态规划的基本原理
- 掌握常用的算法设计技巧
- 学会分析算法的适用场景和局限性
- 能够根据问题特点选择合适的算法策略

## 实践练习

1. 实现基本的递归算法（阶乘、斐波那契）
2. 分析不同算法的时间复杂度
3. 实现归并排序和快速排序
4. 解决经典的贪心算法问题
5. 使用动态规划解决简单问题
6. 实现回溯算法解决组合问题
7. 使用位运算优化算法
8. 比较不同算法解决同一问题的效率

## 代码示例模板

```python
# 递归算法示例
def recursive_algorithms():
    """演示递归算法"""
    
    # 阶乘递归实现
    def factorial(n):
        """递归计算阶乘"""
        if n <= 1:
            return 1
        return n * factorial(n - 1)
    
    # 斐波那契数列递归实现
    def fibonacci(n):
        """递归计算斐波那契数列"""
        if n <= 1:
            return n
        return fibonacci(n - 1) + fibonacci(n - 2)
    
    # 记忆化递归优化
    def fibonacci_memo(n, memo={}):
        """记忆化递归计算斐波那契数列"""
        if n in memo:
            return memo[n]
        if n <= 1:
            return n
        
        memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
        return memo[n]
    
    # 汉诺塔问题
    def hanoi(n, source, target, auxiliary):
        """汉诺塔递归解法"""
        if n == 1:
            print(f"将盘子从 {source} 移动到 {target}")
            return
        
        hanoi(n - 1, source, auxiliary, target)
        print(f"将盘子从 {source} 移动到 {target}")
        hanoi(n - 1, auxiliary, target, source)

# 分治算法示例
def divide_and_conquer():
    """演示分治算法"""
    
    # 归并排序
    def merge_sort(arr):
        """归并排序实现"""
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = merge_sort(arr[:mid])
        right = merge_sort(arr[mid:])
        
        return merge(left, right)
    
    def merge(left, right):
        """合并两个有序数组"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    # 快速排序
    def quick_sort(arr):
        """快速排序实现"""
        if len(arr) <= 1:
            return arr
        
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        
        return quick_sort(left) + middle + quick_sort(right)
    
    # 最大子数组和问题
    def max_subarray(arr):
        """分治法求最大子数组和"""
        def max_crossing_sum(arr, left, mid, right):
            # 计算跨越中点的最大子数组和
            left_sum = float('-inf')
            current_sum = 0
            for i in range(mid, left - 1, -1):
                current_sum += arr[i]
                left_sum = max(left_sum, current_sum)
            
            right_sum = float('-inf')
            current_sum = 0
            for i in range(mid + 1, right + 1):
                current_sum += arr[i]
                right_sum = max(right_sum, current_sum)
            
            return left_sum + right_sum
        
        def max_subarray_recursive(arr, left, right):
            if left == right:
                return arr[left]
            
            mid = (left + right) // 2
            
            left_max = max_subarray_recursive(arr, left, mid)
            right_max = max_subarray_recursive(arr, mid + 1, right)
            cross_max = max_crossing_sum(arr, left, mid, right)
            
            return max(left_max, right_max, cross_max)
        
        return max_subarray_recursive(arr, 0, len(arr) - 1)

# 贪心算法示例
def greedy_algorithms():
    """演示贪心算法"""
    
    # 活动选择问题
    def activity_selection(start, finish):
        """活动选择贪心算法"""
        n = len(start)
        activities = list(zip(start, finish))
        activities.sort(key=lambda x: x[1])  # 按结束时间排序
        
        selected = []
        last_finish = -1
        
        for i in range(n):
            if activities[i][0] >= last_finish:
                selected.append(activities[i])
                last_finish = activities[i][1]
        
        return selected
    
    # 背包问题（分数背包）
    def fractional_knapsack(weights, values, capacity):
        """分数背包问题贪心解法"""
        n = len(weights)
        items = list(zip(weights, values))
        items.sort(key=lambda x: x[1] / x[0], reverse=True)  # 按价值密度排序
        
        total_value = 0
        remaining_capacity = capacity
        
        for weight, value in items:
            if remaining_capacity >= weight:
                total_value += value
                remaining_capacity -= weight
            else:
                fraction = remaining_capacity / weight
                total_value += value * fraction
                break
        
        return total_value
    
    # 哈夫曼编码
    import heapq
    
    def huffman_encoding(char_freq):
        """哈夫曼编码贪心算法"""
        heap = [[freq, [char, ""]] for char, freq in char_freq.items()]
        heapq.heapify(heap)
        
        while len(heap) > 1:
            low1 = heapq.heappop(heap)
            low2 = heapq.heappop(heap)
            
            for pair in low1[1:]:
                pair[1] = '0' + pair[1]
            for pair in low2[1:]:
                pair[1] = '1' + pair[1]
            
            heapq.heappush(heap, [low1[0] + low2[0]] + low1[1:] + low2[1:])
        
        return heap[0][1:]

# 动态规划基础示例
def dynamic_programming():
    """演示动态规划基础"""
    
    # 斐波那契数列动态规划
    def fibonacci_dp(n):
        """动态规划计算斐波那契数列"""
        if n <= 1:
            return n
        
        dp = [0] * (n + 1)
        dp[0], dp[1] = 0, 1
        
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]
    
    # 最长递增子序列
    def longest_increasing_subsequence(arr):
        """最长递增子序列动态规划解法"""
        n = len(arr)
        dp = [1] * n
        
        for i in range(1, n):
            for j in range(i):
                if arr[i] > arr[j] and dp[i] < dp[j] + 1:
                    dp[i] = dp[j] + 1
        
        return max(dp) if dp else 0
    
    # 0-1 背包问题
    def knapsack_01(weights, values, capacity):
        """0-1 背包问题动态规划解法"""
        n = len(weights)
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for w in range(1, capacity + 1):
                if weights[i - 1] <= w:
                    dp[i][w] = max(
                        values[i - 1] + dp[i - 1][w - weights[i - 1]],
                        dp[i - 1][w]
                    )
                else:
                    dp[i][w] = dp[i - 1][w]
        
        return dp[n][capacity]

# 回溯算法示例
def backtracking():
    """演示回溯算法"""
    
    # 全排列问题
    def permutations(nums):
        """生成所有排列"""
        result = []
        
        def backtrack(path, used):
            if len(path) == len(nums):
                result.append(path[:])
                return
            
            for i in range(len(nums)):
                if used[i]:
                    continue
                
                used[i] = True
                path.append(nums[i])
                backtrack(path, used)
                path.pop()
                used[i] = False
        
        backtrack([], [False] * len(nums))
        return result
    
    # N 皇后问题
    def solve_n_queens(n):
        """N 皇后问题回溯解法"""
        solutions = []
        
        def backtrack(row, cols, diag1, diag2, board):
            if row == n:
                solutions.append(board[:])
                return
            
            for col in range(n):
                d1 = row - col
                d2 = row + col
                
                if col in cols or d1 in diag1 or d2 in diag2:
                    continue
                
                cols.add(col)
                diag1.add(d1)
                diag2.add(d2)
                board.append('.' * col + 'Q' + '.' * (n - col - 1))
                
                backtrack(row + 1, cols, diag1, diag2, board)
                
                cols.remove(col)
                diag1.remove(d1)
                diag2.remove(d2)
                board.pop()
        
        backtrack(0, set(), set(), set(), [])
        return solutions

# 位运算技巧
def bit_manipulation():
    """演示位运算技巧"""
    
    # 判断奇偶数
    def is_odd(n):
        return n & 1
    
    # 交换两个数
    def swap(a, b):
        a = a ^ b
        b = a ^ b
        a = a ^ b
        return a, b
    
    # 计算二进制中 1 的个数
    def count_bits(n):
        count = 0
        while n:
            n &= n - 1  # 清除最低位的 1
            count += 1
        return count
    
    # 判断是否为 2 的幂
    def is_power_of_two(n):
        return n > 0 and (n & (n - 1)) == 0
    
    # 找出只出现一次的数字
    def find_single_number(nums):
        result = 0
        for num in nums:
            result ^= num
        return result

# 算法复杂度分析示例
def complexity_analysis():
    """演示算法复杂度分析"""
    import time
    import random
    
    # 不同复杂度的算法
    def linear_algorithm(n):
        """O(n) 算法"""
        total = 0
        for i in range(n):
            total += i
        return total
    
    def quadratic_algorithm(n):
        """O(n^2) 算法"""
        total = 0
        for i in range(n):
            for j in range(n):
                total += i * j
        return total
    
    def logarithmic_algorithm(n):
        """O(log n) 算法"""
        count = 0
        while n > 1:
            n //= 2
            count += 1
        return count
    
    # 性能测试
    def test_performance():
        sizes = [1000, 2000, 4000, 8000]
        
        for size in sizes:
            # 测试线性算法
            start = time.time()
            linear_algorithm(size)
            linear_time = time.time() - start
            
            # 测试对数算法
            start = time.time()
            logarithmic_algorithm(size)
            log_time = time.time() - start
            
            print(f"大小 {size}: 线性算法 {linear_time:.6f}s, 对数算法 {log_time:.6f}s")
```

## 扩展资源

- [算法导论](https://en.wikipedia.org/wiki/Introduction_to_Algorithms)
- [Python 算法教程](https://docs.python.org/3/tutorial/)
- [LeetCode](https://leetcode.com/)
- [HackerRank](https://www.hackerrank.com/)
- [算法可视化](https://visualgo.net/en)
# Python 排序与搜索算法

## 最佳提示词

```
请详细介绍 Python 的排序与搜索算法，包括以下内容：

1. 基础排序算法：
   - 冒泡排序：原理、实现、优化、复杂度分析
   - 选择排序：原理、实现、稳定性分析
   - 插入排序：原理、实现、适用场景
   - 希尔排序：原理、实现、增量选择

2. 高级排序算法：
   - 归并排序：分治思想、递归实现、迭代实现
   - 快速排序：分区策略、随机化、三路快排
   - 堆排序：堆的构建、排序过程、应用场景
   - 计数排序：适用条件、实现方法、优化技巧
   - 桶排序：原理、实现、桶的设计
   - 基数排序：LSD 和 MSD 方法、稳定性

3. 特殊排序技术：
   - 外部排序：多路归并、置换选择
   - 拓扑排序：有向无环图、应用场景
   - 部分排序：第 K 大元素、中位数查找

4. 搜索算法：
   - 线性搜索：顺序查找、优化技巧
   - 二分搜索：递归实现、迭代实现、边界处理
   - 插值搜索：原理、适用条件、性能分析
   - 斐波那契搜索：黄金分割、实现方法
   - 跳表搜索：数据结构、搜索过程

5. Python 内置排序：
   - sort() 方法：Timsort 算法、参数详解
   - sorted() 函数：使用方法、key 函数
   - 排序稳定性：保证机制、应用场景

6. 算法比较与选择：
   - 时间复杂度对比
   - 空间复杂度对比
   - 稳定性比较
   - 实际性能测试
   - 不同场景下的选择策略

请为每种算法提供详细的 Python 实现，包括实际应用场景和性能分析。解释算法的设计思路和优化方法。
```

## 学习要点

- 掌握各种基础排序算法的原理和实现
- 理解高级排序算法的分治思想和优化技巧
- 学会根据数据特点选择合适的排序算法
- 掌握不同搜索算法的适用场景和实现方法
- 理解二分搜索的边界处理技巧
- 了解 Python 内置排序的实现原理
- 学会使用 key 函数进行自定义排序
- 掌握算法性能分析和比较方法
- 了解特殊排序技术的应用场景
- 能够根据实际需求选择最优的排序和搜索策略

## 实践练习

1. 实现所有基础排序算法并比较性能
2. 实现高级排序算法并分析复杂度
3. 练习二分搜索的各种实现和边界处理
4. 使用 Python 内置排序解决实际问题
5. 实现自定义 key 函数进行复杂排序
6. 测试不同算法在不同数据分布下的性能
7. 实现外部排序处理大数据
8. 解决需要排序和搜索结合的实际问题

## 代码示例模板

```python
# 基础排序算法
def basic_sorting_algorithms():
    """演示基础排序算法"""
    
    # 冒泡排序
    def bubble_sort(arr):
        """冒泡排序实现"""
        n = len(arr)
        for i in range(n):
            swapped = False
            for j in range(0, n - i - 1):
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
                    swapped = True
            if not swapped:
                break
        return arr
    
    # 优化版冒泡排序
    def optimized_bubble_sort(arr):
        """优化版冒泡排序"""
        n = len(arr)
        last_swap = n - 1
        for i in range(n):
            swapped = False
            current_swap = 0
            for j in range(last_swap):
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
                    swapped = True
                    current_swap = j
            last_swap = current_swap
            if not swapped:
                break
        return arr
    
    # 选择排序
    def selection_sort(arr):
        """选择排序实现"""
        n = len(arr)
        for i in range(n):
            min_idx = i
            for j in range(i + 1, n):
                if arr[j] < arr[min_idx]:
                    min_idx = j
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
        return arr
    
    # 插入排序
    def insertion_sort(arr):
        """插入排序实现"""
        for i in range(1, len(arr)):
            key = arr[i]
            j = i - 1
            while j >= 0 and arr[j] > key:
                arr[j + 1] = arr[j]
                j -= 1
            arr[j + 1] = key
        return arr
    
    # 希尔排序
    def shell_sort(arr):
        """希尔排序实现"""
        n = len(arr)
        gap = n // 2
        
        while gap > 0:
            for i in range(gap, n):
                temp = arr[i]
                j = i
                while j >= gap and arr[j - gap] > temp:
                    arr[j] = arr[j - gap]
                    j -= gap
                arr[j] = temp
            gap //= 2
        return arr

# 高级排序算法
def advanced_sorting_algorithms():
    """演示高级排序算法"""
    
    # 归并排序
    def merge_sort(arr):
        """归并排序实现"""
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = merge_sort(arr[:mid])
        right = merge_sort(arr[mid:])
        
        return merge(left, right)
    
    def merge(left, right):
        """合并两个有序数组"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    # 快速排序
    def quick_sort(arr):
        """快速排序实现"""
        if len(arr) <= 1:
            return arr
        
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        
        return quick_sort(left) + middle + quick_sort(right)
    
    # 原地快速排序
    def quick_sort_inplace(arr, low=0, high=None):
        """原地快速排序"""
        if high is None:
            high = len(arr) - 1
        
        if low < high:
            pi = partition(arr, low, high)
            quick_sort_inplace(arr, low, pi - 1)
            quick_sort_inplace(arr, pi + 1, high)
        
        return arr
    
    def partition(arr, low, high):
        """分区函数"""
        pivot = arr[high]
        i = low - 1
        
        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1
    
    # 堆排序
    def heap_sort(arr):
        """堆排序实现"""
        n = len(arr)
        
        # 构建最大堆
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # 逐个提取元素
        for i in range(n - 1, 0, -1):
            arr[0], arr[i] = arr[i], arr[0]
            heapify(arr, i, 0)
        
        return arr
    
    def heapify(arr, n, i):
        """堆化函数"""
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

# 特殊排序算法
def special_sorting_algorithms():
    """演示特殊排序算法"""
    
    # 计数排序
    def counting_sort(arr):
        """计数排序实现"""
        if not arr:
            return []
        
        max_val = max(arr)
        min_val = min(arr)
        range_val = max_val - min_val + 1
        
        count = [0] * range_val
        output = [0] * len(arr)
        
        # 计数
        for num in arr:
            count[num - min_val] += 1
        
        # 累积计数
        for i in range(1, len(count)):
            count[i] += count[i - 1]
        
        # 构建输出数组
        for num in reversed(arr):
            count[num - min_val] -= 1
            output[count[num - min_val]] = num
        
        return output
    
    # 桶排序
    def bucket_sort(arr, bucket_size=5):
        """桶排序实现"""
        if len(arr) == 0:
            return arr
        
        min_val = min(arr)
        max_val = max(arr)
        
        # 计算桶的数量
        bucket_count = (max_val - min_val) // bucket_size + 1
        buckets = [[] for _ in range(bucket_count)]
        
        # 分配元素到桶
        for num in arr:
            bucket_idx = (num - min_val) // bucket_size
            buckets[bucket_idx].append(num)
        
        # 对每个桶进行排序
        sorted_arr = []
        for bucket in buckets:
            if bucket:
                sorted_arr.extend(sorted(bucket))
        
        return sorted_arr
    
    # 基数排序
    def radix_sort(arr):
        """基数排序实现（LSD）"""
        if not arr:
            return []
        
        max_val = max(arr)
        exp = 1
        
        while max_val // exp > 0:
            counting_sort_by_digit(arr, exp)
            exp *= 10
        
        return arr
    
    def counting_sort_by_digit(arr, exp):
        """按位数进行计数排序"""
        n = len(arr)
        output = [0] * n
        count = [0] * 10
        
        # 计数当前位数
        for num in arr:
            index = (num // exp) % 10
            count[index] += 1
        
        # 累积计数
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        # 构建输出数组
        for i in range(n - 1, -1, -1):
            index = (arr[i] // exp) % 10
            output[count[index] - 1] = arr[i]
            count[index] -= 1
        
        # 复制回原数组
        for i in range(n):
            arr[i] = output[i]

# 搜索算法
def searching_algorithms():
    """演示搜索算法"""
    
    # 线性搜索
    def linear_search(arr, target):
        """线性搜索实现"""
        for i, value in enumerate(arr):
            if value == target:
                return i
        return -1
    
    # 二分搜索（递归）
    def binary_search_recursive(arr, target, left=0, right=None):
        """递归二分搜索"""
        if right is None:
            right = len(arr) - 1
        
        if left > right:
            return -1
        
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            return binary_search_recursive(arr, target, mid + 1, right)
        else:
            return binary_search_recursive(arr, target, left, mid - 1)
    
    # 二分搜索（迭代）
    def binary_search_iterative(arr, target):
        """迭代二分搜索"""
        left, right = 0, len(arr) - 1
        
        while left <= right:
            mid = (left + right) // 2
            
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1
    
    # 插值搜索
    def interpolation_search(arr, target):
        """插值搜索实现"""
        left, right = 0, len(arr) - 1
        
        while left <= right and target >= arr[left] and target <= arr[right]:
            if left == right:
                return left if arr[left] == target else -1
            
            # 估算位置
            pos = left + ((target - arr[left]) * (right - left)) // (arr[right] - arr[left])
            
            if arr[pos] == target:
                return pos
            elif arr[pos] < target:
                left = pos + 1
            else:
                right = pos - 1
        
        return -1
    
    # 斐波那契搜索
    def fibonacci_search(arr, target):
        """斐波那契搜索实现"""
        n = len(arr)
        
        # 初始化斐波那契数
        fib_m2 = 0  # (m-2)th Fibonacci
        fib_m1 = 1  # (m-1)th Fibonacci
        fib_m = fib_m2 + fib_m1  # mth Fibonacci
        
        # 找到大于等于 n 的最小斐波那契数
        while fib_m < n:
            fib_m2 = fib_m1
            fib_m1 = fib_m
            fib_m = fib_m2 + fib_m1
        
        # 标记数组范围
        offset = -1
        
        while fib_m > 1:
            i = min(offset + fib_m2, n - 1)
            
            if arr[i] < target:
                fib_m = fib_m1
                fib_m1 = fib_m2
                fib_m2 = fib_m - fib_m1
                offset = i
            elif arr[i] > target:
                fib_m = fib_m2
                fib_m1 = fib_m1 - fib_m2
                fib_m2 = fib_m - fib_m1
            else:
                return i
        
        if fib_m1 and offset + 1 < n and arr[offset + 1] == target:
            return offset + 1
        
        return -1

# Python 内置排序
def python_builtin_sorting():
    """演示 Python 内置排序功能"""
    
    # sort() 方法
    def sort_method_example():
        """sort() 方法示例"""
        numbers = [3, 1, 4, 1, 5, 9, 2, 6]
        numbers.sort()  # 原地排序
        print("升序排序:", numbers)
        
        numbers.sort(reverse=True)  # 降序排序
        print("降序排序:", numbers)
        
        # 使用 key 函数
        words = ["apple", "banana", "cherry", "date"]
        words.sort(key=len)  # 按长度排序
        print("按长度排序:", words)
        
        # 复杂对象排序
        people = [
            {"name": "Alice", "age": 25},
            {"name": "Bob", "age": 30},
            {"name": "Charlie", "age": 20}
        ]
        people.sort(key=lambda x: x["age"])  # 按年龄排序
        print("按年龄排序:", people)
    
    # sorted() 函数
    def sorted_function_example():
        """sorted() 函数示例"""
        numbers = [3, 1, 4, 1, 5, 9, 2, 6]
        sorted_numbers = sorted(numbers)  # 返回新列表
        print("原数组:", numbers)
        print("排序后:", sorted_numbers)
        
        # 多级排序
        students = [
            {"name": "Alice", "grade": 85, "age": 20},
            {"name": "Bob", "grade": 90, "age": 22},
            {"name": "Charlie", "grade": 85, "age": 21}
        ]
        
        # 先按成绩排序，成绩相同按年龄排序
        sorted_students = sorted(students, key=lambda x: (x["grade"], x["age"]))
        print("多级排序:", sorted_students)
    
    # 排序稳定性
    def sorting_stability():
        """演示排序稳定性"""
        data = [(1, "a"), (2, "b"), (1, "c"), (2, "d")]
        
        # 按第一个元素排序，保持相同元素的相对顺序
        sorted_data = sorted(data, key=lambda x: x[0])
        print("稳定排序:", sorted_data)

# 性能比较
def performance_comparison():
    """比较不同排序算法的性能"""
    import time
    import random
    
    def generate_test_data(size):
        """生成测试数据"""
        return [random.randint(1, 1000) for _ in range(size)]
    
    def test_sorting_algorithm(algorithm, data, name):
        """测试排序算法性能"""
        test_data = data.copy()
        start_time = time.time()
        algorithm(test_data)
        end_time = time.time()
        print(f"{name}: {end_time - start_time:.6f} 秒")
    
    # 测试不同大小的数据
    sizes = [1000, 5000, 10000]
    
    for size in sizes:
        print(f"\n测试数据大小: {size}")
        test_data = generate_test_data(size)
        
        # 测试不同算法
        test_sorting_algorithm(sorted, test_data.copy(), "Python sorted()")
        test_sorting_algorithm(lambda x: x.sort(), test_data.copy(), "Python sort()")
        
        # 对于小数据量，测试基础算法
        if size <= 5000:
            test_sorting_algorithm(bubble_sort, test_data.copy(), "冒泡排序")
            test_sorting_algorithm(insertion_sort, test_data.copy(), "插入排序")
            test_sorting_algorithm(selection_sort, test_data.copy(), "选择排序")

# 实际应用示例
def real_world_applications():
    """排序与搜索的实际应用"""
    
    # 学生成绩排序
    def sort_student_grades():
        """学生成绩排序应用"""
        students = [
            {"name": "张三", "math": 90, "english": 85, "total": 175},
            {"name": "李四", "math": 85, "english": 90, "total": 175},
            {"name": "王五", "math": 95, "english": 80, "total": 175},
            {"name": "赵六", "math": 80, "english": 95, "total": 175}
        ]
        
        # 按总分排序，总分相同按数学成绩排序
        sorted_students = sorted(students, 
                                key=lambda x: (-x["total"], -x["math"]))
        
        print("学生排名:")
        for i, student in enumerate(sorted_students, 1):
            print(f"{i}. {student['name']}: 总分 {student['total']}, "
                  f"数学 {student['math']}, 英语 {student['english']}")
    
    # 字典搜索
    def dictionary_search():
        """字典搜索应用"""
        dictionary = ["apple", "banana", "cherry", "date", "elderberry", 
                     "fig", "grape", "honeydew", "kiwi", "lemon"]
        dictionary.sort()  # 确保字典有序
        
        def search_word(word):
            """搜索单词"""
            index = binary_search_iterative(dictionary, word)
            if index != -1:
                return f"找到单词 '{word}' 在位置 {index}"
            else:
                return f"未找到单词 '{word}'"
        
        print(search_word("cherry"))
        print(search_word("orange"))
    
    # 文件排序
    def sort_large_file():
        """大文件排序示例"""
        # 模拟大文件数据
        import tempfile
        import os
        
        # 创建临时文件
        with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:
            for _ in range(10000):
                f.write(f"{random.randint(1, 100000)}\n")
            temp_file = f.name
        
        try:
            # 读取文件并排序
            with open(temp_file, 'r') as f:
                numbers = [int(line.strip()) for line in f]
            
            sorted_numbers = sorted(numbers)
            
            # 写入排序后的文件
            with open(temp_file + '.sorted', 'w') as f:
                for num in sorted_numbers:
                    f.write(f"{num}\n")
            
            print(f"文件排序完成，共处理 {len(numbers)} 个数字")
            
        finally:
            # 清理临时文件
            os.unlink(temp_file)
            if os.path.exists(temp_file + '.sorted'):
                os.unlink(temp_file + '.sorted')
```

## 扩展资源

- [Python 排序算法文档](https://docs.python.org/3/howto/sorting.html)
- [排序算法可视化](https://www.toptal.com/developers/sorting-algorithms)
- [搜索算法详解](https://en.wikipedia.org/wiki/Search_algorithm)
- [Timsort 算法分析](https://en.wikipedia.org/wiki/Timsort)
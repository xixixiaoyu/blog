## 为什么需要异常处理？
在开发 HTTP API 时，异常无处不在。比如，用户请求一个不存在的资源，服务器可能会抛出 404 错误；或者用户权限不足，可能触发 403 错误。如果不处理这些异常，客户端可能会收到一堆难以理解的错误堆栈，甚至导致应用崩溃。Nest.js 的异常处理机制就像一张安全网，专门捕获这些“漏网之鱼”，并将它们转化为结构化的 JSON 响应，确保用户体验和系统稳定性。

---

## Nest.js 的内置异常处理机制
Nest.js 内置了一个全局异常过滤器，专门处理 `HttpException` 及其子类的异常。默认情况下，如果抛出的是 `HttpException`（比如 404 Not Found 或 403 Forbidden），Nest 会返回一个标准的 JSON 响应，格式如下：

```json
{
  "statusCode": 403,
  "message": "Forbidden resource",
  "error": "Forbidden"
}
```

但如果抛出的异常不是 `HttpException` 或其子类（比如一个普通的 JavaScript `Error`），内置过滤器会返回一个通用的 500 错误响应：

```json
{
  "statusCode": 500,
  "message": "Internal server error"
}
```

虽然这能防止应用崩溃，但对于复杂场景来说，这种响应显然不够灵活。接下来，我们将从主动抛出标准 HTTP 异常开始，逐步探索如何自定义异常处理逻辑。

---

## 主动抛出标准 HTTP 异常
在实际开发中，我们经常需要主动告诉客户端发生了什么错误。Nest.js 提供了 `HttpException` 类，专门用来构造标准的 HTTP 异常。以下是一个简单的例子，假设我们在 `CatsController` 中有一个 `findAll` 方法：

```typescript
import { Controller, Get, HttpException, HttpStatus } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Get()
  findAll() {
    throw new HttpException('禁止访问', HttpStatus.FORBIDDEN);
  }
}
```

这里用到了 `HttpStatus`，它是一个枚举，包含了所有标准的 HTTP 状态码，比如 `HttpStatus.NOT_FOUND` (404)、`HttpStatus.BAD_REQUEST` (400) 等。执行这段代码，客户端会收到以下响应：

```json
{
  "statusCode": 403,
  "message": "禁止访问",
  "error": "Forbidden"
}
```

### 自定义响应体
如果想让响应体更丰富，可以在 `HttpException` 中传入一个对象作为 `response` 参数：

```typescript
throw new HttpException(
  {
    statusCode: HttpStatus.FORBIDDEN,
    message: '你没有权限访问这个资源',
    error: 'Permission Denied',
    details: {
      resource: 'cats',
      userId: 123,
    },
  },
  HttpStatus.FORBIDDEN,
  {
    cause: new Error('数据库查询失败'), // 仅用于后端日志
  },
);
```

客户端会收到：

```json
{
  "statusCode": 403,
  "message": "你没有权限访问这个资源",
  "error": "Permission Denied",
  "details": {
    "resource": "cats",
    "userId": 123
  }
}
```

注意，`cause` 字段不会出现在响应中，但对后端调试和日志记录非常有用。

---

## 使用内置的常见 HTTP 异常
Nest.js 提供了许多预定义的异常类，全部继承自 `HttpException`，可以直接使用。这些类涵盖了常见的 HTTP 状态码，比如：

+ `BadRequestException` (400)
+ `UnauthorizedException` (401)
+ `NotFoundException` (404)
+ `ForbiddenException` (403)
+ `InternalServerErrorException` (500)

使用方式非常简单：

```typescript
import { Controller, Get, NotFoundException } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Get(':id')
  findOne() {
    throw new NotFoundException('未找到指定的猫咪');
  }
}
```

响应如下：

```json
{
  "statusCode": 404,
  "message": "未找到指定的猫咪",
  "error": "Not Found"
}
```

如果需要更详细的错误描述，可以传入 `error` 参数：

```typescript
throw new NotFoundException('未找到指定的猫咪', { cause: new Error('数据库中无此记录') });
```

---

## 创建自定义异常类型
为了让代码更有语义化，我们可以创建自定义异常类，继承 `HttpException`：

```typescript
import { HttpException, HttpStatus } from '@nestjs/common';

export class ForbiddenCustomException extends HttpException {
  constructor() {
    super('禁止访问此资源', HttpStatus.FORBIDDEN);
  }
}
```

在控制器中使用：

```typescript
import { Controller, Get } from '@nestjs/common';
import { ForbiddenCustomException } from './forbidden-custom.exception';

@Controller('cats')
export class CatsController {
  @Get()
  findAll() {
    throw new ForbiddenCustomException();
  }
}
```

这种方式让异常更具语义化，且便于维护。Nest 的内置过滤器会自动识别并处理这些继承自 `HttpException` 的异常。

---

## 自定义异常过滤器
内置的异常处理虽然强大，但有时我们需要更精细的控制，比如统一响应格式、记录错误日志，或根据异常类型做不同处理。这时，自定义异常过滤器就派上用场了。

以下是一个只处理 `HttpException` 的自定义过滤器：

```typescript
import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest();
    const status = exception.getStatus();
    const message = exception.message;

    response.status(status).json({
      success: false,
      code: status,
      message: message,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
```

### 应用自定义过滤器
异常过滤器可以应用在不同作用域：

1. **方法作用域**：只对某个方法生效。

```typescript
@Get()
@UseFilters(HttpExceptionFilter)
findAll() {
  throw new HttpException('禁止访问', HttpStatus.FORBIDDEN);
}
```

2. **控制器作用域**：对整个控制器生效。

```typescript
@Controller('cats')
@UseFilters(HttpExceptionFilter)
export class CatsController {
  // ...
}
```

3. **全局作用域**：对整个应用生效。推荐通过模块注册的方式：

```typescript
import { Module } from '@nestjs/common';
import { APP_FILTER } from '@nestjs/core';
import { HttpExceptionFilter } from './http-exception.filter';

@Module({
  providers: [
    {
      provide: APP_FILTER,
      useClass: HttpExceptionFilter,
    },
  ],
})
export class AppModule {}
```

这种方式支持依赖注入，方便在过滤器中注入日志服务或数据库服务。

---

## 捕获所有异常的终极过滤器
如果需要一个能捕获所有异常的过滤器，只需在 `@Catch()` 中不指定参数：

```typescript
import { ExceptionFilter, Catch, ArgumentsHost, HttpStatus } from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

  catch(exception: unknown, host: ArgumentsHost) {
    const { httpAdapter } = this.httpAdapterHost;
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR;
    const message = exception instanceof HttpException ? exception.message : '服务器内部错误';

    httpAdapter.reply(response, {
      success: false,
      code: status,
      message: message,
      timestamp: new Date().toISOString(),
      path: httpAdapter.getRequestUrl(request),
    }, status);
  }
}
```

这个过滤器能处理任何类型的异常，确保应用始终返回统一的响应格式。

---

## 继承默认过滤器
如果想在 Nest 的默认全局过滤器基础上添加功能，可以继承 `BaseExceptionFilter`：

```typescript
import { Catch, ArgumentsHost, Logger } from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';

@Catch()
export class CustomBaseExceptionFilter extends BaseExceptionFilter {
  private readonly logger = new Logger(CustomBaseExceptionFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    this.logger.error(`异常: ${exception instanceof Error ? exception.message : '未知错误'}`);
    super.catch(exception, host); // 调用父类的处理逻辑
  }
}
```

这种方式既保留了默认行为，又能添加自定义逻辑，比如日志记录。

---

## 实际应用场景
### 1. 统一 API 响应格式
为了让所有 API 响应保持一致，我们可以用全局过滤器定义统一的格式：

```typescript
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR;
    const message = exception instanceof HttpException ? exception.message : '服务器内部错误';

    response.status(status).json({
      success: false,
      code: status,
      message: message,
      data: null,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
```

### 2. 错误日志记录
为了便于问题排查，可以在过滤器中添加日志记录：

```typescript
import { ExceptionFilter, Catch, ArgumentsHost, HttpStatus, Logger } from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';

@Catch()
export class LoggingExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(LoggingExceptionFilter.name);

  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

  catch(exception: unknown, host: ArgumentsHost) {
    const { httpAdapter } = this.httpAdapterHost;
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR;
    const message = exception instanceof Error ? exception.message : '未知错误';

    this.logger.error(
      `异常: ${message} | URL: ${request.url} | Method: ${request.method}`,
      exception instanceof Error ? exception.stack : undefined,
    );

    httpAdapter.reply(response, {
      success: false,
      code: status,
      message: message,
      timestamp: new Date().toISOString(),
      path: httpAdapter.getRequestUrl(request),
    }, status);
  }
}
```

---

## 总结
Nest.js 的异常处理机制为开发者提供了从基础到高级的灵活工具。通过主动抛出 `HttpException` 或其子类，我们可以轻松处理常见的 HTTP 错误；通过自定义异常类，可以让代码更具语义化；通过自定义过滤器，我们可以实现统一的响应格式、日志记录等高级功能。

在实际开发中，建议：

1. 优先使用 Nest 提供的内置异常类（如 `NotFoundException`），简单且标准。
2. 对于特定业务场景，创建自定义异常类以提高代码可读性。
3. 使用全局异常过滤器来统一响应格式和记录日志，确保 API 体验一致且便于维护。
4. 结合依赖注入，充分利用 Nest 的模块化特性，让过滤器更强大。


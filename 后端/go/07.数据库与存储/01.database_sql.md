
# AI Prompt: 精通 Go `database/sql` 标准库

## 核心目标

你是一位资深的 Go 语言开发者和数据库专家。请撰写一篇关于 Go 标准库 `database/sql` 的综合性深度指南。本文的目标是让读者不仅学会如何使用这个库，更能深刻理解其设计哲学和最佳实践，从而写出健壮、高效、可维护的数据库代码。

## 内容结构

### 1. 引言：`database/sql` 的设计哲学
- **接口而非实现**：开篇点题，强调 `database/sql` 定义了一套与数据库交互的通用接口，而具体的数据库驱动 (driver) 负责实现这些接口。解释这种设计的优势：代码可移植性、驱动选择的灵活性。
- **连接池的内建支持**：简述 `database/sql` 自动管理数据库连接池，这是其核心特性之一，能显著提升应用性能和稳定性。
- **不提供便利的“特性”**：解释为什么 `database/sql` 刻意不提供 ORM 那样的便利功能（如结构体映射），这体现了 Go 语言“显式优于隐式”的哲学。

### 2. 核心组件剖析
- **`sql.DB`**：
  - **定义**：它不是一个单一的数据库连接，而是一个维护着连接池的数据库句柄。强调它在多 goroutine 中是并发安全的。
  - **生命周期**：解释 `sql.DB` 应该在应用启动时创建一次，并作为全局变量或长生命周期的对象持有，而不是在每个函数中频繁创建和关闭。
  - **配置连接池**：详细讲解 `SetMaxOpenConns`, `SetMaxIdleConns`, `SetConnMaxLifetime`, `SetConnMaxIdleTime` 的作用和配置建议，并解释它们如何影响性能和资源使用。

- **`sql.Conn`**：
  - **定义**：代表一个真实的、单一的数据库连接。解释何时需要从 `sql.DB` 中检出 (`DB.Conn()`) 一个 `sql.Conn` 来执行需要连接状态绑定的操作。
  - **使用场景**：例如，执行数据库的特定设置（如设置 session 变量）或在单个连接上执行一系列命令。
  - **注意事项**：强调使用完毕后必须调用 `Close()` 将连接归还给连接池。

- **`sql.Tx`**：
  - **定义**：代表一个数据库事务。强调事务是保证原子性操作的关键。
  - **生命周期**：通过 `DB.Begin()` 或 `DB.BeginTx()` 开启事务，最终必须调用 `Commit()` 或 `Rollback()`。解释 `defer` 语句在事务中的经典用法，以防止忘记回滚。
  - **`BeginTx` 与 `context`**：解释 `BeginTx` 如何与 `context.Context` 结合，实现带超时的事务。

- **`sql.Rows` 和 `sql.Row`**：
  - **定义**：`sql.Rows` 是查询结果的迭代器，`sql.Row` 是单行查询结果的容器。
  - **`Rows.Next()` 循环**：展示标准的 `for rows.Next() { ... }` 循环模式，并强调循环结束后必须调用 `rows.Close()` 和检查 `rows.Err()`。
  - **`Scan()` 方法**：详细解释如何使用 `Scan()` 将列数据映射到 Go 变量。这是 `database/sql` 的核心操作。
  - **`DB.QueryRow()`**：解释它是一个为单行查询优化的快捷方式，并强调其返回的 `sql.Row` 的 `Scan()` 方法会延迟报告查询错误。

### 3. 关键操作与最佳实践
- **执行查询**
  - **`DB.Query()` vs `DB.Exec()`**：清晰地区分这两者的用途。`Query` 用于 `SELECT` 等返回数据行的查询，而 `Exec` 用于 `INSERT`, `UPDATE`, `DELETE` 等不返回数据行的操作。
  - **获取执行结果**：展示如何从 `Exec()` 的 `sql.Result` 中获取 `LastInsertId()` 和 `RowsAffected()`。

- **预处理语句 (`PreparedStatement`)**
  - **为什么需要预处理**：解释预处理的两个核心优势：1) **防止 SQL 注入**；2) **性能提升**（在多次执行相同结构的 SQL 时）。
  - **使用方法**：演示 `DB.Prepare()` 或 `Tx.Prepare()` 的用法，以及如何执行 (`Stmt.Exec()`, `Stmt.Query()`) 和关闭 (`Stmt.Close()`) 一个 `Stmt`。
  - **最佳实践**：强调应该为所有接受用户输入的 SQL 查询使用预处理。

- **处理 `NULL` 值**
  - **挑战**：解释 Go 的基本类型（如 `string`, `int`）不支持 `NULL`，直接 `Scan` 一个 `NULL` 值会报错。
  - **解决方案**：
    - **`sql.Null` 类型**：详细介绍 `sql.NullString`, `sql.NullInt64`, `sql.NullBool`, `sql.NullFloat64` 等类型。展示如何使用它们的 `Valid` 字段和 `Value` 字段。
    - **使用指针**：解释如何 `Scan` 到一个指针类型（如 `*string`, `*int`），如果数据库值为 `NULL`，指针将为 `nil`。
    - **选择哪种方案**：对比两种方案的优缺点，并给出建议（`sql.Null` 类型更明确，但使用起来稍显繁琐）。

- **错误处理**
  - **`sql.ErrNoRows`**：特别强调 `DB.QueryRow().Scan()` 在没有找到结果时会返回 `sql.ErrNoRows`。解释应该显式地检查这个错误，而不是将其视为一个通用的失败。
  - **其他常见错误**：如连接错误、语法错误、约束冲突等，并给出通用的错误处理策略。

### 4. 高级主题
- **`context.Context` 的集成**
  - **目的**：解释 `context` 如何为数据库操作提供超时控制和取消信号的传递机制。
  - **用法**：展示 `DB.QueryContext()`, `DB.ExecContext()`, `DB.BeginTx()` 等 `*Context` 方法的使用。
  - **重要性**：强调在现代网络应用中，为所有数据库操作传递 `context` 是一个至关重要的实践。

### 5. 完整示例：一个简单的 CRUD 应用
- 提供一个完整、可运行的 Go 程序。
- 该程序使用 `database/sql` 和 `go-sql-driver/mysql` (或 `pq`)。
- 实现一个 `users` 表的增、删、改、查功能。
- 代码中要清晰地展示前面讨论过的所有关键概念：连接池配置、预处理、事务、`NULL` 值处理和 `context`。

## 代码要求
- 所有代码片段都必须是独立的、可编译和可运行的。
- 遵循 Go 的编码规范和最佳实践。
- 注释清晰，解释代码的关键部分和设计决策。
- 在示例代码的开头，用注释说明所需的数据库表结构 (SQL DDL)。

## 文章风格
- **权威与精确**：确保所有技术细节准确无误。
- **循序渐进**：从基础概念讲到高级用法，结构清晰，逻辑流畅。
- **注重实践**：提供大量实用的代码示例，而不仅仅是理论。

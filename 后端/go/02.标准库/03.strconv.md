# `strconv` 包：字符串与基础类型的精准转换

请你扮演一位 Go 语言标准库的专家，为一篇名为《`strconv` 包：字符串与基础类型的精准转换》的教程生成内容。

**文章目标：** 帮助 Go 开发者深入理解和熟练运用 `strconv` 包，实现字符串与各种基础数据类型（如整数、浮点数、布尔值）之间的安全、高效转换。文章应覆盖核心函数、错误处理和最佳实践。

**内容要求：**

1.  **引言：为什么需要 `strconv`？**
    *   开篇提出一个常见场景：当从配置文件、HTTP 请求参数、数据库或 CSV 文件中读取数据时，我们得到的是字符串，但程序逻辑需要的是 `int`、`float64` 或 `bool` 等类型。
    *   解释 `strconv`（String Conversion）包的职责：它就是连接“文本世界”和“类型世界”的桥梁，提供了一套标准、可靠的转换工具。

2.  **核心功能一：字符串 → 其他类型 (Parse)**
    *   这是 `strconv` 最常用的功能。需要强调**错误处理**的重要性，因为用户输入或外部数据源的格式无法保证。
    *   **`ParseBool(str)`**: 将 "1", "t", "T", "true", "TRUE", "True" 等解析为 `true`。其他为 `false`（除非是无效语法）。
    *   **`ParseInt(s, base, bitSize)`**: 这是最核心的整数解析函数。
        *   `s`: 要解析的字符串。
        *   `base`: 进位制（2 到 36）。如果 `base` 为 0，则会根据字符串前缀自动推断（`0x` 为 16 进制，`0` 为 8 进制，否则为 10 进制）。
        *   `bitSize`: 指定整数类型的大小，如 0, 8, 16, 32, 64，分别对应 `int`, `int8`, `int16`, `int32`, `int64`。
        *   **必须**演示如何检查返回的 `error`，特别是 `ErrRange`（超出范围）和 `ErrSyntax`（语法错误）。
    *   **`ParseUint(s, base, bitSize)`**: `ParseInt` 的无符号版本。
    *   **`ParseFloat(s, bitSize)`**: 解析浮点数。
        *   `bitSize`: 32 或 64，对应 `float32` 和 `float64`。
    *   **`Atoi(s)` (ASCII to Integer)**: 这是 `ParseInt(s, 10, 0)` 的便捷包装。强调它虽然方便，但功能相对简单，且只适用于十进制。

3.  **核心功能二：其他类型 → 字符串 (Format)**
    *   将程序中的数据转换为可读的字符串形式。
    *   **`FormatBool(b)`**: `true` → "true", `false` → "false"。
    *   **`FormatInt(i, base)`**: 将 `int64` 类型的整数 `i` 转换为指定 `base` 的字符串。
    *   **`FormatUint(i, base)`**: `FormatInt` 的无符号版本。
    *   **`FormatFloat(f, fmt, prec, bitSize)`**: 最复杂的格式化函数。
        *   `fmt`: 格式，如 'f' (标准)、'b' (二进制指数)、'e' (科学计数法)。
        *   `prec`: 精度（小数点后的位数）。
        *   `bitSize`: 32 或 64。
    *   **`Itoa(i)` (Integer to ASCII)**: `FormatInt(int64(i), 10)` 的便捷包装。同样，它只适用于十进制。

4.  **性能优化：`Append` 系列函数**
    *   介绍 `AppendInt`, `AppendFloat` 等函数。
    *   解释它们的作用：将格式化后的字符串**追加**到一个已有的 `[]byte` 切片中，而不是创建一个新的字符串。
    *   强调这在需要拼接大量数字和文本的性能敏感场景下（如构建 JSON 或日志），可以有效减少内存分配。

5.  **总结与最佳实践**
    *   回顾 `strconv` 的核心功能：`Parse`、`Format`、`Append` 以及便捷的 `Atoi/Itoa`。
    *   总结关键实践点：
        *   **永远不要忽略 `Parse` 系列函数返回的 `error`**。这是保证程序健壮性的关键。
        *   `Atoi` 很方便，但只适用于简单的十进制字符串转 `int` 的场景。
        *   在需要控制进制或整数大小时，必须使用 `ParseInt` / `FormatInt`。
        *   在高性能场景下，优先考虑使用 `Append` 系列函数来减少内存分配。

**代码示例要求：**
*   为每个核心函数提供清晰、可运行的示例。
*   `Parse` 系列的示例必须包含完整的错误处理逻辑。
*   `ParseInt` 和 `FormatInt` 的示例应展示不同 `base` 参数的效果。

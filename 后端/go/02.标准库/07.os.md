# `os` 包：与操作系统交互的通用接口

请你扮演一位 Go 语言的系统工程师和命令行工具开发者，为一篇名为《`os` 包：与操作系统交互的通用接口》的教程生成内容。

**文章目标：** 帮助 Go 开发者掌握 `os` 包，学会如何使用它来执行平台无关的文件系统操作、管理环境变量、与进程交互以及处理操作系统信号，从而编写出强大的系统级应用程序和工具。

**内容要求：**

1.  **引言：程序的边界——操作系统**
    *   开篇说明任何程序都运行在操作系统之上，`os` 包就是 Go 程序与底层操作系统进行交互的标准、跨平台接口。
    *   强调 `os` 包的重要性：无论是简单的脚本还是复杂的后端服务，都离不开它提供的功能。
    *   简要概述文章将涵盖的核心领域：文件 I/O、文件系统操作、环境变量、进程控制和信号处理。

2.  **文件 I/O 核心：`os.File`**
    *   **`os.File` 的角色**：解释 `os.File` 是对底层文件描述符的封装，它代表一个打开的文件，并且是 Go I/O 体系的核心成员，因为它实现了 `io.Reader` 和 `io.Writer` 接口。
    *   **文件的打开与创建**：
        *   `os.Open(name)`: 以只读方式打开文件。
        *   `os.Create(name)`: 创建一个用于写入的文件，如果文件已存在则清空内容。
        *   `os.OpenFile(name, flag, perm)`: **最通用、最强大**的函数。重点解释 `flag`（如 `os.O_RDONLY`, `os.O_WRONLY`, `os.O_RDWR`, `os.O_APPEND`, `os.O_CREATE`, `os.O_TRUNC`）和 `perm`（文件权限，如 `0666`）的含义和组合方式。
    *   **文件的读写**：展示如何结合 `io` 或 `bufio` 包对 `os.File` 对象进行读写操作。
    *   **关闭文件**：**强烈强调**打开文件后必须使用 `defer file.Close()` 来确保文件句柄被释放，防止资源泄漏。

3.  **文件系统操作**
    *   **获取文件信息**：
        *   `os.Stat(name)`: 获取一个 `FileInfo` 接口，包含文件名、大小、模式、修改时间等信息。
        *   `FileInfo` 的常用方法：`Name()`, `Size()`, `Mode()`, `ModTime()`, `IsDir()`。
    *   **目录操作**：
        *   `os.Mkdir(path, perm)` / `os.MkdirAll(path, perm)`: 创建单级目录/多级目录。
        *   `os.ReadDir(name)`: 读取目录内容，返回一个 `[]DirEntry` 切片（比 `os.Readdir` 更现代、更高效）。
    *   **删除操作**：
        *   `os.Remove(name)`: 删除文件或**空**目录。
        *   `os.RemoveAll(path)`: 递归删除路径下的所有内容。**警示**：这是一个危险操作，需谨慎使用。
    *   **重命名与移动**：
        *   `os.Rename(oldpath, newpath)`: 重命名或移动文件/目录。

4.  **与进程环境交互**
    *   **环境变量**：
        *   `os.Getenv(key)`: 获取单个环境变量的值。
        *   `os.Setenv(key, value)`: 设置环境变量。
        *   `os.LookupEnv(key)`: 安全地获取环境变量，它会返回一个布尔值表示该变量是否存在。
        *   `os.Environ()`: 获取所有环境变量，形式为 `["key=value", ...]`。
    *   **命令行参数**：
        *   `os.Args`: 获取命令行参数切片，`os.Args[0]` 是程序本身的名称。
    *   **工作目录**：
        *   `os.Getwd()`: 获取当前工作目录。
        *   `os.Chdir(dir)`: 更改当前工作目录。
    *   **退出进程**：
        *   `os.Exit(code)`: 以给定的状态码退出程序。强调 `os.Exit` 会立即终止程序，`defer` 语句不会被执行。

5.  **处理操作系统信号 (`os/signal`)**
    *   **为什么需要处理信号？** 解释信号是操作系统用来通知进程发生某个事件的方式（如 `Ctrl+C` 对应 `SIGINT`，`kill` 命令对应 `SIGTERM`），优雅地处理信号是构建健壮服务的关键。
    *   **基本用法**：
        *   创建一个 channel (e.g., `make(chan os.Signal, 1)`)。
        *   使用 `signal.Notify(c, os.Interrupt, syscall.SIGTERM)` 来监听指定的信号。
        *   在一个单独的 goroutine 中阻塞等待从 channel 接收信号。
        *   收到信号后，执行清理工作（如关闭数据库连接、完成正在处理的请求），然后安全退出。

6.  **总结与最佳实践**
    *   回顾 `os` 包提供的核心功能。
    *   总结关键实践点：
        *   文件操作后务必 `defer file.Close()`。
        *   创建多级目录时使用 `os.MkdirAll` 更方便。
        *   使用 `os.RemoveAll` 前要三思。
        *   优先使用 `os.LookupEnv` 来检查环境变量是否存在。
        *   对于需要优雅退出的服务，必须实现信号处理逻辑。

**代码示例要求：**
*   为文件读、写、创建、删除提供完整的代码片段，包含错误处理和 `defer`。
*   提供一个递归遍历目录的示例（使用 `os.ReadDir`）。
*   提供一个完整的、可运行的信号处理示例，模拟一个服务的优雅关闭过程。

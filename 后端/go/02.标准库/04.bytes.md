# `bytes` 包：Go 中的高效字节序列处理

请你扮演一位 Go 语言底层库专家，为一篇名为《`bytes` 包：Go 中的高效字节序列处理》的深度教程生成内容。

**文章目标：** 帮助 Go 开发者深入理解 `bytes` 包，特别是它与 `strings` 包的相似性与区别，并熟练掌握 `bytes.Buffer` 这一强大的工具，用于高效地构建和读取字节序列。

**内容要求：**

1.  **引言：`[]byte` 与 `string` 的二元性**
    *   开篇解释 Go 中 `string` 是不可变的字节序列，而 `[]byte` 是可变的字节序列。这是理解 `strings` 和 `bytes` 两个包关系的基础。
    *   指出 `bytes` 包提供了大量与 `strings` 包功能几乎完全对应的函数，但它们操作的对象是 `[]byte`。
    *   简要介绍文章将重点探讨 `bytes` 包的常用函数、与 `strings` 的对比，以及核心类型 `bytes.Buffer`。

2.  **`bytes` 包常用函数：`strings` 的镜像**
    *   强调学习 `bytes` 包的函数有一个捷径：它们大部分与 `strings` 包的同名函数功能一致，只是参数和返回值换成了 `[]byte`。
    *   选择几个具有代表性的函数进行对比展示，无需全部罗列，旨在说明其对应关系。
        *   `bytes.Equal(a, b)` vs `a == b` (for strings)
        *   `bytes.Compare(a, b)` vs `strings.Compare(a, b)`
        *   `bytes.Contains(b, subslice)` vs `strings.Contains(s, substr)`
        *   `bytes.HasPrefix(b, prefix)` vs `strings.HasPrefix(s, prefix)`
        *   `bytes.Split(b, sep)` vs `strings.Split(s, sep)`
        *   `bytes.Join(s, sep)` vs `strings.Join(a, sep)`
        *   `bytes.Replace(b, old, new, n)` vs `strings.Replace(s, old, new, n)`
    *   **关键区别**：强调 `bytes` 包的函数直接操作可变的 `[]byte`，而 `strings` 包的函数由于 `string` 的不可变性，总是返回一个新的 `string`。

3.  **核心工具：`bytes.Buffer`**
    *   这是 `bytes` 包的精髓，也是文章的重点。
    *   **定义**：将 `bytes.Buffer` 描述为一个可变的、内存中的字节缓冲区，它同时实现了 `io.Reader` 和 `io.Writer` 接口。
    *   **与 `strings.Builder` 的对比**：
        *   **相似点**：两者都用于高效构建序列，内部都使用 `[]byte` 并有动态扩容机制，都旨在减少内存分配。
        *   **不同点**：`bytes.Buffer` 更强大，因为它**可读可写**。`strings.Builder` 只能写入，最终通过 `String()` 方法一次性读取。
    *   **核心用法**：
        *   **作为写入器 (`io.Writer`)**：
            *   `Write(p []byte)` / `WriteString(s)` / `WriteByte(c)`: 向缓冲区末尾追加数据。
            *   展示如何将 `bytes.Buffer` 作为参数传递给 `io.Copy` 或 `fmt.Fprintf`，捕获它们的输出。
        *   **作为读取器 (`io.Reader`)**：
            *   `Read(p []byte)`: 从缓冲区开头读取数据到 `p` 中。
            *   `Bytes()`: 获取缓冲区中所有**未读**的字节。
            *   `String()`: 获取缓冲区中所有**未读**字节的字符串表示。
        *   **其他重要方法**：`Len()` (未读字节数), `Cap()` (总容量), `Reset()` (清空缓冲区), `Grow()` (预分配容量)。

4.  **`bytes.Reader`**
    *   简要介绍 `bytes.NewReader(b []byte)`，它与 `strings.NewReader` 功能完全相同，但作用于 `[]byte`。
    *   解释其使用场景：当需要将一个 `[]byte` 切片适配到 `io.Reader`、`io.Seeker` 等接口时使用。

5.  **总结与最佳实践**
    *   回顾 `bytes` 包的核心功能。
    *   总结关键实践点：
        *   当你需要一个功能类似 `strings` 包但操作对象是 `[]byte` 的函数时，直接去 `bytes` 包里找。
        *   **`bytes.Buffer` 是处理动态字节序列的首选工具**。它在 I/O 操作、数据编码/解码、构建网络请求体等场景中非常有用。
        *   如果只是为了构建一个最终的字符串，`strings.Builder` 可能更直接、意图更清晰。如果需要一个既能读又能写的缓冲区，`bytes.Buffer` 是不二之-   选。

**代码示例要求：**
*   提供 `bytes` 和 `strings` 对应函数的简单对比示例。
*   提供 `bytes.Buffer` 作为 `io.Writer` 和 `io.Reader` 的清晰、可运行的示例。
*   展示 `Buffer` 的 `Reset` 和 `Grow` 等方法的用法。

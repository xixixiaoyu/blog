# `flag`：构建优雅的 Go 命令行工具

请你扮演一位经验丰富的 Go 开发者和命令行工具设计师，为一篇名为《`flag`：构建优雅的 Go 命令行工具》的教程生成内容。

**文章目标：** 帮助 Go 开发者精通标准库 `flag` 包，学会如何轻松地为应用程序添加命令行标志（command-line flags），并掌握构建结构清晰、用户友好的命令行接口（CLI）的最佳实践。

**核心概念：**

1.  **`flag` 包的哲学：**
    *   简介 `flag` 包在 Go 生态中的地位，以及它如何简化命令行参数的解析。
    *   强调其设计目标：简单、够用，专注于标志（flags）而非复杂的参数处理。

2.  **基础用法：定义与解析**
    *   **定义标志的三种方式：**
        *   `flag.String()` / `flag.Int()` / `flag.Bool()` 等：返回一个指向标志值的指针。这是最直接的方式。
        *   `flag.StringVar()` / `flag.IntVar()` / `flag.BoolVar()` 等：将标志值绑定到一个已有的变量上。
        *   `flag.Var()`：绑定一个实现了 `flag.Value` 接口的自定义类型，用于处理复杂或自定义的标志。
    *   **`flag.Parse()` 的关键作用：**
        *   详细解释 `flag.Parse()` 必须在所有标志定义之后、访问标志值之前被调用。
        *   说明它如何从 `os.Args[1:]` 中解析标志，并将非标志参数保留下来。
    *   **提供一个完整的入门代码示例**，包含定义字符串、整数、布尔型标志，解析它们，并打印出最终的值。

3.  **访问标志的值：**
    *   演示如何通过指针（`*myFlag`）或绑定的变量来安全地访问解析后的标志值。
    *   介绍 `flag.Args()` 函数，用于获取所有非标志参数。
    *   介绍 `flag.NFlag()` 和 `flag.NArg()`，用于获取已设置的标志数量和非标志参数的数量。

4.  **自定义标志：`flag.Value` 接口**
    *   **场景：** 什么时候需要自定义标志？（例如：接受逗号分隔的列表 `host1,host2`，或自定义时间格式 `YYYY-MM-DD`）。
    *   **实现 `flag.Value` 接口：**
        *   详细讲解 `String() string` 和 `Set(string) error` 这两个方法的含义和实现要点。
        *   `String()` 方法用于生成默认值的帮助信息。
        *   `Set()` 方法是核心，负责将用户输入的字符串转换为你的自定义类型。
    *   提供一个实用的例子，例如实现一个可以接受多个值的 `string` 切片标志。

5.  **最佳实践与高级技巧**
    *   **设置默认值和帮助信息：** 强调为每个标志提供清晰、有意义的默认值和帮助文本的重要性。
    *   **`flag.FlagSet`：实现子命令（Subcommands）**
        *   解释为什么 `flag` 包本身不直接支持子命令（如 `git commit` 中的 `commit`），但可以使用 `flag.FlagSet` 来实现。
        *   提供一个清晰的 `git` 或 `docker` 风格的子命令实现示例，展示如何为每个子命令定义独立的标志集。
    *   **优雅地处理错误：** 演示如何处理 `flag.Parse()` 可能返回的错误。
    *   **定制帮助信息：** 展示如何通过 `flag.Usage` 变量来自定义 `--help` 的输出，使其更具品牌特色或包含更丰富的文档。
    *   **与第三方库的对比：** 简要提及 `spf13/cobra` 和 `urfave/cli` 等功能更丰富的第三方库，并说明何时应该选择它们而不是标准库 `flag`。

**代码示例要求：**
*   所有代码都必须是完整、可运行的 Go 程序。
*   注释清晰，解释每个关键步骤的目的。
*   命令行交互示例要清晰地展示如何运行程序、传递标志，以及程序的预期输出。

**总结：**
回顾 `flag` 包的核心优势——简洁、零依赖，并总结在什么场景下它依然是构建命令行工具的最佳选择。鼓励读者在简单的项目中优先使用标准库。

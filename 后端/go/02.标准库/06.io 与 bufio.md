# `io` 与 `bufio`：Go I/O 操作的哲学与实践

请你扮演一位 Go 语言的系统编程专家和接口设计大师，为一篇名为《`io` 与 `bufio`：Go I/O 操作的哲学与实践》的深度技术文章生成内容。

**文章目标：** 帮助 Go 开发者深入理解 Go 语言中 I/O 操作的核心设计哲学——基于接口和组合的流式处理。文章需清晰讲解 `io` 包的基础接口、`bufio` 包的缓冲机制，以及如何组合它们来编写高效、优雅的 I/O 代码。

**内容要求：**

1.  **引言：Go 的 I/O 哲学——万物皆为流**
    *   开篇点明 Go I/O 设计的核心思想：将所有可进行 I/O 操作的对象（如文件、网络连接、内存数据等）抽象为统一的、可读或可写的“流”（Stream）。
    *   介绍 `io.Reader` 和 `io.Writer` 接口是这一哲学的基石，它们定义了所有 I/O 操作的通用合约。
    *   强调这种设计的巨大优势：**可组合性（Composability）**。任何实现了这些接口的类型都可以被无缝地组合和替换。

2.  **`io` 包：构建一切的基础**
    *   **`io.Reader` 和 `io.Writer`**
        *   深入讲解这两个核心接口的定义和方法签名：`Read(p []byte) (n int, err error)` 和 `Write(p []byte) (n int, err error)`。
        *   解释 `(n, err)` 返回值的含义，特别是 `io.EOF` 这个重要的错误信号。
    *   **`io.Copy(dst Writer, src Reader)`**
        *   将其誉为“Go I/O 操作的瑞士军刀”，是连接 `Reader` 和 `Writer` 最常用、最高效的方式。
        *   提供一个从 `strings.Reader` 复制到 `os.Stdout` 的简单示例。
    *   **`io.ReadAll(r Reader)`**
        *   介绍这是一个将 `Reader` 中所有数据一次性读入内存的便捷函数。
        *   **警示**：必须提醒读者，在处理大数据流（如大文件）时要慎用此函数，因为它可能导致巨大的内存消耗。
    *   **重要的组合接口**
        *   简要介绍 `io.ReadWriter`、`io.ReadCloser`、`io.WriteCloser`、`io.ReadWriteCloser`，展示接口组合的魅力。
    *   **`io.Pipe()`**
        *   解释 `io.Pipe()` 如何创建一个内存内的同步管道，返回一个 `*PipeReader` 和一个 `*PipeWriter`。
        *   强调其典型应用场景：在不同的 goroutine 之间安全地传递流式数据，一个 goroutine 写入，另一个 goroutine 读取。

3.  **`bufio` 包：为性能加上“缓冲”**
    *   **为什么需要缓冲？**
        *   解释直接对文件或网络进行 `Read`/`Write` 操作通常涉及昂贵的系统调用（syscall）。
        *   说明缓冲的原理：通过在内存中设置一个缓冲区，`bufio` 将多次小的 I/O 操作合并为一次大的 I/O 操作，从而显著减少系统调用的次数，提升性能。
    *   **`bufio.Reader`**
        *   介绍 `bufio.NewReader(rd)` 如何包装一个已有的 `io.Reader`。
        *   常用方法：`ReadString('
')`（按行读）、`ReadByte()`、`Peek()`（窥探数据而不消费）。
    *   **`bufio.Writer`**
        *   介绍 `bufio.NewWriter(wr)` 如何包装一个 `io.Writer`。
        *   **重点强调 `Flush()` 方法**：解释写入 `bufio.Writer` 的数据会先暂存在缓冲区，直到缓冲区满了或**手动调用 `Flush()`** 才会真正写入底层的 `Writer`。**忘记 `Flush()` 是一个极其常见的 bug**，必须重点说明，并给出 `defer writer.Flush()` 的最佳实践。
    *   **`bufio.Scanner`：现代文本读取的最佳方式**
        *   将其定位为读取文本数据（如逐行读取文件）的首选工具。
        *   **对比 `ReadString('
')`**：解释 `Scanner` 的优势在于能处理任意长度的行（不会像 `ReadString` 那样因缓冲区不足而出错），并且可以通过 `Split` 函数自定义分割逻辑（如按单词、按 CSV 逗号等）。
        *   展示标准的 `for scanner.Scan() { ... }` 循环，并说明如何通过 `scanner.Err()` 检查循环结束后的错误。

4.  **总结与最佳实践**
    *   回顾 Go I/O 的核心：`Reader/Writer` 接口、`io.Copy`、`bufio` 缓冲和 `bufio.Scanner`。
    *   总结关键实践点：
        *   对于文件、网络等底层 I/O，**总是使用 `bufio` 进行包装**以获得最佳性能。
        *   使用 `bufio.Writer` 时，**永远不要忘记 `defer writer.Flush()`**。
        *   读取文本文件或解析文本流时，**优先使用 `bufio.Scanner`**。
        *   尽可能地让你的函数接受 `io.Reader` 和 `io.Writer` 接口，而不是具体类型（如 `*os.File`），这会让你的代码更通用、更易于测试。

**代码示例要求：**
*   为 `io.Copy`、`io.Pipe` 提供清晰的示例。
*   提供 `bufio.Writer` 忘记 `Flush()` 导致没写入数据的反面教材，和使用 `defer` 的正确示例。
*   提供一个使用 `bufio.Scanner` 逐行读取文件的完整、可运行的示例。

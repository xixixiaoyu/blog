# `log`：Go 标准库的日志艺术

请你扮演一位 Go 语言的资深开发者和软件架构师，为一篇名为《`log`：Go 标准库的日志艺术》的教程生成内容。

**文章目标：** 帮助 Go 开发者深入理解标准库 `log` 包的设计哲学、核心功能和局限性。读者将学会如何有效使用默认 logger、如何创建和配置自定义 logger，并能在现代项目中就日志方案做出明智的技术选型。

**核心概念：**

1.  **`log` 包的设计哲学：简单与可靠**
    *   开篇明义，`log` 包的核心目标是提供一个简单、开箱即用、并发安全的日志记录功能。
    *   它不是一个功能完备的日志框架，而是一个基础构建块。

2.  **默认的全局 Logger：开箱即用**
    *   介绍 `log` 包提供的全局默认 logger，它默认将日志输出到标准错误（`os.Stderr`）。
    *   **核心函数族：**
        *   `log.Print` / `log.Println` / `log.Printf`：用于记录常规信息。
        *   `log.Fatal` / `log.Fatalln` / `log.Fatalf`：记录日志后，会调用 `os.Exit(1)` 终止程序。
        *   `log.Panic` / `log.Panicln` / `log.Panicf`：记录日志后，会调用 `panic()`。
    *   提供清晰的代码示例，演示上述函数的基本用法和区别。

3.  **自定义 Logger：`log.New`**
    *   **创建 Logger：**
        *   详细讲解 `log.New(out io.Writer, prefix string, flag int)` 函数的三个参数：
            *   `out`：日志的输出目的地，可以是文件（`*os.File`）、标准输出、`bytes.Buffer`（用于测试）等任何实现了 `io.Writer` 的对象。
            *   `prefix`：每条日志的前缀字符串。
            *   `flag`：控制日志内容的格式，如日期、时间、文件名、行号等。
    *   **配置 Logger：**
        *   演示如何通过 `logger.SetOutput()`, `logger.SetPrefix()`, `logger.SetFlags()` 在创建后动态修改 logger 的配置。
        *   提供一个将日志同时输出到控制台和文件的实用示例。

4.  **日志标志（Flags）详解**
    *   通过一个表格清晰地列出所有可用的 `flag` 及其组合效果，例如：
        *   `log.Ldate`：日期 `2009/01/23`
        *   `log.Ltime`：时间 `01:23:23`
        *   `log.Lmicroseconds`：微秒 `01:23:23.123123`
        *   `log.Llongfile`：完整文件路径和行号 `/a/b/c/d.go:23`
        *   `log.Lshortfile`：文件名和行号 `d.go:23`
        *   `log.LstdFlags`：`log.Ldate | log.Ltime` 的默认组合。
    *   提供代码示例，展示不同 `flag` 组合的输出效果。

5.  **`log` 包的局限性与现代日志实践**
    *   **缺乏日志级别（Log Levels）：** 这是 `log` 包最显著的局限。它没有 `DEBUG`, `INFO`, `WARN`, `ERROR` 等分级，使得日志过滤和管理变得困难。
    *   **结构化日志（Structured Logging）的缺失：** `log` 包输出的是纯文本，不利于机器解析和处理。现代应用（尤其是在云原生环境中）普遍采用 JSON 或其他结构化格式。
    *   **性能考量：** 在高并发、高吞吐量的场景下，`log` 包的性能可能不及专门优化的第三方库。

6.  **技术选型：`log` vs. 第三方库**
    *   **何时使用 `log` 包？**
        *   简单的命令行工具或脚本。
        *   项目的早期开发阶段。
        *   当不希望引入任何第三方依赖时。
        *   作为底层库，将日志输出的控制权交给上层应用。
    *   **何时选择第三方库（如 `zerolog`, `zap`, `logrus`）？**
        *   需要日志级别控制。
        *   需要结构化日志（JSON 格式）。
        *   对日志性能有极高要求。
        *   需要更丰富的特性，如 hooks、日志轮转（log rotation）等。
    *   简要介绍 `zerolog` 和 `zap` 的核心优势（高性能、低分配、结构化），并提供一个简单的 `zerolog` 代码示例作为对比。

**代码示例要求：**
*   代码简洁、可运行，并有详细的注释。
*   清晰地展示如何配置和使用 `log.Logger`。
*   对比默认 logger 和自定义 logger 的输出差异。

**总结：**
重申 `log` 包的价值在于其简单性和作为标准库的普适性。它教会了我们日志记录的基本原则。在构建严肃的生产级应用时，开发者应该基于项目的具体需求，明智地选择 `log` 包或更强大的第三方日志框架。

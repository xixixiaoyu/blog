# `regexp`：Go 中的安全与高性能正则表达式

请你扮演一位 Go 语言的性能工程师和安全专家，为一篇名为《`regexp`：Go 中的安全与高性能正则表达式》的教程生成内容。

**文章目标：** 帮助 Go 开发者深入理解 `regexp` 标准库的设计哲学，掌握其核心 API，并学会编写出既正确又高效的正则表达式代码。读者将理解 Go 正则引擎与其他引擎（如 PCRE）的关键区别，并学会如何避免常见的性能陷阱。

**核心概念：**

1.  **Go 正则的哲学：基于 RE2 的安全与效率**
    *   **开篇明义：** Go 的 `regexp` 包是基于 Google 的 [RE2 引擎](https://github.com/google/re2/wiki/Syntax)实现的。
    *   **核心保证：**
        *   **线性时间复杂度：** 匹配时间与输入字符串长度成线性关系，从根本上杜绝了“正则表达式拒绝服务攻击”（ReDoS）。
        *   **更少的特性，更高的安全性：** RE2 不支持一些在其他引擎中常见但可能导致灾难性回溯的功能，如反向引用（backreferences）和环视（look-around）。
    *   **结论：** Go 的正则表达式为速度和安全而生，而非最丰富的功能。

2.  **编译正则表达式：`Compile` vs. `MustCompile`**
    *   **`regexp.Compile(expr string) (*Regexp, error)`：**
        *   这是标准的编译函数，它将一个正则表达式字符串解析并编译成一个 `Regexp` 对象。如果表达式语法错误，它会返回一个 `error`。
        *   适用于：当正则表达式本身是动态生成或来自用户输入时。
    *   **`regexp.MustCompile(expr string) *Regexp`：**
        *   功能与 `Compile` 相同，但如果表达式语法错误，它会直接 `panic`。
        *   **最佳实践：** 当正则表达式是写死在代码里的常量时，**总是**使用 `MustCompile` 在包级别（全局变量）进行初始化。这确保了“编译一次，复用多次”，并且在程序启动时就能发现语法错误。
    *   提供一个使用 `MustCompile` 定义全局 `Regexp` 变量的经典示例。

3.  **核心 API 详解：匹配、查找、替换、分割**
    *   **匹配 (Match)：检查是否存在匹配**
        *   `MatchString(s string) bool`：最常用的函数，判断字符串 `s` 是否包含任何匹配项。
        *   `MatchReader(r io.RuneReader) bool` / `Match(b []byte) bool`：针对不同输入源的同类函数。
    *   **查找 (Find)：获取匹配的文本**
        *   `FindString(s string) string`：查找第一个匹配的子字符串。
        *   `FindAllString(s string, n int)`：查找所有匹配的子字符串，`n` 控制查找数量（-1 表示全部）。
        *   **捕获组 (Submatch)：**
            *   `FindStringSubmatch(s string) []string`：查找第一个匹配项及其所有捕获组。
            *   `FindAllStringSubmatch(s string, n int)`：查找所有匹配项及其所有捕-获组。
        *   提供一个解析 URL 或日志的示例，清晰地展示 `FindStringSubmatch` 如何提取出协议、域名、路径等部分。
    *   **替换 (Replace)：修改字符串**
        *   `ReplaceAllString(src, repl string) string`：将所有匹配项替换为字符串 `repl`。
        *   `ReplaceAllStringFunc(src string, repl func(string) string) string`：使用一个函数的返回值来动态替换每个匹配项，功能更强大。
        *   提供示例，展示如何使用捕获组（如 `$1`, `${name}`）进行替换。
    *   **分割 (Split)：切分字符串**
        *   `Split(s string, n int) []string`：使用正则表达式作为分隔符来切分字符串。

4.  **性能最佳实践**
    *   **“编译一次，复用多次”：** 再次强调，永远不要在循环或高频调用的函数内部调用 `Compile` 或 `MustCompile`。应将其结果保存在一个变量中复用。
    *   **使用 `MatchString` 进行纯粹的检查：** 如果你只需要知道“是否匹配”，而不是“匹配了什么”，`MatchString` 是最高效的选择。
    *   **编写具体的正则表达式：** 避免使用过于宽泛的模式，如 `.*`。模式越具体，引擎的工作效率越高。例如，用 `[^<]+` 代替 `.*` 来匹配标签内的内容。

**代码示例要求：**
*   所有代码都必须是完整、可运行的 Go 程序。
*   使用 `regexp.MustCompile` 在包级别初始化 `Regexp` 对象。
*   提供一个清晰的 `FindStringSubmatch` 示例，用于从文本中提取结构化数据。
*   提供一个 `ReplaceAllStringFunc` 的示例，展示其动态替换的能力。

**总结：**
回顾 `regexp` 包的核心优势：安全、高效、可靠。虽然它在功能上有所取舍，但其对 ReDoS 的免疫能力使其成为构建健壮网络服务的理想选择。鼓励开发者拥抱其设计哲学，并遵循性能最佳实践。

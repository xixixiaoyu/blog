# `errors` 包：现代 Go 中的错误处理艺术

请你扮演一位 Go 语言错误处理（Error Handling）专家和布道者，为一篇名为《`errors` 包：现代 Go 中的错误处理艺术》的深度教程生成内容。

**文章目标：** 帮助 Go 开发者（特别是从 Go 1.13 之前的版本迁移过来的开发者）全面掌握现代 Go 的错误处理机制。文章需要清晰地讲解 `errors.Is`、`errors.As` 和错误包装（Wrapping）的核心概念与用法，并与传统的错误处理方式进行对比。

**内容要求：**

1.  **引言：从 `err != nil` 到错误哲学**
    *   开篇肯定 `if err != nil` 是 Go 错误处理的基石，它强制开发者显式地处理每一个可能的错误。
    *   提出问题：简单的 `err != nil` 检查在复杂的系统中会遇到什么问题？（例如，无法判断错误的具体类型、错误信息丢失上下文）
    *   引出 Go 1.13 引入的 `errors` 包新特性，它们旨在解决这些问题，让错误处理更强大、更具表现力。

2.  **传统错误处理方式及其局限性**
    *   **哨兵错误 (Sentinel Errors)**
        *   解释：通过定义导出的错误变量（如 `var ErrNotFound = errors.New("not found")`）并在调用方通过 `if err == ErrNotFound` 来判断特定错误。
        *   **局限性**：当错误被其他信息包装后（例如，使用 `fmt.Errorf`），`==` 比较就会失效，导致无法正确识别底层错误。
    *   **错误类型 (Error Types)**
        *   解释：定义一个实现了 `error` 接口的自定义结构体，通过类型断言 `if _, ok := err.(*MyError); ok` 来判断。
        *   **局限性**：与哨兵错误类似，一旦错误被包装，类型断言也会失效。

3.  **现代错误处理的核心：错误包装 (Error Wrapping)**
    *   **`fmt.Errorf` 与 `%w` 动词**：
        *   这是现代错误处理的**核心**。解释 `fmt.Errorf("service layer: %w", err)` 中的 `%w` 动词的作用：它会将 `err` “包装”起来，形成一个错误链（Error Chain）。
        *   强调 `%w` 与 `%v` 的关键区别：`%v` 只是将错误信息简单地嵌入到新的字符串中，丢失了原始错误对象；而 `%w` 保留了对原始错误的引用。
    *   **错误链 (Error Chain)**：形象地将错误链比喻成一个“洋葱”，每一层都添加了新的上下文信息，但核心的错误仍然在最里面。

4.  **检查错误链：`errors.Is` 和 `errors.As`**
    *   **`errors.Is(err, target)`**
        *   **用途**：用于检查错误链中**是否包含**某个特定的哨兵错误 `target`。
        *   **工作原理**：它会遍历整个错误链，对链上的每一个错误 `e` 执行 `e == target` 的比较。只要有一个匹配，就返回 `true`。
        *   **优势**：完美解决了传统哨兵错误在错误被包装后失效的问题。
    *   **`errors.As(err, target)`**
        *   **用途**：用于检查错误链中**是否有某个错误可以被赋值给** `target` 指向的变量。通常用于检查特定错误类型。
        *   **工作原理**：它会遍历错误链，尝试将链上的每个错误赋值给 `target`。如果成功，它会执行赋值并返回 `true`。
        *   **`target` 的要求**：必须是一个指向接口或实现了 `error` 接口的结构体类型的指针（例如 `var e *MyError`）。
        *   **优势**：完美解决了传统错误类型断言在错误被包装后失效的问题。

5.  **解开错误链：`errors.Unwrap`**
    *   介绍 `errors.Unwrap(err)` 函数，它可以获取错误链中的下一个错误。
    *   说明 `Is` 和 `As` 内部就是依赖 `Unwrap` 来遍历错误链的，通常我们不需要手动调用它，但理解其存在有助于加深对错误链的理解。

6.  **总结与最佳实践**
    *   回顾 Go 现代错误处理的三大支柱：`%w` 包装、`errors.Is` 检查值、`errors.As` 检查类型。
    *   总结最佳实践：
        *   在向调用栈上层传递错误时，如果需要添加上下文信息，**总是使用 `fmt.Errorf` 配合 `%w`**。
        *   **优先使用 `errors.Is`** 来检查特定的、预定义的哨兵错误。
        *   当需要从错误中提取额外信息（例如，一个自定义错误结构体中的状态码）时，**使用 `errors.As`**。
        *   避免在代码中直接使用 `errors.Unwrap`，除非你在实现自定义的错误检查逻辑。

**代码示例要求：**
*   提供清晰的哨兵错误和错误类型的传统示例，并展示其在错误包装下的局限性。
*   提供使用 `%w` 创建错误链的示例。
*   提供 `errors.Is` 和 `errors.As` 的完整、可运行的示例，清晰地展示它们如何解决传统方式的痛点。

# `sync` 与 `atomic`：Go 并发同步的核心原语

请你扮演一位 Go 语言的并发编程专家和性能调优大师，为一篇名为《`sync` 与 `atomic`：Go 并发同步的核心原语》的教程生成内容。

**文章目标：** 帮助 Go 开发者深入理解 Go 语言除了 channel 之外的另一大并发利器——基于共享内存的同步原语。读者将精通 `sync` 和 `sync/atomic` 包中的核心工具，学会如何在正确的场景下选择正确的锁或原子操作，从而编写出高效、安全、无竞争的并发代码。

**核心概念：**

1.  **Go 的并发哲学再探讨**
    *   开篇回顾 Go 的名言：“不要通过共享内存来通信，而要通过通信来共享内存。” (Don't communicate by sharing memory, share memory by communicating.)
    *   解释这句话鼓励使用 channel，但并不意味着禁止使用共享内存。当需要保护一个独立的状态或数据结构时，传统的锁机制（共享内存模型）通常更简单、更高效。
    *   引出 `sync` 和 `sync/atomic` 包的定位：为共享内存提供保护和同步。

2.  **`sync.Mutex`：互斥锁**
    *   **核心功能：** 保证在同一时刻，只有一个 goroutine 可以访问被保护的共享资源。
    *   **API：** `Lock()` 和 `Unlock()`。
    *   **黄金法则：** 使用 `defer mutex.Unlock()` 来确保在函数返回时（无论是正常返回还是 `panic`）锁一定会被释放，这是避免死锁的关键。
    *   提供一个经典的并发计数器示例，展示加锁和不加锁情况下的数据竞争问题。

3.  **`sync.RWMutex`：读写锁**
    *   **适用场景：** “读多写少”的并发场景。
    *   **核心规则：**
        *   可以有任意多个“读锁” (reader lock) 同时存在。
        *   当“写锁” (writer lock) 存在时，其他任何读锁或写锁都必须等待。
    *   **API：** `RLock()`, `RUnlock()`, `Lock()`, `Unlock()`。
    *   提供一个模拟配置缓存的示例，其中读取配置的操作可以并发进行，但更新配置的操作是互斥的。

4.  **`sync.WaitGroup`：等待一组 Goroutine 完成**
    *   **核心功能：** 主 goroutine 等待一组子 goroutine 全部执行完毕。
    *   **API：**
        *   `Add(delta int)`：增加计数器的值（通常在启动 goroutine 前调用）。
        *   `Done()`：减少计数器的值（通常在 goroutine 的 `defer` 语句中调用）。
        *   `Wait()`：阻塞，直到计数器归零。
    *   提供一个并发处理任务列表的示例，主 goroutine 分发任务后使用 `wg.Wait()` 等待所有任务完成。

5.  **`sync.Once`：保证只执行一次**
    *   **核心功能：** 确保一个函数在程序生命周期内，无论被多少个 goroutine 调用，都只会被真正执行一次。
    *   **API：** `Do(f func())`。
    *   **典型场景：** 单例模式的初始化、配置的首次加载等。
    *   提供一个并发环境下安全初始化单例对象的示例。

6.  **`sync.Pool`：临时对象的复用池**
    *   **核心功能：** 减少因频繁创建和销毁临时对象而带来的 GC 压力。
    *   **API：** `Get()` 和 `Put()`。
    *   **重要特性：** `Pool` 中的对象可能在任何时候被 GC 无通知地回收。它不是一个持久化的缓存。
    *   **适用场景：** 用于复用生命周期短、创建开销大的对象，如 `[]byte` 缓冲区、大型结构体等。
    *   提供一个在 HTTP 服务器中复用 `bytes.Buffer` 的示例。

7.  **`sync/atomic`：低级别的原子操作**
    *   **定义：** 原子操作是不可中断的操作，在硬件层面保证了其在多核 CPU 环境下的线程安全，通常比使用 `Mutex` 更快。
    *   **适用场景：** 仅适用于最简单的操作，如对一个整数进行增加、减少、读取、写入或比较并交换 (CAS)。
    *   **核心 API (以 `int64` 为例)：**
        *   `atomic.AddInt64(addr *int64, delta int64)`
        *   `atomic.LoadInt64(addr *int64)`
        *   `atomic.StoreInt64(addr *int64, val int64)`
        *   `atomic.CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)` (CAS)
    *   使用 `atomic.AddInt64` 重写并发计数器示例，并与 `Mutex` 版本进行对比。

8.  **如何选择？**
    *   **`atomic`：** 保护一个独立的、简单的数值类型时，优先考虑，性能最高。
    *   **`Mutex`：** 保护一个复杂的结构体或一段需要多个操作才能完成的逻辑时，使用互斥锁。
    *   **`RWMutex`：** 当资源存在明显的“读多写少”特征时，使用读写锁以提高并发度。
    *   **Channel：** 当需要在 goroutine 之间传递数据所有权或协调复杂的业务流程时，channel 是更优雅的选择。

**常见陷阱：**
*   **死锁 (Deadlock)：** 忘记解锁、重复加锁、AB-BA 加锁顺序问题。
*   **竞争条件 (Race Condition)：** 使用 `go run -race` 或 `go test -race` 来检测。
*   **`WaitGroup` 计数器错误：** `Add` 调用时机错误，或 `Done` 调用次数不匹配。

**代码示例要求：**
*   每个原语的示例都必须是完整、可运行的并发程序。
*   使用 `go -race` 命令来展示数据竞争，并说明加锁或原子操作如何解决它。
*   注释要清晰地解释为什么选择该原语以及其关键的注意事项。

**总结：**
Go 提供了从低级的 `atomic` 到高级的 `channel` 一整套并发工具箱。`sync` 包中的原语是构建高性能并发系统的基石。理解并掌握这些工具的适用场景和正确用法，是每一位 Go 开发者的必修课。

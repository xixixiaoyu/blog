
# AI 大模型提示词

## 任务

你是一位在微服务和可观测性领域有深厚积累的 Go 专家。请撰写一篇关于“在 Go 中使用 OpenTelemetry (OTel) 实现分布式追踪”的权威指南。

## 文章目标

本文旨在引导 Go 开发者全面掌握 OpenTelemetry 的核心概念，并能在一个真实的 Go 微服务环境中，从零开始搭建一套完整的分布式追踪系统。读者将学会如何初始化 OTel SDK、手动和自动植入探针（instrumentation）、以及如何在服务间传播追踪上下文。

## 核心内容

### 1. OpenTelemetry 与分布式追踪入门

- **回顾分布式追踪**：简要重申分布式追踪的价值——在微服务架构中，可视化请求的完整调用链，快速定位故障和性能瓶颈。
- **OTel 核心概念**：
    - **Trace**: 一个完整的请求链路，由一个或多个 Span 组成。
    - **Span**: 调用链中的一个基本工作单元（如一次 HTTP 请求、一次数据库查询）。解释 Span 的父子关系、TraceID 和 SpanID。
    - **Trace Context**: 在服务间传递的元数据（TraceID, SpanID 等），用于将分属不同服务的 Span 串联起来。解释其载体（Carrier），如 HTTP Headers。
    - **Instrumentation**: 为代码添加追踪逻辑（即创建和管理 Span）的过程。

### 2. 搭建 OTel Go SDK

- **OTel 的组件化设计**：解释 OTel Go SDK 的几个关键部分是如何协同工作的：
    - **TracerProvider**: 创建和管理 `Tracer` 的工厂。
    - **Exporter**: 负责将追踪数据发送到后端。重点介绍 OTLP (OpenTelemetry Protocol) Exporter，因为它是厂商中立的标准方案。
    - **Span Processor**: 在 Span 导出前进行处理。介绍 `BatchSpanProcessor`（推荐用于生产环境）和 `SimpleSpanProcessor`（用于调试）。
    - **Propagator**: 负责在网络边界注入（Inject）和提取（Extract）Trace Context。介绍 `W3C Trace Context` 是目前的标准。
- **初始化流程**：提供一段清晰的、带有详尽注释的 Go 代码，演示在一个 `main` 函数中如何：
    1. 创建一个 Exporter（例如，导出到标准输出或 OTLP Collector）。
    2. 创建一个 TracerProvider，并配置好 Span Processor。
    3. 将创建的 TracerProvider 注册为全局 Provider。
    4. 设置全局的 Propagator。
    5. **重点**：解释如何优雅地处理应用的关闭（Shutdown），确保所有缓存的 Span 都能被成功导出。

### 3. 手动与自动植入探针 (Instrumentation)

- **手动创建 Span**：
    - 演示如何从全局 Provider 获取一个 `Tracer`。
    - 如何使用 `tracer.Start(ctx, "span-name")` 来创建一个新的 Span。
    - **强调 `context.Context` 的核心地位**：解释 Span 是如何通过 `context` 来传递的，以及 `defer span.End()` 的重要性。
- **丰富你的 Span**：
    - **Attributes**: 如何使用 `span.SetAttributes(key.String("my-key", "my-value"))` 为 Span 添加键值对属性，提供更多上下文信息。
    - **Events**: 如何使用 `span.AddEvent("event-name")` 记录 Span生命周期内的特定事件。
    - **Status & Errors**: 演示记录操作成功或失败状态的正确方式，特别是如何使用 `span.RecordError(err)` 和 `span.SetStatus(codes.Error, err.Error())` 来标记一个错误的 Span。
- **自动植入：`contrib` 库**：
    - 强调“不要重复造轮子”，优先使用 `go.opentelemetry.io/contrib` 中提供的官方或社区贡献的 instrumentation 库。
    - **HTTP**: 详细演示如何使用 `otelhttp` 包来包裹 `http.Client` 和 `http.Handler`，实现 HTTP 客户端和服务端的全自动追踪。
    - **gRPC**: 简要介绍 `otelgrpc` 的用法。
    - **Database**: 介绍 `otelsql` 如何与 `database/sql` 集成，自动追踪 SQL 查询。

### 4. 跨服务上下文传播实战

- 设计一个场景：服务 A (Client) 调用服务 B (Server)。
- **服务 A**：创建一个父 Span，然后使用被 `otelhttp` 包裹的 `http.Client` 向服务 B 发起请求。解释 OTel Propagator 是如何自动将 Trace Context 注入到 HTTP Headers 中的。
- **服务 B**：使用 `otelhttp.NewHandler` 包裹其 `http.Handler`。解释 OTel Propagator 是如何自动从请求头中提取 Trace Context，并创建一个与服务 A 的 Span 相关联的子 Span。

## 代码与环境要求

- **提供一个完整的、基于 Docker Compose 的多服务项目**：
    - **`docker-compose.yml`**：
        - `service-a`: Go 编写的客户端服务。
        - `service-b`: Go 编写的服务端服务。
        - `otel-collector`: 官方的 OpenTelemetry Collector，配置为接收 OTLP 数据，并将其导出到 Jaeger。
        - `jaeger`: Jaeger All-in-one 用于存储和可视化追踪数据。
    - **`service-a` 代码**：
        - 初始化 OTel SDK，使用 OTLP Exporter。
        - 创建一个 Tracer，开启一个父 Span。
        - 使用 `otelhttp` 客户端向 `service-b` 发送请求。
    - **`service-b` 代码**：
        - 初始化 OTel SDK，使用 OTLP Exporter。
        - 使用 `otelhttp` 中间件包裹其 HTTP 处理器。
        - 在处理器内部，可以再手动创建一个子 Span，模拟一次数据库查询或业务处理。
- **提供 OTel Collector 的配置文件 (`otel-collector-config.yaml`)**，清晰地定义 `receivers`, `processors`, `exporters`, 和 `service` pipeline。
- **代码注释**：所有代码必须有清晰的注释，解释每一步的目的。
- **运行指南**：提供简单的 `docker-compose up` 命令，并告知用户在浏览器中访问 Jaeger UI 的地址，以查看生成的分布式追踪火焰图。

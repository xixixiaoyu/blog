
# AI 大模型提示词

## 任务

你是一位资深的 Go 开发者和监控专家。请撰写一篇关于“在 Go 应用中集成 Prometheus”的实战指南。

## 文章目标

本文旨在为 Go 开发者提供一个从入门到进阶的 Prometheus 集成教程。读者将学会如何在 Go 应用中定义、暴露和使用 Prometheus 的核心指标类型，并掌握相关的最佳实践和常见问题的解决方案。

## 核心内容

### 1. Prometheus 集成入门

- **基本流程**：概述在 Go 应用中集成 Prometheus 的三个核心步骤：
    1. 定义你想要追踪的指标（Metrics）。
    2. 通过 `prometheus/client_golang` 库注册这些指标。
    3. 暴露一个 HTTP 端点（通常是 `/metrics`），供 Prometheus Server前来抓取（Scrape）。
- **Hello, Prometheus!**：提供一个最简单的 Go 程序，该程序仅暴露一个静态的 Counter 指标，并解释如何通过 `promhttp.Handler` 快速启动一个 `/metrics` 服务。

### 2. 深入理解 Prometheus 指标类型

为以下四种核心指标类型，分别提供详细解释、Go 中的定义方法、使用场景和代码示例：

- **Counter (计数器)**：
    - **用途**：只增不减的累积量，如总请求数、任务完成数。
    - **Go 实现**：`prometheus.NewCounter` 和 `prometheus.NewCounterVec`。
    - **操作**：`Inc()`、`Add(float64)`。

- **Gauge (仪表盘)**：
    - **用途**：可任意变化的瞬时值，如当前在处理的请求数、Goroutine 数量、CPU 温度。
    - **Go 实现**：`prometheus.NewGauge` 和 `prometheus.NewGaugeVec`。
    - **操作**：`Set(float64)`、`Inc()`、`Dec()`、`Add(float64)`、`Sub(float64)`。

- **Histogram (直方图)**：
    - **用途**：对观察值（如请求延迟、响应大小）进行分组统计，形成分布图。特别适合计算分位数（Quantile）和 Apdex score。
    - **Go 实现**：`prometheus.NewHistogram` 和 `prometheus.NewHistogramVec`。
    - **核心概念**：解释“桶（Buckets）”的概念，以及如何通过 `prometheus.LinearBuckets` 或 `prometheus.ExponentialBuckets` 定义它们。
    - **操作**：`Observe(float64)`。
    - **产出**：说明一个 Histogram 会自动产生三个指标：`<basename>_bucket{le="..."}`、`<basename>_sum` 和 `<basename>_count`。

- **Summary (摘要)**：
    - **用途**：与 Histogram 类似，也用于观察值的分布，但它直接在客户端计算分位数。
    - **Go 实现**：`prometheus.NewSummary` 和 `prometheus.NewSummaryVec`。
    - **核心概念**：解释 `Objectives`（目标分位数和允许的误差）。
    - **与 Histogram 的对比**：强调 Summary 的分位数计算更精确，但其结果在 Prometheus Server 端难以聚合，且客户端开销更大。而 Histogram 更易于聚合和存储。

### 3. 标签（Labels）：Prometheus 的精髓

- **为什么需要标签**：解释标签如何为指标提供多维度视角，是 Prometheus 强大的查询能力的基础。
- **`*Vec` 类型**：详细说明 `CounterVec`, `GaugeVec`, `HistogramVec`, `SummaryVec` 的作用。
- **实战**：提供一个 `http_requests_total` 的 `CounterVec` 示例，其标签包括 `method`、`path` 和 `status_code`。演示如何使用 `.With(prometheus.Labels{...})` 来为特定维度的指标赋值。
- **高基数（High Cardinality）警告**：重点强调“标签基数爆炸”的危险。警告开发者绝对不要使用用户 ID、请求 ID 或其他无限增长的值作为标签，并解释其对性能和存储的毁灭性影响。

### 4. 最佳实践与高级用法

- **HTTP 中间件**：提供一个完整的 Go HTTP 中间件示例，用于自动记录所有 HTTP 请求的延迟（使用 Histogram）和状态码（使用 Counter）。
- **常量标签**：演示如何使用 `prometheus.MustRegister` 结合 `prometheus.NewRegistry` 和 `promhttp.HandlerOpts` 来为所有指标附加常量标签（如 `service_name`, `instance`）。
- **自定义采集器（Collector）**：简要介绍 `prometheus.Collector` 接口，说明何时需要自定义采集器（例如，从其他系统或硬件获取指标），并提供一个简单的实现示例。
- **Pushgateway 的使用**：解释 Pushgateway 的适用场景（用于生命周期短暂的批处理任务），以及为什么它不应该被用作常规的指标推送方案。

## 代码要求

- **提供一个完整的、可运行的 Go 项目**：
    - 该项目应包含一个 Web 服务器。
    - 定义并注册一个 `CounterVec`（统计 HTTP 请求总数和状态码）和一个 `HistogramVec`（统计请求延迟）。
    - 实现一个 HTTP 中间件来采集上述指标。
    - 在 `main` 函数中，设置多个路由，并应用该中间件。
    - 暴露 `/metrics` 端点。
- **提供配套的 `prometheus.yml` 配置文件**，用于指导用户如何配置 Prometheus 来抓取这个 Go 应用的指标。
- **代码注释清晰**，关键部分要解释其作用和设计考虑。

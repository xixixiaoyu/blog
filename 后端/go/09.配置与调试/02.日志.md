# Prompt: Go 结构化日志终极指南：深入 `slog` 与 `Zerolog`

请你扮演一位在可观测性领域有深入研究的 Go 语言专家，撰写一篇关于 Go 结构化日志的终极指南。

这篇文章旨在帮助 Go 开发者从传统的文本日志（`fmt.Println`, `log.Printf`）迈向现代化的结构化日志，并深入理解 Go 1.21+ 新标准库 `log/slog` 的设计哲学与用法，同时与高性能社区库 `Zerolog` 进行对比分析。

## 1. 文章核心目标

- **理念革新**：清晰地阐述什么是结构化日志，以及它为什么对现代云原生应用的可观测性至关重要。
- **`slog` 深度解析**：全面讲解 `log/slog` 的核心组件（`Logger`, `Handler`, `Record`, `Attr`）、API 用法和扩展方式。
- **`Zerolog` 对比**：客观分析高性能日志库 `Zerolog` 的设计特点、优势（零内存分配）和适用场景。
- **实战与选型**：提供在 Gin/Echo 等 Web 框架中集成日志库的最佳实践，并给出明确的技术选型建议。

## 2. 内容结构要求

请按照以下结构组织文章，确保逻辑清晰、内容详实：

### 引言：告别 `fmt.Println`，拥抱结构化日志

- 以一个生动的例子开始：在复杂的生产环境中，通过 grep 和 awk 从海量文本日志中排查问题的痛苦经历。
- 引出结构化日志（Structured Logging）的核心思想：将日志事件记录为机器可读的格式（如 JSON），包含丰富的键值对上下文。
- 强调结构化日志对于日志聚合、查询、告警系统（如 ELK, Loki, Splunk）的价值。

### 一、Go 官方新标准：`log/slog` 全方位指南

- **1. 设计哲学**：解释 `slog` 诞生的背景——为 Go 提供一个官方的、可扩展的结构化日志解决方案。强调其“前端-后端”（Frontend-Backend）分离的设计（`Logger` 为前端，`Handler` 为后端）。

- **2. 核心组件与基础用法**
    - **`Logger`**: 演示如何获取默认 logger 和创建新 logger。
    - **日志级别 (`Level`)**: 介绍 `Debug`, `Info`, `Warn`, `Error` 四个基本级别。
    - **记录日志**: 演示 `slog.Info()`, `slog.Error()` 等方法，并展示如何添加键值对属性（`Attr`）。
    - **代码示例**：
      ```go
      slog.Info("user login success", "user_id", 123, "ip_address", "192.168.1.1")
      ```

- **3. `Handler`：定制日志的输出与格式**
    - **`TextHandler`**: 演示如何创建和使用，输出人类可读的 `key=value` 格式日志。
    - **`JSONHandler`**: 演示如何创建和使用，输出机器友好的 JSON 格式日志。
    - **自定义 `Handler`**: 简要说明实现 `slog.Handler` 接口可以让你完全控制日志的输出行为（例如，发送到 Kafka、过滤敏感信息）。

- **4. 上下文与性能**
    - **`With` 方法**: 演示如何使用 `logger.With("request_id", "uuid-123")` 创建一个携带固定上下文的子 logger，避免在每次日志调用时重复添加字段。
    - **`Group`**: 演示如何使用 `slog.Group` 将相关的属性组织在一起，使日志结构更清晰。

### 二、社区性能王者：`Zerolog` 深度剖析

- **1. 设计哲学**：介绍 `Zerolog` 的核心目标——提供一个零内存分配（zero-allocation）的高性能日志库。

- **2. 核心用法与链式 API**
    - 演示 `Zerolog` 独特的链式 API 设计。
    - **代码示例**：
      ```go
      import "github.com/rs/zerolog/log"

      log.Info().Str("service", "my-service").Int("user_id", 123).Msg("User logged in")
      ```
    - 解释这种设计如何通过 `sync.Pool` 和避免 `interface{}` 来实现极致性能。

- **3. 与 `slog` 的对比**
    - **性能**：明确指出 `Zerolog` 在原始性能上通常优于 `slog` 的默认 `Handler`。
    - **API 风格**：对比 `slog` 的可变参数 `(key, value, ...)` 风格和 `Zerolog` 的链式 `.` 调用风格。
    - **标准化**：强调 `slog` 作为标准库的优势——生态整合会越来越好，无需引入第三方依赖即可获得结构化日志能力。

### 三、实战：在 Web 框架中集成日志

- **目标**：为每个进入的 HTTP 请求创建一个包含唯一 `request_id` 的 logger，并将该 logger 注入到 `context.Context` 中，以便在业务逻辑的任何地方都能方便地调用。

- **`slog` + Gin/Echo 集成示例**
    - 编写一个日志中间件（Middleware）。
    - 在中间件中，从请求头获取或生成一个 `request_id`。
    - 使用 `logger.With("request_id", ...)` 创建一个子 logger。
    - 将新的 logger 实例存入请求的 `context` 中。
    - 在后续的 handler 中，从 `context` 取出 logger 并使用。

- **`Zerolog` + Gin/Echo 集成示例**
    - 展示使用 `Zerolog` 实现类似功能的中间件，并对比其 API 写法。

### 四、技术选型与最佳实践

- **选型建议**：
    - **新项目/追求标准化**：强烈推荐 `log/slog`。作为官方标准，它能确保长期的稳定性和生态兼容性。
    - **极致性能敏感场景**：对于需要处理海量日志且性能是首要考虑因素的应用，`Zerolog` 或 `Zap` 仍然是顶级选择。
    - **已有项目**：如果项目中已经深度使用了 `Zerolog` 或 `Zap`，并且没有遇到性能或维护问题，可以暂时保持现状。

- **最佳实践总结**：
    - **统一日志格式**：在整个团队和所有服务中约定统一的日志格式和关键字段（如 `service_name`, `request_id`, `user_id`）。
    - **善用日志级别**：`Debug` 用于开发，`Info` 用于关键业务事件，`Warn` 用于可恢复的异常，`Error` 用于需要立即关注的问题。
    - **不要记录敏感信息**：确保对密码、Token、个人身份信息等进行脱敏处理。
    - **日志是给机器读的**：始终以方便后续的自动化分析为目标来设计日志内容。

### 结论

- 总结从 `fmt.Println` 到 `slog`/`Zerolog` 的演进是 Go 开发成熟度的体现。
- 鼓励读者在项目中实践结构化日志，为构建高可观测性的稳健应用打下坚实基础。

## 3. 文章风格要求

- **深入浅出**：能够用简单的语言解释清楚 `slog` 的 `Handler` 机制和 `Zerolog` 的零分配原理。
- **对比客观**：公正地分析 `slog` 和 `Zerolog` 的优缺点，避免带有强烈偏好。
- **实战性强**：提供的 Web 框架集成代码应具有代表性，可以直接用于生产项目。

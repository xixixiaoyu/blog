
# AI Prompt: 使用 Cobra 构建专业级 Go CLI 应用

## 核心目标

你是一位资深的 Go CLI 开发专家，对 Cobra 框架有深入的研究和丰富的实战经验。请撰写一篇关于 Cobra 的“从入门到精通”级别的综合性教程。

本文旨在引导开发者从零开始，利用 Cobra 的核心功能和生态工具，一步步构建一个结构清晰、功能强大、可扩展性强的专业级命令行应用，最终达到能够媲美 `kubectl` 或 `hugo` 等知名工具的水平。

## 内容结构

### 1. 引言：为什么选择 Cobra？
- **Cobra 的定位**：将 Cobra 描述为构建现代 CLI 应用的“事实标准”之一，特别适合需要复杂子命令结构和丰富标志的应用。
- **核心优势**：突出 Cobra 的三大支柱：
  1. **基于组件的结构**：以 `Command` 为核心，易于组织和扩展。
  2. **强大的标志系统**：集成 `pflag`，支持 POSIX 兼容的标志。
  3. **高效的代码生成**：`cobra-cli` 工具能极大提升开发效率。

### 2. 快速启动：`cobra-cli` 初体验
- **安装 `cobra-cli`**：提供 `go install` 命令。
- **初始化项目**：演示如何使用 `cobra-cli init` 创建一个新的项目。分析生成的项目结构，特别是 `main.go` 和 `cmd/root.go` 的作用。
- **添加新命令**：演示如何使用 `cobra-cli add` 添加一个新的子命令（例如 `greet`），并解释新生成的 `cmd/greet.go` 文件。
- **运行你的第一个应用**：展示如何编译和运行这个应用，并看到自动生成的帮助信息。

### 3. Cobra 核心概念深度剖析
- **`Command` 结构体**：详细解释 `cobra.Command` 的关键字段：
  - `Use`：命令的名称和用法，例如 `greet [name]`。
  - `Short` & `Long`：帮助信息中的短描述和长描述。
  - `Run` / `RunE`：命令的执行函数。**强调 `RunE` 的优势**，因为它可以返回 `error`，便于进行更优雅的错误处理。
  - `Args`：内置的参数验证器，例如 `cobra.ExactArgs(1)` (必须有1个参数), `cobra.MinimumNArgs(1)` (至少1个参数)。

- **标志 (Flags) 系统**：
  - **本地标志 (Local Flags)**：只对当前命令有效的标志。演示如何使用 `cmd.Flags().StringVarP()` 等方法定义一个本地标志（例如 `--name` / `-n`）。
  - **持久化标志 (Persistent Flags)**：对当前命令及其所有子命令都有效的标志。演示如何使用 `cmd.PersistentFlags().BoolVarP()` 定义一个全局标志（例如 `--verbose`）。
  - **获取标志的值**：在 `RunE` 函数中，展示如何从变量中读取解析后的标志值。
  - **将标志绑定到 Viper**：这是 Cobra 的一个强大功能，后续章节会详细介绍。

### 4. 实战：构建一个多功能 `todo` CLI 工具
通过构建一个 `todo` 应用，将所有概念串联起来。

- **项目规划**：
  - `todo add "buy milk"`：添加一个任务。
  - `todo list`：列出所有任务。
  - `todo complete 1`：将 ID 为 1 的任务标记为完成。
  - `todo rm 1`：删除 ID 为 1 的任务。

- **实现步骤**：
  1. **`cobra-cli init todo`**：初始化项目。
  2. **`cobra-cli add add`**, **`cobra-cli add list`**, etc.：创建各个子命令。
  3. **实现 `add` 命令**：使用 `cobra.ExactArgs(1)` 验证参数，并将任务保存到文件（例如 `tasks.json`）。
  4. **实现 `list` 命令**：从文件中读取任务并打印。可以添加一个 `--all` / `-a` 标志来显示已完成的任务。
  5. **实现 `complete` 和 `rm` 命令**：接收任务 ID 作为参数，并更新任务状态或删除任务。

### 5. 进阶：与 Viper 集成，实现专业级配置管理
- **Viper 简介**：简要介绍 Viper 是一个功能强大的配置解决方案，支持多种格式（JSON, TOML, YAML）、环境变量、远程配置等。
- **集成的优势**：解释 Cobra + Viper 组合的威力——让 CLI 的配置变得极其灵活。
- **实现步骤**：
  1. **定义配置文件**：在 `root.go` 的 `init` 函数中，使用 `viper.SetDefault`, `viper.SetConfigName`, `viper.AddConfigPath` 来配置 Viper。
  2. **绑定标志**：在定义标志时，使用 `viper.BindPFlag()` 将 Cobra 的标志与 Viper 的配置键绑定。例如，`viper.BindPFlag("author", rootCmd.PersistentFlags().Lookup("author"))`。
  3. **读取配置**：在 `RunE` 函数中，直接使用 `viper.GetString("author")` 来获取配置值。Viper 会自动按照 **标志 > 配置文件 > 默认值** 的优先级来解析。
- **代码示例**：为 `todo` 应用添加一个配置文件 `~/.todo.yaml`，用于设置默认的作者信息或数据文件路径。

### 6. 总结与最佳实践
- **结构化你的命令**：遵循 `cmd/` 目录结构，保持代码清晰。
- **优先使用 `RunE`**：让错误处理更简单。
- **善用 `cobra-cli`**：让它为你处理样板代码。
- **拥抱 Viper**：为你的应用提供灵活的配置能力。
- **编写好的帮助信息**：`Short` 和 `Long` 描述是给用户最好的文档。

## 代码要求
- 所有代码片段，特别是 `todo` 应用的示例，都应该是完整、可运行的。
- 清晰地展示 `cobra-cli` 的使用命令和生成的代码结构。
- 提供 `~/.todo.yaml` 配置文件的示例内容。

## 文章风格
- **教程风格**：手把手、一步步地引导读者完成一个真实的项目。
- **注重实践**：以构建 `todo` 应用为主线，而不是罗列枯燥的 API。
- **清晰的逻辑**：从基础概念到高级集成，层层递进，结构分明。


# AI Prompt: `urfave/cli` - 体验 Go CLI 开发的极简之美

## 核心目标

你是一位信奉“少即是多”的 Go 语言开发专家，擅长使用轻量级工具快速构建高效的应用。请撰写一篇关于 `urfave/cli` (v2) 框架的实战教程。

本文旨在向开发者展示 `urfave/cli` 如何通过其简洁、直观的 API，在无需代码生成器和复杂目录结构的情况下，快速构建功能完善、易于维护的命令行工具。

## 内容结构

### 1. 引言：CLI 开发的“轻骑兵”
- **`urfave/cli` 的哲学**：将 `urfave/cli` 定位为一个追求“大道至简”的框架。它不提供代码生成，也不强制项目结构，而是通过一个声明式的 API，让你在一个地方就能定义整个应用。
- **核心优势**：突出其三大特点：
  1. **零依赖（或极少依赖）**：保持你的应用体积小巧。
  2. **上手极快**：API 直观，学习曲线平缓，几分钟内就能构建出第一个应用。
  3. **灵活性高**：对项目结构没有限制，可以是一个单文件应用，也可以是大型多文件项目。

### 2. 核心概念：一个 `App`，包罗万象
- **`cli.App` 结构体**：解释 `cli.App` 是整个应用的容器。它的字段（如 `Name`, `Usage`, `Commands`, `Flags`, `Action`）通过切片（Slices）来定义应用的全部行为，一目了然。
- **`cli.Command`**：介绍命令的定义，它也是一个结构体，包含 `Name`, `Usage`, `Action`, `Flags` 等字段。子命令就是 `Commands` 切片中的一个元素。
- **`cli.Flag`**：介绍各种标志类型（`StringFlag`, `IntFlag`, `BoolFlag`），以及如何定义它们的名称、别名 (`Aliases`)、默认值 (`Value`) 和用途说明 (`Usage`)。
- **`*cli.Context`**：这是 `urfave/cli` 的“瑞士军刀”。解释 `Action` 函数接收的 `*cli.Context` 参数，它封装了所有解析后的上下文信息，如获取标志的值 (`c.String("flag-name")`)、获取参数 (`c.Args().First()`) 等。

### 3. 实战：在 100 行代码内构建一个 `todo` 应用
通过在一个 `main.go` 文件中构建一个完整的 `todo` 应用，来淋漓尽致地展现 `urfave/cli` 的简洁之美。

- **应用骨架**：
  ```go
  package main

  import (
      "log"
      "os"

      "github.com/urfave/cli/v2"
  )

  func main() {
      app := &cli.App{
          Name:  "todo",
          Usage: "一个简单的待办事项管理工具",
          // 在这里定义命令和标志
      }

      if err := app.Run(os.Args); err != nil {
          log.Fatal(err)
      }
  }
  ```

- **定义全局标志**：在 `app.Flags` 中定义一个全局标志，例如 `--file` / `-f`，用于指定存储 `todo` 任务的数据文件路径。

- **实现 `add` 命令**：
  - 在 `app.Commands` 切片中添加一个 `cli.Command`。
  - `Name`: `"add"`
  - `Usage`: `"添加一个新的任务"`
  - `Action`: 一个函数，接收 `*cli.Context`。在该函数中，使用 `c.Args().First()` 获取任务内容，然后将其追加到由全局标志 `--file` 指定的文件中。

- **实现 `list` 命令**：
  - 添加另一个 `cli.Command` 到 `app.Commands`。
  - `Name`: `"list"`
  - `Usage`: `"列出所有任务"`
  - `Action`: 读取并打印任务文件中的所有行。
  - **添加本地标志**：在 `list` 命令的 `Flags` 切片中添加一个 `--completed` 标志，用于筛选已完成的任务（此功能作为练习，可以在实现时简化）。

- **实现 `complete` 命令**：
  - 添加 `complete` 命令。
  - `Usage`: `"complete [任务索引]"`
  - `Action`: 读取任务文件，将指定索引的任务标记为完成（例如，在行首添加 `[x]`），然后写回文件。

### 4. `urfave/cli` 的一些技巧
- **参数处理**：展示如何使用 `c.Args().Get(i)`、`c.Args().Slice()`、`c.NArg()` 来灵活处理命令行参数。
- **子命令的子命令**：简要说明如何通过在 `cli.Command` 中嵌套 `Subcommands` 切片来实现多层级的命令结构。
- **`Before` 钩子**：演示如何使用 `app.Before` 或 `command.Before` 钩子函数来执行一些预处理逻辑，例如检查配置文件是否存在或初始化数据库连接。

### 5. 结论：简单就是力量
- **回顾 `urfave/cli` 的优势**：快速、简洁、灵活。
- **与 Cobra 的对比思考**：不直接进行功能对比，而是引导读者思考两种不同的开发哲学。Cobra 提供了“脚手架”和“约定”，而 `urfave/cli` 提供了“积木”和“自由”。
- **选型建议**：对于中小型工具、个人项目或追求极致简洁和快速原型验证的场景，`urfave/cli` 是一个无与伦比的选择。

## 代码要求
- **单文件实现**：整个 `todo` 应用的核心逻辑应尽可能地放在一个 `main.go` 文件中，以凸显框架的简洁性。
- **代码完整可运行**：提供完整的 `main` 函数和所有必要的导入。
- **注释清晰**：解释每个命令和标志的定义，以及 `Action` 函数中的逻辑。

## 文章风格
- **轻快、直接**：语言风格应与其框架的特点保持一致，直奔主题。
- **强调对比**：通过代码本身的简洁性，与读者心中可能存在的其他框架（如 Cobra）的印象形成对比。
- **赋能读者**：让读者在读完文章后，有信心在几分钟内就能用 `urfave/cli` 构建出自己的工具。

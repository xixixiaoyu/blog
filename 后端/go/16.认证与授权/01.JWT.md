
# AI 大模型提示词

## 任务

你是一位精通 Go 语言和网络安全的资深工程师。请撰写一篇关于“在 Go 中从零实现 JWT (JSON Web Token) 认证”的深度实战指南。

## 文章目标

本文旨在为 Go 开发者提供一个完整、安全、可用于生产的 JWT 认证实现方案。读者将学习 JWT 的内部结构、如何使用 `golang-jwt/jwt` 库生成和验证 Token，如何构建安全的认证中间件，以及如何处理 Token 刷新和吊销等高级主题。

## 核心内容

### 1. JWT 结构解析

- **回顾 JWT**：简要重申 JWT 是一个紧凑、自包含的字符串，由三部分组成，用 `.` 分隔。
- **Header (头部)**：包含 `alg` (签名算法, 如 `HS256`) 和 `typ` (类型, 固定为 `JWT`)。强调 `alg` 的重要性。
- **Payload (载荷)**：包含 Token 的实际数据，称为“声明 (Claims)”。
    - **Registered Claims (标准声明)**：介绍 `iss` (签发者), `sub` (主题), `aud` (受众), `exp` (过期时间), `nbf` (生效时间), `iat` (签发时间), `jti` (唯一标识)。重点讲解 `exp` 的必要性。
    - **Custom Claims (自定义声明)**：演示如何添加应用所需的自定义字段，如 `user_id`, `role` 等。
- **Signature (签名)**：
    - **作用**：用于验证 Token 的发送者和确保消息在传输过程中未被篡改。**强调：签名只保证完整性，不保证机密性（Payload 是 Base64 编码，不是加密）**。
    - **生成方式**：解释签名是如何通过 `HMAC(Base64(Header) + "." + Base64(Payload), secret)` 生成的。

### 2. 使用 `golang-jwt/jwt` 实战

- **引入库**：介绍 `github.com/golang-jwt/jwt/v5` 是 Go 社区的事实标准。
- **生成 Token**：
    1. **定义 Claims 结构体**：创建一个 Go 结构体，嵌入 `jwt.RegisteredClaims` 并添加自定义字段。
    2. **实例化 Claims**：设置过期时间 (`exp`) 和其他必要字段。
    3. **创建 Token 对象**：使用 `jwt.NewWithClaims(jwt.SigningMethodHS256, claims)` 创建一个 Token。
    4. **签名**：使用 `token.SignedString([]byte(secret))` 生成最终的 Token 字符串。提供完整的函数代码示例。
- **解析与验证 Token**：
    1. **核心函数 `jwt.ParseWithClaims`**：这是验证 Token 的关键。
    2. **提供 `Keyfunc`**：解释 `Keyfunc` 的作用是向库提供用于验证签名的密钥。**安全重点**：在 `Keyfunc` 中，必须严格校验 `token.Method` 是否为预期的签名算法（如 `*jwt.SigningMethodHMAC`），以防止“算法置空 (`alg: none`)”攻击。
    3. **错误处理**：演示如何检查 `jwt.ParseWithClaims` 返回的错误，特别是如何区分 `jwt.ErrTokenExpired`、`jwt.ErrTokenMalformed` 等不同类型的错误。
    4. **获取 Claims**：如果 Token 有效，演示如何从解析后的 `token.Claims` 中安全地断言出自已定义的 Claims 结构体，并获取其中的数据。

### 3. 构建认证中间件 (Middleware)

- **设计思路**：中间件是保护需要认证的路由的理想方式。
- **实现步骤**：
    1. 编写一个 `func(http.Handler) http.Handler` 形式的中间件。
    2. 从请求头 `Authorization` 中提取 Token。格式应为 `Bearer <token>`。
    3. 调用前面编写的 Token 解析函数进行验证。
    4. **如果验证成功**：从 Claims 中提取用户信息（如 `user_id`），然后通过 `context.WithValue` 将其存入请求的 `context` 中，以便后续的 Handler 使用。调用 `next.ServeHTTP(w, r)` 继续处理请求。
    5. **如果验证失败**（Token 不存在、格式错误、过期、签名无效等）：立即返回 `401 Unauthorized` 响应，并终止请求链。

### 4. 完整认证流程与高级主题

- **实现 `/login` 接口**：接收用户名和密码，验证通过后，调用 Token 生成函数，返回 Token。
- **实现受保护接口**：例如 `/api/profile`，应用上述中间件。在 Handler 内部，从 `r.Context()` 中取出用户信息并返回。
- **Access Token 与 Refresh Token 策略**：
    - **解决什么问题**：`access_token` 的有效期通常很短（如 15 分钟），过期后如何让用户无感刷新？
    - **流程**：登录时，同时签发一个短期的 `access_token` 和一个长期的 `refresh_token`（如 7 天）。`access_token` 放在 Header 中，`refresh_token` 存储在安全的 `HttpOnly` Cookie 中。
    - **实现 `/refresh_token` 接口**：此接口接收 `refresh_token`，验证其有效性后，签发一个新的 `access_token`。
- **Token 吊销（黑名单机制）**：
    - **解决什么问题**：用户登出或修改密码后，如何让其旧 Token 立刻失效？
    - **实现思路**：使用 Redis 等高速缓存。当 Token 需要被吊销时，将其 `jti` (JWT ID) 存入 Redis 并设置其过期时间为 Token 的 `exp`。在认证中间件中，增加一步检查：`jti` 是否存在于 Redis 黑名单中。

## 代码要求

- **提供一个完整的、可运行的 Go Web 服务器代码文件**。
- **功能完备**：实现 `/login` 接口、JWT 认证中间件、一个受中间件保护的 `/api/profile` 接口，以及一个 `/refresh_token` 接口。
- **安全最佳实践**：
    - 密钥从环境变量读取，而不是硬编码。
    - 在 `Keyfunc` 中严格检查签名算法。
    - 使用 `HttpOnly` Cookie 存储 Refresh Token。
- **注释详尽**：对 JWT 生成、解析、中间件逻辑、Context 传递等关键部分进行详细注释。


# AI 大模型提示词

## 任务

你是一位资深的 Go Web 开发者，对 OAuth 2.0 和 OpenID Connect (OIDC) 有深入的理解和丰富的实战经验。请撰写一篇关于“在 Go 中实现 OAuth 2.0 客户端”的实践指南。

## 文章目标

本文旨在教会 Go 开发者如何使用官方的 `golang.org/x/oauth2` 包，完整地实现一个 OAuth 2.0 客户端，让用户可以通过第三方服务（如 Google 或 GitHub）登录自己的应用。文章将重点讲解最常用且最安全的“授权码授权流程 (Authorization Code Grant Flow)”。

## 核心内容

### 1. OAuth 2.0 授权码流程解析

- **回顾角色**：再次明确四个角色：资源所有者（用户）、客户端（我们的 Go 应用）、授权服务器（如 Google）、资源服务器（如 Google API）。
- **图解授权流程**：使用流程图或清晰的步骤，详细拆解“授权码”模式的每一步：
    1. **用户发起授权请求**：我们的 Go 应用将用户重定向到授权服务器的特定 URL。这个 URL 包含了 `client_id`、`redirect_uri`、`scope`、`state` 和 `response_type=code` 等参数。
    2. **用户授权**：用户在授权服务器的页面上登录，并同意授权我们的应用访问其指定 `scope` 的信息。
    3. **返回授权码**：授权服务器将用户重定向回我们应用预先注册的 `redirect_uri`，并在 URL 参数中附带一个临时的 `code` 和之前我们发送的 `state`。
    4. **交换授权码获取 Access Token**：我们应用的**后端**收到 `code` 后，向授权服务器的 Token 端点发起一个 POST 请求，用 `code`、`client_id` 和 `client_secret` 换取 `access_token` 和 `refresh_token`。
    5. **访问受保护资源**：我们的应用使用 `access_token` 向资源服务器请求用户信息（如昵称、头像等）。
    6. **完成登录**：获取到用户信息后，我们可以在自己的系统中为该用户创建会话或颁发自己的 JWT，完成登录流程。

### 2. 使用 `golang.org/x/oauth2` 实战

- **准备工作**：指导用户去一个 OAuth 2.0 提供商（推荐 GitHub 或 Google）的开发者设置中创建一个新的 OAuth App，以获取 `Client ID` 和 `Client Secret`，并配置好 `Redirect URI`。
- **配置 `oauth2.Config`**：
    - 演示如何初始化一个 `oauth2.Config` 结构体。
    - 解释每个字段的含义：`ClientID`, `ClientSecret`, `RedirectURL`, `Scopes`。
    - 介绍 `Endpoint` 字段，并说明如何使用 `golang.org/x/oauth2` 子包中为常用服务预设的 `Endpoint`，如 `google.Endpoint` 和 `github.Endpoint`。
- **实现登录处理器 (`/login`)**：
    - **生成 `state`**：强调 `state` 参数用于防止 CSRF 攻击。演示如何生成一个随机字符串作为 `state`，并将其存储在用户的会话中（例如，使用一个有时效的 Cookie）。
    - **生成授权 URL**：调用 `config.AuthCodeURL(state, oauth2.AccessTypeOffline)` 生成需要重定向的目标 URL。
    - **执行重定向**：使用 `http.Redirect` 将用户浏览器重定向到该 URL。
- **实现回调处理器 (`/callback`)**：
    - **验证 `state`**：这是回调处理器的第一步，也是最重要的一步。从 URL 参数中获取 `state`，并与之前存储在会話中的 `state` 进行比较。如果不匹配，必须立即中止操作。
    - **交换 Code 获取 Token**：从 URL 参数中获取 `code`，然后调用 `config.Exchange(r.Context(), code)`。这个函数会完成后台的 POST 请求，返回一个 `*oauth2.Token` 对象。
    - **创建认证的 HTTP Client**：演示如何使用 `config.Client(r.Context(), token)` 创建一个会自动在请求头中添加 `Authorization: Bearer <access_token>` 的 `*http.Client`。
    - **获取用户信息**：使用上一步创建的 `client`，向资源服务器的用户信息 API（如 `https://api.github.com/user`）发起请求，并解析返回的 JSON 数据。
    - **后续操作**：在成功获取用户信息后，可以为用户在自己的系统中创建账号、登录会话，或者颁发自己应用的 JWT，并最终将用户重定向到个人主页。

### 3. 安全注意事项

- **State 的重要性**：再次强调 `state` 参数是防御 CSRF 攻击的关键，必须严格校验。
- **Client Secret 的保密**：`Client Secret` 绝对不能泄露到前端或客户端代码中，它必须只存在于你的后端服务器上。
- **Redirect URI 的精确匹配**：在服务商处注册的回调地址必须是完整的、精确的，不能过于宽泛，以防止“开放重定向”漏洞。

## 代码要求

- **提供一个完整的、可运行的 Go Web 服务器代码文件**。
- **选择一个具体服务商**：以“通过 GitHub 登录”为例进行完整实现。
- **功能完备**：
    - `/`：一个简单的首页，包含“使用 GitHub 登录”的链接。
    - `/login/github`：处理登录请求，将用户重定向到 GitHub。
    - `/github/callback`：处理 GitHub 的回调，完成整个 OAuth 2.0 流程，并最终显示获取到的用户 GitHub 用户名和头像。
- **环境变量**：要求 `GITHUB_CLIENT_ID` 和 `GITHUB_CLIENT_SECRET` 通过环境变量传入，而不是硬编码在代码里。
- **会话管理**：使用一个简单的、基于 Cookie 的会话来存储 `state` 值。
- **注释详尽**：对 OAuth 2.0 流程的每一步，特别是安全相关的部分（如 `state` 校验），进行详细的注释。

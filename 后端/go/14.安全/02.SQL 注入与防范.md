
# AI 大模型提示词

## 任务

你是一位专业的 Go 开发者和网络安全专家。请撰写一篇关于“在 Go 中防范 SQL 注入”的深度技术文章。

## 文章目标

本文旨在帮助 Go 开发者深入理解 SQL 注入的原理、危害，并掌握在 Go 语言环境中，特别是使用标准库 `database/sql` 和流行 ORM 框架 GORM 时，如何有效防范 SQL 注入攻击。

## 核心内容

### 1. SQL 注入：原理与危害

- **定义**：解释什么是 SQL 注入。说明攻击者如何通过在输入字段中插入恶意的 SQL 代码，欺骗服务器执行非预期的数据库操作。
- **示例**：提供一个经典的、语言无关的 SQL 注入示例，例如通过用户登录 `username = 'admin' --` 来绕过密码验证。
- **危害**：阐述 SQL 注入可能导致的严重后果，包括数据泄露、数据篡改、数据丢失、服务器被完全控制等。

### 2. Go 与 SQL 注入：为何不能掉以轻心

- 澄清一个误区：Go 的强类型和内存安全特性并不能自动防御所有类型的安全漏洞。
- 指出问题根源：当开发者使用字符串拼接（`fmt.Sprintf`）的方式构建 SQL 查询时，就为 SQL 注入打开了大门。

### 3. Go 中的 SQL 注入防范黄金法则

#### 3.1. 使用 `database/sql` 进行参数化查询

- **核心原则**：强调永远不要信任用户输入，必须将 SQL 查询结构与用户提供的数据分离。
- **正确实践**：
    - 详细解释如何使用 `?`（MySQL, SQLite）或 `$1`, `$2`（PostgreSQL）作为查询参数占位符。
    - 演示 `db.QueryContext`、`db.QueryRowContext` 和 `db.ExecContext` 等函数的正确用法。
    - 解释 `database/sql` 驱动在底层如何安全地处理这些参数，避免它们被解释为 SQL 代码。
- **错误示范**：提供一个使用 `fmt.Sprintf` 拼接 SQL 字符串的反面教材，并分析其脆弱性。

#### 3.2. 使用 GORM 等 ORM 框架

- **GORM 的内置防御**：
    - 解释 GORM 的链式 API（如 `db.Where("name = ?", name)`）默认会生成参数化的 SQL 查询，从而天然地防御 SQL 注入。
    - 提供使用 GORM 进行安全查询的示例。
- **GORM 中的风险点**：
    - 警示用户，即使使用 GORM，如果采用不当的查询方式（如 `db.Where(fmt.Sprintf("name = '%s'", name))`），风险依然存在。
    - 强调应始终使用 GORM 推荐的参数化查询方式。

#### 3.3. 处理动态 `IN` 查询

- **常见难题**：`IN` 子句中的参数数量是动态的，这使得直接使用占位符变得困难。
- **安全解决方案**：
    - 演示如何动态构建占位符字符串（例如 `IN (?, ?, ?)`）。
    - 展示如何将一个切片（slice）安全地传递给 `Exec` 或 `Query` 方法作为参数。
    - 可以引用 `sqlx` 库的 `sqlx.In` 作为更优雅的解决方案。

## 代码要求

- **清晰对比**：为每个关键知识点提供“不安全”和“安全”的代码片段对比。
- **完整示例**：提供一个完整的、可运行的 Go 程序示例，演示如何连接数据库（可使用 `sqlite3` 以简化依赖），并执行一次安全的查询操作。
- **注释详尽**：在代码中添加关键注释，解释为什么某种写法是安全的，而另一种则不是。

## 总结

- 再次强调在 Go 中防范 SQL 注入的核心是**杜绝字符串拼接，坚持使用参数化查询**。
- 鼓励开发者养成代码审查和使用静态分析工具（如 `gosec`）的习惯，以发现潜在的安全风险。

## 什么是循环依赖？
想象一下，你正在开发一个宠物管理系统。你有一个 `CatsService` 负责处理猫咪相关的业务逻辑，还有一个 `CommonService` 提供通用的工具方法。

正常情况下，`CatsService` 可能需要调用 `CommonService` 的某些方法，这很合理。但如果 `CommonService` 也需要使用 `CatsService` 的功能，问题就来了 —— 它们互相依赖，形成了一个死循环。

类似这种：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749347545967-24767c9d-5c4f-46c4-8b02-bc960e426d50.png)

Nest 的依赖注入系统在启动时需要按顺序创建所有实例，但当 A 需要 B，B 又需要 A 时，系统就不知道该先创建谁了，最终导致应用启动失败。

## 服务间的循环依赖：最常见的情况
### 解决方案 1：使用 forwardRef() 前向引用
这是处理循环依赖最经典的方法。`forwardRef()` 就像给 Nest 发了个信号："这个依赖现在可能还没准备好，你稍后再处理。"

**在 CatsService 中：**

```typescript
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { CommonService } from './common.service';

@Injectable()
export class CatsService {
  constructor(
    @Inject(forwardRef(() => CommonService))
    private commonService: CommonService,
  ) {}

  getCatsWithCommonLogic() {
    // 现在可以安全地调用 commonService 的方法了
    return this.commonService.processData('cats');
  }

  getCatsCount(): number {
    return 666;
  }
}
```

**在 CommonService 中：**

```typescript
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { CatsService } from './cats.service';

@Injectable()
export class CommonService {
  constructor(
    @Inject(forwardRef(() => CatsService))
    private catsService: CatsService,
  ) {}

  processData(type: string) {
    if (type === 'cats') {
      // 可以安全地调用 catsService 的方法
      const catsCount = this.catsService.getCatsCount();
      return `Processing ${catsCount} cats`;
    }
  }
}
```

**重要提醒：**

+ 使用 `forwardRef()` 后，两个服务的构造函数执行顺序是不确定的，所以不要在构造函数中直接调用对方的方法
+ 如果涉及到 `Scope.REQUEST` 作用域的服务，要特别小心，可能会出现依赖项为 `undefined` 的情况

### 解决方案 2：使用 ModuleRef 动态获取
这是一种更灵活的方法，不在构造函数中直接注入循环依赖，而是在需要时动态获取：

```typescript
import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { CommonService } from './common.service';

@Injectable()
export class CatsService {
  constructor(private moduleRef: ModuleRef) {}

  async getCatsWithCommonLogic() {
    // 运行时动态获取 CommonService
    const commonService = this.moduleRef.get(CommonService);
    return commonService.processData('cats');
  }
}
```

这种方法把"启动时解决依赖"变成了"运行时获取依赖"，巧妙地绕过了循环依赖检查。

使用 `ModuleRef` 时，只需要在循环依赖的至少一方使用它来获取另一方的实例，即可打破启动时的依赖注入循环。另一方可以选择常规注入（如果必要，配合 `forwardRef`）或同样使用 `ModuleRef`。



## 模块间的循环依赖：更大范围的纠缠
有时候问题不在服务层面，而是整个模块之间形成了循环引用。比如 `CatsModule` 导入了 `CommonModule`，而 `CommonModule` 又需要导入 `CatsModule`。

**解决方法同样是 forwardRef()：**

**CommonModule：**

```typescript
import { Module, forwardRef } from '@nestjs/common';
import { CatsModule } from './cats.module';
import { CommonService } from './common.service';

@Module({
  imports: [forwardRef(() => CatsModule)],
  providers: [CommonService],
  exports: [CommonService],
})
export class CommonModule {}
```

**CatsModule：**

```typescript
import { Module, forwardRef } from '@nestjs/common';
import { CommonModule } from './common.module';
import { CatsService } from './cats.service';
import { CatsController } from './cats.controller';

@Module({
  imports: [forwardRef(() => CommonModule)],
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
```



## 小心桶文件（index.ts）的陷阱
很多开发者喜欢用 `index.ts` 文件来统一导出模块内的所有类，这确实很方便。但在 Nest 中，这可能无意中造成循环依赖。

**不推荐的做法：**

```typescript
// 在 cats.controller.ts 中
import { CatsService } from './index'; // 通过桶文件导入
```

**推荐的做法：**

```typescript
// 在 cats.controller.ts 中
import { CatsService } from './cats.service'; // 直接导入具体文件
```

直接引用具体文件路径通常更安全，能避免很多意外的循环引用问题。



## 最佳实践与建议
### 1. 优先考虑重构设计
遇到循环依赖时，首先问问自己：

+ 这两个服务真的必须互相了解吗？
+ 能否通过引入第三个服务来解耦？
+ 是否可以调整职责划分？

有时候，一个好的架构设计比技术手段更重要。

### 2. 合理使用 forwardRef()
如果确实无法避免循环依赖，`forwardRef()` 是你的好朋友。它简单易用，适用于大多数场景。

### 3. 考虑使用事件驱动
对于复杂的业务场景，可以考虑使用事件驱动的方式来解耦服务间的直接依赖：

```typescript
// 不直接调用对方的方法，而是发布事件
this.eventEmitter.emit('cats.created', { catId: 123 });
```

### 4. 谨慎处理作用域
如果你的应用中使用了请求作用域（`Scope.REQUEST`），在处理循环依赖时要格外小心，可能需要额外的处理逻辑。

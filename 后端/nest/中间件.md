## 中间件是什么？
简单来说，中间件就像是请求和控制器之间的“门卫”。每次有请求进入你的应用，中间件都会先“检查”一番，决定是放行、修改请求，还是直接处理甚至拒绝。

想象一个场景：你去一家公司拜访，门口的保安会先检查你的证件、记录你的信息，甚至可能直接拒绝你进入。中间件在 Nest 里干的就是类似的事儿。它的核心作用是在请求到达最终的控制器逻辑之前，插入一些处理逻辑。

---

## 中间件能做什么？
中间件的功能非常灵活，几乎可以覆盖请求处理的所有环节。以下是几个常见用途：

1. **记录访问信息**：像日志一样，记录谁访问了你的应用、访问了什么接口、用了多长时间。
2. **检查和修改请求**：比如检查请求头、添加用户信息，或者设置响应头。
3. **决定是否放行**：如果请求不符合要求（比如用户没登录），中间件可以直接返回错误，阻止请求继续往下走。
4. **直接处理请求**：对于一些简单逻辑，中间件可以直接返回响应，不需要麻烦控制器。

⚠️ **关键提醒**：中间件处理完后，如果希望请求继续流转到下一个中间件或控制器，**必须调用 next()**。忘了调用 next()，请求就会卡住，用户只能干等着！

---

## 怎么写中间件？
Nest 提供了两种方式来创建中间件：**类中间件**和**函数中间件**。选择哪种方式，取决于你的需求复杂程度。

### 1. 使用类中间件（适合复杂逻辑）
类中间件适合需要依赖注入或复杂逻辑的场景。Nest 提供了一个 `NestMiddleware` 接口，让你可以轻松实现中间件。

#### 示例：日志记录中间件
```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const start = Date.now();
    res.on('finish', () => {
      const duration = Date.now() - start;
      console.log(`${req.method} ${req.originalUrl} - ${res.statusCode} (${duration}ms)`);
    });
    next(); // 别忘了调用 next！
  }
}
```

**特点**：

+ 使用 `@Injectable()` 装饰器，允许注入其他服务（如数据库服务、配置服务）。
+ 实现 `NestMiddleware` 接口，在 `use` 方法中编写逻辑。
+ 适合需要复杂逻辑或依赖注入的场景。

### 2. 使用函数中间件（适合简单逻辑）
如果逻辑简单，不需要依赖注入，函数中间件会更简洁。

#### 示例：函数式日志中间件
```typescript
import { Request, Response, NextFunction } from 'express';

export function requestLogger(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`${req.method} ${req.originalUrl} - ${res.statusCode} (${duration}ms)`);
  });
  next();
}
```

**特点**：

+ 代码更简洁，适合快速实现简单的中间件。
+ 无法使用依赖注入，适合独立逻辑。

---

## 如何应用中间件？
写好中间件后，你需要告诉 Nest 在哪里使用它。Nest 提供了灵活的方式来控制中间件的应用范围。

### 1. 在模块中应用中间件
通常，我们在模块的 `configure` 方法中配置中间件，指定它作用于哪些路由。

```typescript
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './logger.middleware';

@Module({})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes('users'); // 只对 /users 路由生效
  }
}
```

### 2. 使用路由通配符
Nest 支持通配符，让你可以更灵活地匹配路由。

```typescript
consumer
  .apply(LoggerMiddleware)
  .forRoutes('users/*'); // 匹配 /users 下的所有子路由，如 /users/profile、/users/123
```

或者更广的匹配：

```typescript
consumer
  .apply(LoggerMiddleware)
  .forRoutes('*'); // 匹配所有路由
```

### 3. 全局中间件
如果希望中间件对所有路由生效，可以在 `main.ts` 中设置全局中间件：

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { requestLogger } from './request-logger.middleware';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.use(requestLogger); // 全局应用
  await app.listen(3000);
}
bootstrap();
```

**注意**：

+ 通过 `app.use()` 设置的全局中间件无法使用依赖注入。
+ 如果需要依赖注入，可以在模块中使用 `.forRoutes('*')` 实现类似全局的效果。

---

## 实际应用场景
中间件在实际开发中用途广泛，下面是一些典型案例。

### 1. 身份认证
检查用户是否登录，确保只有合法用户才能访问某些接口。

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class AuthMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const token = req.headers.authorization;
    if (!token) {
      return res.status(401).json({ message: '请先登录' });
    }

    try {
      // 假设有 JWT 验证逻辑
      // const decoded = jwt.verify(token, 'secret');
      // req.user = decoded; // 将用户信息附加到请求对象
      next();
    } catch (error) {
      return res.status(401).json({ message: 'Token 无效' });
    }
  }
}
```

**应用场景**：保护需要登录的 API，比如用户个人资料、订单查询等。

### 2. 请求日志
记录每次请求的详细信息，便于调试和监控。

```typescript
import { Request, Response, NextFunction } from 'express';

export function requestLogger(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`${req.method} ${req.originalUrl} - ${res.statusCode} (${duration}ms)`);
  });
  next();
}
```

**应用场景**：调试开发环境、监控生产环境性能。

### 3. 数据验证
在请求到达控制器前，检查请求体的基本合法性。

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class ValidationMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    if (req.method === 'POST' && !req.body) {
      return res.status(400).json({ message: '请求体不能为空' });
    }
    next();
  }
}
```

**应用场景**：确保 POST 请求包含必要的数据，减轻控制器的负担。

---

## 中间件的注意事项
1. **别忘了 next()**：如果中间件处理完后需要请求继续流转，必须调用 `next()`，否则请求会挂起。
2. **顺序很重要**：中间件的执行顺序取决于配置顺序，先配置的先执行。
3. **全局 vs 局部**：全局中间件适合通用的逻辑（如日志、CORS），而局部中间件更适合特定路由的定制逻辑。
4. **性能考虑**：中间件会增加请求处理时间，避免在中间件中加入过于复杂的逻辑。

---

## 总结
中间件是 Nest.js 中处理请求的利器，它让你的代码更模块化、更易维护。无论是记录日志、验证身份，还是检查请求数据，中间件都能帮你提前处理，减轻控制器的负担。通过类中间件和函数中间件的灵活选择，以及路由通配符和全局配置的强大支持，你可以轻松应对各种开发场景。


## 什么是守卫？
简单来说，守卫是 NestJS 中的一种拦截机制，用来决定某个请求能否访问目标资源。它是一个带有 `@Injectable()` 装饰器的类，实现了 `CanActivate` 接口。守卫的核心任务是检查请求者的权限，比如验证用户是否登录、是否有特定角色，或者是否满足某些条件。

守卫有点像 Express 中的中间件，但它更智能。得益于 NestJS 的 `ExecutionContext`，守卫可以获取当前请求的详细信息，比如 HTTP 请求对象、即将调用的控制器方法，甚至是控制器类本身。这让守卫在权限判断时更加灵活。

---

## 守卫的核心：canActivate 方法
每个守卫都需要实现 `CanActivate` 接口的核心方法 `canActivate()`。这个方法决定了请求能否继续执行，返回值有以下几种可能：

+ `true`：放行，请求继续处理。
+ `false`：拦截，NestJS 默认抛出 403 Forbidden 错误。
+ `Promise<boolean>` 或 `Observable<boolean>`：支持异步逻辑，比如从数据库验证权限。

下面是一个简单的认证守卫示例：

```typescript
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    // 简单检查请求头是否有 authorization
    return !!request.headers.authorization;
  }
}
```

在这个例子中，守卫检查请求头中是否有 `authorization` 字段。如果没有，返回 `false`，请求会被拦截。

---

## ExecutionContext：守卫的“情报官”
`ExecutionContext` 是守卫的强大助手，提供了请求的上下文信息。你可以通过它获取：

+ `context.switchToHttp().getRequest()`：获取 HTTP 请求对象，包含 headers、body、query 等。
+ `context.getHandler()`：获取即将调用的路由处理方法。
+ `context.getClass()`：获取对应的控制器类。

这些信息让守卫能够根据具体场景做出精准的权限判断。比如，你可以检查请求的 headers 是否携带有效的 JWT token，或者根据路由方法动态调整权限逻辑。

---

## 实现基于角色的访问控制（RBAC）
在实际项目中，基于角色的访问控制（Role-Based Access Control, RBAC）是非常常见的需求。比如，只有管理员（admin）才能删除用户，而普通用户（user）只能查看数据。NestJS 提供了便捷的工具来实现这一点，核心是 `@SetMetadata` 和 `Reflector`。

### 步骤 1：创建自定义角色装饰器
我们可以用 `Reflector.createDecorator` 创建一个自定义的 `@Roles` 装饰器，用来标记哪些路由需要特定角色：

```typescript
import { Reflector } from '@nestjs/core';

// 创建自定义装饰器
export const Roles = Reflector.createDecorator<string[]>();
```

### 步骤 2：编写角色守卫
接下来，我们实现一个 `RolesGuard`，通过 `Reflector` 读取 `@Roles` 装饰器设置的元数据，并与用户角色进行比较：

```typescript
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Roles } from './roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    // 获取控制器或方法上设置的角色元数据
    const requiredRoles = this.reflector.get(Roles, context.getHandler());
    if (!requiredRoles) {
      return true; // 如果没有设置角色要求，直接放行
    }

    // 获取请求中的用户信息
    const request = context.switchToHttp().getRequest();
    const user = request.user; // 假设 user 已通过其他中间件设置

    // 检查用户角色是否匹配
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}
```

### 步骤 3：在控制器中使用
在需要权限控制的路由上应用 `@Roles` 装饰器和 `RolesGuard`：

```typescript
import { Controller, Get, UseGuards } from '@nestjs/common';
import { RolesGuard, Roles } from './roles.guard';

@Controller('users')
export class UsersController {
  @Get('delete')
  @UseGuards(RolesGuard)
  @Roles(['admin'])
  deleteUser() {
    return 'User deleted';
  }
}
```

在这个例子中，只有角色包含 `admin` 的用户才能访问 `deleteUser` 方法。如果用户角色不匹配，守卫会返回 `false`，抛出 403 错误。

---

## 如何应用守卫？
NestJS 支持在不同层级应用守卫，灵活性很高：

### 1. 方法级别
通过 `@UseGuards()` 装饰器，将守卫应用到单个路由方法：

```typescript
@Get('profile')
@UseGuards(AuthGuard)
getProfile() {
  return 'User profile';
}
```

### 2. 控制器级别
将守卫应用到整个控制器，所有路由都会受保护：

```typescript
@Controller('users')
@UseGuards(AuthGuard)
export class UsersController {
  @Get()
  getUsers() {
    return 'List of users';
  }
}
```

### 3. 全局级别
全局守卫对所有路由生效，有两种方式：

**方式 1：在 **`main.ts`** 中设置**

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AuthGuard } from './auth.guard';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalGuards(new AuthGuard());
  await app.listen(3000);
}
bootstrap();
```

这种方式简单，但不支持依赖注入（比如无法注入 `Reflector`）。

**方式 2：通过模块提供者（推荐）**

```typescript
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { RolesGuard } from './roles.guard';

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: RolesGuard,
    },
  ],
})
export class AppModule {}
```

这种方式支持依赖注入，适合需要复杂逻辑的守卫。

---

## 自定义错误响应
默认情况下，守卫返回 `false` 时，NestJS 会抛出 `ForbiddenException`，返回如下响应：

```json
{
  "statusCode": 403,
  "message": "Forbidden resource",
  "error": "Forbidden"
}
```

如果想自定义错误信息或状态码，可以在 `canActivate` 中抛出自定义异常：

```typescript
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException, ForbiddenException } from '@nestjs/common';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();

    if (!request.headers.authorization) {
      throw new UnauthorizedException('请先登录');
    }

    if (!this.hasPermission(request.user)) {
      throw new ForbiddenException('权限不足');
    }

    return true;
  }

  private hasPermission(user: any): boolean {
    // 自定义权限检查逻辑
    return user && user.roles.includes('admin');
  }
}
```

在这个例子中，如果用户未登录，会收到 401 错误和“请先登录”的提示；如果权限不足，会收到 403 错误和“权限不足”的提示。

---

## 实际应用场景
守卫在实际项目中有广泛的应用，以下是一些常见的场景：

1. **JWT 认证**：验证请求头中的 JWT token 是否有效、是否过期。

```typescript
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';

@Injectable()
export class JwtGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const token = request.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      throw new UnauthorizedException('Token 缺失');
    }

    try {
      const decoded = jwt.verify(token, 'your-secret-key');
      request.user = decoded; // 将用户信息附加到请求
      return true;
    } catch (error) {
      throw new UnauthorizedException('Token 无效或已过期');
    }
  }
}
```

2. **API 限流**：限制用户或 IP 的请求频率，防止滥用。
3. **功能开关（Feature Flags）**：根据配置动态控制 API 访问。
4. **多租户权限**：确保用户只能访问其所属租户的数据。
5. **IP 白名单/黑名单**：只允许特定 IP 访问，或阻止某些 IP。
6. **CSRF 保护**：验证请求中的 CSRF token。

---

## 最佳实践
1. **单一职责**：每个守卫专注于一类权限检查，比如认证守卫和角色守卫分开实现，方便复用和维护。
2. **组合使用**：通过 `@UseGuards(AuthGuard, RolesGuard)` 组合多个守卫，处理复杂逻辑。
3. **异步支持**：对于需要数据库查询或外部 API 验证的场景，使用 `Promise<boolean>` 返回异步结果。
4. **错误信息友好**：自定义异常信息，帮助前端和用户快速定位问题。
5. **全局与局部结合**：全局守卫处理通用逻辑（如认证），局部守卫处理特定路由的特殊需求。

---

## 总结
NestJS 的守卫是一个强大而灵活的工具，能帮助开发者轻松实现权限控制。从简单的认证检查到复杂的基于角色访问控制，守卫通过 `ExecutionContext` 和 `Reflector` 提供了丰富的上下文信息和元数据支持。无论你的项目需要 JWT 验证、API 限流，还是多租户权限管理，守卫都能提供优雅的解决方案。

通过合理设计守卫并结合实际场景，你可以构建一个安全、可靠且易于维护的权限系统。希望这篇文章能帮你在 NestJS 项目中更好地利用守卫，写出更健壮的代码！


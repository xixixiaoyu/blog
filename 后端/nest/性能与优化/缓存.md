## 什么是缓存？为什么需要 Redis？
简单来说，缓存就像一个“快速记事本”，用来存放那些经常被访问或计算成本较高的数据。比如，一个接口需要从数据库查询用户信息，如果每次请求都查库，服务器压力会很大，响应也会变慢。而把结果暂时存到缓存里，下次请求直接从缓存读取，就能大幅提升速度。

Redis 是一个高性能的内存数据库，支持键值对、List、Hash、Set、Sorted Set 等多种数据结构，适合以下场景：

+ **接口缓存**：减少数据库查询，提升响应速度。
+ **复杂数据处理**：如用 List 实现任务队列，Sorted Set 实现排行榜。
+ **会话管理**：存储用户 Session 或分布式锁。

在 NestJS 中，官方提供的 `@nestjs/cache-manager` 模块是一个快速上手的选择，但它是否能满足所有需求？让我们来一探究竟。

---

## CacheManager：简单但有限
`@nestjs/cache-manager` 是基于社区 `cache-manager` 库的 NestJS 模块，主打简单易用，适合快速搭建缓存功能。以下是它的主要优点和局限性。

### 优点：快速上手，适合简单场景
1. **配置简单**  
通过 `CacheModule.register`，你可以快速启用缓存，默认使用内存存储，也可以切换到 Redis：

```typescript
import { CacheModule, Module } from '@nestjs/common';

@Module({
  imports: [
    CacheModule.register({
      ttl: 10, // 缓存 10 秒（默认使用内存存储，无需设置 store）
    }),
  ],
})
export class AppModule {}
```

2. **内置 CacheInterceptor**  
使用 `@UseInterceptors(CacheInterceptor)`，可以自动缓存 GET 请求的响应结果，省去手动操作缓存的麻烦：

```typescript
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { CacheInterceptor } from '@nestjs/cache-manager';

@Controller('users')
export class UserController {
  @Get()
  @UseInterceptors(CacheInterceptor)
  async getUsers() {
    return [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];
  }
}
```

同一个请求会在缓存有效期内直接返回缓存结果，无需重复执行逻辑。

3. **支持多种后端**  
通过使用社区维护的 Redis store（例如 `cache-manager-redis-yet`），可以切换到 Redis：

```typescript
import { CacheModule, Module } from '@nestjs/common';
import { redisStore } from 'cache-manager-redis-yet';

@Module({
  imports: [
    CacheModule.registerAsync({
      useFactory: async () => ({
        store: await redisStore({
          url: 'redis://localhost:6379',
          ttl: 10,
        }),
      }),
    }),
  ],
})
export class AppModule {}
```

### 短板：功能受限
`cache-manager` 为了兼容多种存储后端（如内存、Redis、Memcached），对 Redis 的支持仅限于基本的键值对操作。这意味着 Redis 的核心优势——如 List、Hash、Set、Sorted Set 等数据结构以及 `LPUSH`、`HSET`、`ZADD` 等高级命令——完全无法使用。

例如：

+ 想用 List 实现任务队列？不行。
+ 想用 Hash 存储结构化数据？没门。
+ 想用 Sorted Set 做排行榜？得换库。

这就像买了一辆跑车，却只能用来跑直线，完全浪费了 Redis 的潜力。更糟的是，当需求复杂时，你可能不得不引入原生 `redis` 库，之前的 `cache-manager` 代码就显得多余。

---

## 原生 Redis 库：灵活但需动手
直接使用 `@redis/client` 这样的原生 Redis 库，虽然需要多写一些代码，但能充分发挥 Redis 的所有功能，同时保持代码的可维护性和扩展性。

### 为什么选择原生 Redis？
1. **完整的功能支持**  
原生库支持 Redis 的所有命令和数据结构，无论是简单的键值对，还是复杂的 List、Hash、Sorted Set，都能轻松实现。
2. **更高的灵活性**  
你可以根据项目需求，自由封装 Redis 操作逻辑，打造完全贴合业务的服务。
3. **更好的可维护性**  
自己封装的逻辑更清晰，未来需求变更时也更容易调整，不会被 `cache-manager` 的抽象层限制。

接下来，我们通过一个实际案例，展示如何在 NestJS 中使用原生 `redis` 库，并实现一个类似 `CacheInterceptor` 的自定义缓存功能。

---

## 动手实践：打造高效的 Redis 缓存方案
我们将分三步实现一个基于原生 Redis 的缓存方案：

1. 配置 Redis 客户端。
2. 封装 `RedisService` 统一操作 Redis。
3. 实现自定义 `CacheInterceptor`。

### 步骤 1：配置 Redis 客户端
首先，安装 `@redis/client`：

```bash
npm install @redis/client
```

在模块中注册 Redis 客户端（作为可供其他模块使用的 Provider）：

```typescript
// redis.module.ts
import { Module } from '@nestjs/common';
import { createClient } from '@redis/client';
import { RedisService } from './redis.service';

@Module({
  providers: [
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
          socket: {
            host: 'localhost',
            port: 6379,
          },
        });
        await client.connect();
        return client;
      },
    },
    RedisService,
  ],
  exports: ['REDIS_CLIENT', RedisService],
})
export class RedisModule {}
```

这里通过 `useFactory` 创建并连接 Redis 客户端，供其他模块使用。

### 步骤 2：封装 RedisService
创建一个 `RedisService` 来统一管理 Redis 操作：

```bash
nest g service redis --no-spec
```

编辑 `redis.service.ts`：

```typescript
// redis.service.ts
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from '@redis/client';

@Injectable()
export class RedisService {
  constructor(@Inject('REDIS_CLIENT') private redisClient: RedisClientType) {}

  // 键值对操作
  async get(key: string): Promise<string | null> {
    return this.redisClient.get(key);
  }

  async set(key: string, value: string, ttl?: number): Promise<void> {
    if (ttl) {
      await this.redisClient.set(key, value, { EX: ttl });
    } else {
      await this.redisClient.set(key, value);
    }
  }

  async del(key: string): Promise<void> {
    await this.redisClient.del(key);
  }

  // List 操作
  async pushToList(key: string, value: string): Promise<void> {
    await this.redisClient.lPush(key, value);
  }

  async getList(key: string): Promise<string[]> {
    return this.redisClient.lRange(key, 0, -1);
  }

  // Hash 操作
  async setHashField(key: string, field: string, value: string): Promise<void> {
    await this.redisClient.hSet(key, field, value);
  }

  async getHashField(key: string, field: string): Promise<string | null> {
    return this.redisClient.hGet(key, field);
  }
}
```

这个服务封装了基本的键值对操作，同时支持 List 和 Hash 操作，可根据需求扩展其他方法。注册 `RedisService` 与 `REDIS_CLIENT` 到同一个模块：

```typescript
// redis.module.ts（同上，省略）
// 已在上文的 redis.module.ts 中同时注册并导出了 REDIS_CLIENT 与 RedisService
```

在 `AppModule` 中导入：

```typescript
// app.module.ts
@Module({
  imports: [RedisModule],
})
export class AppModule {}
```

### 步骤 3：实现自定义 CacheInterceptor
创建一个自定义拦截器，实现类似 `@nestjs/cache-manager` 的自动缓存功能：

```bash
nest g interceptor cache --no-spec --flat
```

编辑 `cache.interceptor.ts`：

```typescript
// cache.interceptor.ts
import { CallHandler, ExecutionContext, Inject, Injectable, NestInterceptor } from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';
import { Observable, of, tap } from 'rxjs';
import { RedisService } from './redis.service';

@Injectable()
export class CacheInterceptor implements NestInterceptor {
  constructor(
    private redisService: RedisService,
    private httpAdapterHost: HttpAdapterHost,
  ) {}

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const request = context.switchToHttp().getRequest();
    const key = this.httpAdapterHost.httpAdapter.getRequestUrl(request);

    const cachedValue = await this.redisService.get(key);
    if (cachedValue) {
      return of(JSON.parse(cachedValue));
    }

    return next.handle().pipe(
      tap(async (response) => {
        await this.redisService.set(key, JSON.stringify(response), 10);
      }),
    );
  }
}
```

使用方式：

```typescript
// user.controller.ts
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { CacheInterceptor } from './cache.interceptor';

@Controller('users')
export class UserController {
  @Get()
  @UseInterceptors(CacheInterceptor)
  async getUsers() {
    return [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];
  }
}
```

这个拦截器以请求 URL 作为缓存 key，检查是否有缓存，若有则直接返回；否则执行路由逻辑并缓存结果。

---

## CacheManager vs 原生 Redis：如何选择？
从第一性原理出发，我们需要根据项目需求权衡简单性和灵活性。

### 使用 CacheManager 的场景
+ **简单需求**：只需基本的键值对缓存，项目规模小或处于初期。
+ **快速开发**：不想花时间封装 Redis 操作，追求快速上线。
+ **短期项目**：无需 Redis 的高级功能，内存缓存或简单 Redis 配置足够。

### 使用原生 Redis 的场景
+ **复杂需求**：需要 List、Hash、Set、Sorted Set 等数据结构，比如任务队列或排行榜。
+ **长期项目**：需要高灵活性和可维护性，未来可能有更多定制化需求。
+ **精细控制**：希望自定义缓存 key、TTL 或复杂的缓存策略。

虽然原生 Redis 前期需要多写代码，但它能充分发挥 Redis 的潜力，避免后期因 `cache-manager` 限制而重构代码。

---

## 扩展：优化你的 Redis 方案
基于原生 Redis，你可以进一步优化缓存方案：

1. **自定义缓存 Key**  
默认以 URL 作为 key 可能不够灵活，可以通过装饰器自定义：

```typescript
import { applyDecorators, SetMetadata, UseInterceptors } from '@nestjs/common';
import { CacheInterceptor } from './cache.interceptor';

export const Cache = (key: string) =>
  applyDecorators(SetMetadata('cacheKey', key), UseInterceptors(CacheInterceptor));
```

修改拦截器：

```typescript
import { Reflector } from '@nestjs/core';

// 注入 Reflector
constructor(
  private reflector: Reflector,
  private redisService: RedisService,
  private httpAdapterHost: HttpAdapterHost,
) {}

const key = this.reflector.get<string>('cacheKey', context.getHandler())
  || this.httpAdapterHost.httpAdapter.getRequestUrl(request);
```

使用：

```typescript
@Get()
@Cache('users_list')
async getUsers() {
  return [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];
}
```

2. **动态 TTL**  
支持通过装饰器设置不同的 TTL：

```typescript
export const Cache = (key: string, ttl: number) =>
  applyDecorators(SetMetadata('cacheKey', key), SetMetadata('cacheTtl', ttl), UseInterceptors(CacheInterceptor));
```

拦截器中读取 TTL：

```typescript
const ttl = this.reflector.get<number>('cacheTtl', context.getHandler()) ?? 10;
await this.redisService.set(key, JSON.stringify(response), ttl);
```

3. **复杂数据结构**  
在 `RedisService` 中扩展方法，支持 List、Hash 等数据结构的序列化/反序列化，满足更复杂的业务需求。

每当我们启动一个 Nest.js 应用时，它就像开始了一段完整的生命旅程。从初始化到运行，再到最终关闭，这个过程中有很多关键节点需要我们关注。

Nest 框架提供了一套完整的生命周期钩子机制，让我们能够在合适的时机执行必要的操作。

## 应用的三个生命阶段
### 1. 初始化阶段（Initializing）
这是应用的"婴儿期"。Nest 开始启动时，会依次加载你定义的各个模块，解析它们之间的依赖关系，并完成运行前的各种准备工作。

就像搭积木一样，每个模块都需要找到自己的位置，确保所有依赖都能正确连接。

### 2. 运行阶段（Running）
所有准备工作完成后，应用开始监听指定端口，接收并处理来自客户端的请求。

这是应用真正发挥价值的时间，也是我们最关心的业务逻辑执行阶段。

### 3. 终止阶段（Terminating）
当应用收到关闭信号时（比如你按下 Ctrl+C，或者 Docker 容器收到 SIGTERM 信号），它会进入"退休"状态。

这时需要优雅地处理正在进行的请求，关闭数据库连接，释放占用的资源，然后彻底退出。



## 核心生命周期钩子详解
### 初始化相关钩子
**onModuleInit()** 当某个模块的所有依赖都解析完成后，这个钩子会在该模块内部被调用。你可以把它理解为模块级别的"准备就绪"信号。

**onApplicationBootstrap()** 当所有模块的 `onModuleInit` 都执行完成，但在应用真正开始监听端口之前，这个全局钩子会被触发。这是整个应用层面的"万事俱备"时刻。

```typescript
import { Injectable, OnModuleInit, OnApplicationBootstrap } from '@nestjs/common';

@Injectable()
export class ConfigService implements OnModuleInit, OnApplicationBootstrap {
  onModuleInit() {
    console.log('配置服务模块初始化完成');
  }

  onApplicationBootstrap() {
    console.log('应用启动完成，即将开始监听请求');
  }
}
```



### 关闭相关钩子
**onModuleDestroy()** 当应用收到关闭信号时，这个钩子会在相应模块中被调用，是你清理模块特定资源的第一个机会。

**beforeApplicationShutdown()** 在所有模块的 `onModuleDestroy` 执行完毕后，这个钩子会被调用。执行完成后，Nest 会开始关闭所有现有的网络连接。

**onApplicationShutdown()** 当所有网络连接都成功关闭后，这个钩子会被调用，是进行最后清理工作的地方。

用起来其实很简单。只需要在想要添加钩子的类（比如 Service、Controller 或者 Module 本身）上，实现 (implements) Nest 提供的对应接口，然后把那个钩子方法写出来就行了：

```typescript
import { Injectable, OnModuleDestroy, OnApplicationShutdown } from '@nestjs/common';

@Injectable()
export class DatabaseService implements OnModuleDestroy, OnApplicationShutdown {
  onModuleDestroy() {
    console.log('开始关闭数据库连接...');
    // 关闭数据库连接池
  }

  onApplicationShutdown(signal?: string) {
    console.log(`收到关闭信号: ${signal}，执行最终清理工作`);
    // 执行最后的清理操作
  }
}
```



## 异步操作的处理
生命周期钩子完全支持异步操作。如果你的初始化或清理工作需要时间（比如从数据库加载配置），可以使用 `async/await` 或返回 Promise：

```typescript
import { Injectable, OnModuleInit } from '@nestjs/common';

@Injectable()
export class CacheService implements OnModuleInit {
  async onModuleInit(): Promise<void> {
    console.log('开始预热缓存...');
    await this.preloadCache();
    console.log('缓存预热完成！');
  }

  private async preloadCache(): Promise<void> {
    // 模拟异步加载数据
    return new Promise(resolve => {
      setTimeout(() => {
        console.log('缓存数据加载完成');
        resolve();
      }, 2000);
    });
  }
}
```

Nest 会耐心等待所有异步操作完成，然后再继续执行后续的生命周期步骤。



## 实现优雅关闭
在现代部署环境中，优雅关闭是一个重要特性。当平台需要停止或重启应用时，它们会发送关闭信号，给应用一个"收拾行李"的机会。

### 启用关闭钩子监听
默认情况下，Nest 不会监听系统关闭信号。你需要在 `main.ts` 中手动开启：

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // 开启对系统关闭信号的监听
  app.enableShutdownHooks();

  await app.listen(process.env.PORT ?? 3000);
  console.log(`应用已启动，运行在: ${await app.getUrl()}`);
}
bootstrap();
```

### 实现清理逻辑
启用关闭钩子后，你可以在各个服务中实现清理逻辑：

```typescript
import { Injectable, OnApplicationShutdown } from '@nestjs/common';

@Injectable()
export class CleanupService implements OnApplicationShutdown {
  private intervals: NodeJS.Timeout[] = [];

  startBackgroundTask() {
    const interval = setInterval(() => {
      console.log('执行后台任务...');
    }, 5000);
    this.intervals.push(interval);
  }

  onApplicationShutdown(signal?: string) {
    console.log(`收到关闭信号: ${signal}，开始清理后台任务`);
    
    // 清理所有定时器
    this.intervals.forEach(interval => {
      clearInterval(interval);
    });
    
    console.log('后台任务清理完成');
  }
}
```



## 整个流程串讲
Nest 启动时，会递归解析 Module 依赖，扫描其中的 provider、controller，注入它的依赖。

全部解析完后，会监听网络端口，开始处理请求。

过程中 Nest 暴露了一些生命周期方法：

+ 首先，递归初始化模块，会依次调用模块内的 controller、provider 的 onModuleInit 方法，然后再调用 module 的 onModuleInit 方法。
+ 全部初始化完之后，再依次调用模块内的 controller、provider 的 onApplicationBootstrap 方法，然后调用 module 的 onApplicationBootstrap 方法
+ 然后监听网络端口。之后 Nest 应用就正常运行了。

这个过程中，onModuleInit、onApplicationBootstrap 都是我们可以实现的生命周期方法。

在 module 实现它：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349153195-d3d23384-5bcf-4e83-93f3-eabc920d4265.png)

同理 controller、service 也这样实现。

最后输出的结果是：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349171532-e3007e32-a245-401d-a26c-adfe6699ab51.png)

应用销毁的时候也同样有生命周期：

+ 先调用每个模块的 controller、provider 的 onModuleDestroy 方法，然后调用 Module 的 onModuleDestroy 方法。
+ 之后再调用每个模块的 controller、provider 的 beforeApplicationShutdown 方法，然后调用 Module 的 beforeApplicationShutdown 方法。
+ 然后停止监听网络端口。
+ 之后调用每个模块的 controller、provider 的 onApplicationShutdown 方法，然后调用 Module 的 onApplicationShutdown 方法。
+ 之后停止进程。

beforeApplicationShutdown 里可以拿到 signal 系统信号的，比如 SIGTERM。

这些终止信号是别的进程传过来的，让它做一些销毁的事情，比如用 k8s 管理容器的时候，可以通过这个信号来通知它。

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349190097-a9dca712-46f6-46ba-b6f9-577cc75a0921.png)

依次也在 controller、service 这样实现。

3s 后调用 app.close() 触发销毁。（只是触发销毁逻辑，但不会真正退出进程）

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349198684-d2212e88-3c1b-46b1-8e46-c7962747fd9a.png)

生命周期方法执行顺序：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1686403694240-afb57f64-8f8e-43b8-a39e-20609056ca8e.png)

而且所有的生命周期函数都是支持 async 的。



我们可以在 onApplicationShutdown 的生命周期里：  
拿到当前模块的引用，调用 get 方法，传入 token，取出对应的 provider 实例，然后调用它的方法（比如关闭连接等）。

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1749349260772-f5012a95-67bf-42df-a409-c086d4e60aa8.png)



## 注意事项和最佳实践
### 执行顺序
生命周期钩子的执行顺序是固定的：

1. 启动时：`onModuleInit` → `onApplicationBootstrap`
2. 关闭时：`onModuleDestroy` → `beforeApplicationShutdown` → `onApplicationShutdown`

### 请求范围的限制
这些生命周期钩子在请求范围（request-scoped）的类上是有效的，但行为与单例作用域不同：请求范围的类会在每次请求创建实例时执行其生命周期方法（例如 `onModuleInit` 在该实例被创建时触发），而不是在应用启动时统一触发。请求结束后，请求范围实例随即被销毁，拥有独立的生命周期。

### 平台兼容性
Windows 系统对信号的支持有限。SIGINT（Ctrl+C）通常没问题，但 SIGTERM 可能无法被正确捕获。这是操作系统的限制，在部署时需要考虑。

### 资源管理
`enableShutdownHooks()` 会启动额外的监听器，消耗少量系统资源。如果在同一个进程中运行多个 Nest 应用实例（比如测试环境），可能会遇到监听器数量警告。



## 实际应用场景
### 数据库连接管理
```typescript
@Injectable()
export class DatabaseService implements OnModuleInit, OnApplicationShutdown {
  private connection: any;

  async onModuleInit() {
    this.connection = await createDatabaseConnection();
    console.log('数据库连接已建立');
  }

  async onApplicationShutdown() {
    if (this.connection) {
      await this.connection.close();
      console.log('数据库连接已关闭');
    }
  }
}
```

### 缓存预热
```typescript
@Injectable()
export class CacheService implements OnModuleInit {
  private cache = new Map();

  async onModuleInit() {
    await this.preloadFrequentlyUsedData();
    console.log('缓存预热完成');
  }

  private async preloadFrequentlyUsedData() {
    // 从数据库加载常用数据到缓存
    const data = await this.fetchFrequentData();
    data.forEach(item => {
      this.cache.set(item.key, item.value);
    });
  }
}
```



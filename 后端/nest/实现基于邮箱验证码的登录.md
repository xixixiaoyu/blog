<font style="color:rgb(37, 41, 51);">在本节中，我们将学习如何使用 Node.js 实现通过邮箱验证码进行登录的功能。</font>

<font style="color:rgb(37, 41, 51);"></font>

## <font style="color:rgb(37, 41, 51);">前端实现</font>
### 创建 React 项目并搭建登录页面
创建项目并启动开发服务：

```bash
pnpm create vite email-login-frontend --template react-ts
```

<font style="color:rgb(37, 41, 51);">安装 antd 组件库和 axios 请求库：</font>

```bash
pnpm install antd axios
```

<font style="color:rgb(37, 41, 51);">编写登录页面的代码：</font>

```tsx
import { Button, Form, Input, message } from 'antd';
import axios from 'axios';

const App = () => {
	const [form] = Form.useForm();

	const sendEmailCode = async () => {
		const email = form.getFieldValue('email');
		if (!email) {
			message.error('邮箱不能为空');
			return;
		}
		const res = await axios.get('http://localhost:3001/email/code', {
			params: { address: email },
		});
		message.info(res.data);
	};

	const login = async values => {
		const res = await axios.post('http://localhost:3001/user/login', {
			email: values.email,
			code: values.code,
		});
		if (res.data === 'success') {
			message.success('登录成功');
		} else {
			message.error(res.data.message);
		}
	};

	return (
		<div style={{ width: '500px', margin: '200px auto' }}>
			<Form form={form} onFinish={login}>
				<Form.Item
					label="邮箱"
					name="email"
					rules={[{ required: true, message: '请输入邮箱地址' }]}
				>
					<Input />
				</Form.Item>
				<Form.Item
					label="验证码"
					name="code"
					rules={[{ required: true, message: '请输入验证码' }]}
				>
					<Input />
				</Form.Item>
				<Form.Item>
					<Button onClick={sendEmailCode}>发送验证码</Button>
				</Form.Item>
				<Form.Item>
					<Button type="primary" htmlType="submit">
						登录
					</Button>
				</Form.Item>
			</Form>
		</div>
	);
};

export default App;
```

<font style="color:rgb(37, 41, 51);">展示效果：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716728818704-9f42684b-9880-4366-a524-300dd0bb52d2.png)

<font style="color:rgb(37, 41, 51);"></font>

## <font style="color:rgb(37, 41, 51);">后端 Nest 实现</font>
### 创建并启动 Nest 项目
```bash
nest new email-login-backend -p pnpm
cd email-login-backend
pnpm start:dev
```

### <font style="color:rgb(37, 41, 51);">安装依赖</font>
```bash
pnpm install @nestjs/typeorm typeorm mysql2 nodemailer @nestjs/config redis class-validator class-transformer
pnpm install @types/nodemailer -D
```

### <font style="color:rgb(37, 41, 51);">修改 main.ts 以启用跨域和全局验证管道</font>
```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  // 启用跨域资源共享 (CORS)
  app.enableCors();
  // 使用全局验证管道，自动验证请求数据
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3001);
}
bootstrap();
```



### 创建 <font style="color:rgb(37, 41, 51);">database</font>
<font style="color:rgb(37, 41, 51);">我们在 mysql workbench 创建个新的 database：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690019482629-08cba940-5e4b-4c09-b671-7bffbd4e5e87.png)



### <font style="color:rgb(37, 41, 51);">配置 TypeORM</font>
```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'xxx',
      database: 'email_login_test',
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
        authPlugin: 'sha256_password',
      },
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

<font style="color:rgb(37, 41, 51);"></font>

### <font style="color:rgb(37, 41, 51);">创建 User 实体：</font>
```bash
nest g resource user
```

```typescript
// email-login-backend/src/user/entities/user.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 50, comment: '用户名' })
  username: string;

  @Column({ length: 50, comment: '密码' })
  password: string;

  @Column({ length: 50, comment: '邮箱地址' })
  email: string;
}
```

<font style="color:rgb(37, 41, 51);">在 TypeOrm 的 entities 注册下：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716728740593-fc1ee483-1d96-48f6-b94d-57dfbf2513aa.png)

<font style="color:rgb(37, 41, 51);">可以看到 user 表自动创建了：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690019879935-17763af6-343d-490b-96dd-3c7cf3761a96.png)

<font style="color:rgb(37, 41, 51);">我们手动插入条数据：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716729059494-d0d0f0d6-6106-49c1-ad59-2f581f5dc484.png)



### <font style="color:rgb(37, 41, 51);">在 EmailModule 处理发送邮件</font>
<font style="color:rgb(37, 41, 51);">再添加个 email 模块：</font>

```tsx
nest g resource email
```

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716729154318-a0665369-b4e7-49c2-9405-fb95a2b406ec.png)

<font style="color:rgb(37, 41, 51);">这次不生成 crud 代码：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716729137490-6945cf3b-1440-4be4-99c5-2738501e7968.png)

<font style="color:rgb(37, 41, 51);">在 EmailService 发邮件：</font>

```typescript
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { createTransport, Transporter } from 'nodemailer';

@Injectable()
export class EmailService {
  private transporter: Transporter;

  constructor(private configService: ConfigService) {
    // 配置邮件传输器
    this.transporter = createTransport({
      host: 'smtp.qq.com', // 邮件服务器地址
      port: 587, // 邮件服务器端口
      secure: false, // 是否使用安全连接
      auth: {
        user: this.configService.get('EMAIL_USER'), // 获取邮件用户
        pass: this.configService.get('EMAIL_PASSWORD'), // 获取邮件密码
      },
    });
  }

  // 发送邮件方法
  async sendMail({ to, subject, html }) {
    await this.transporter.sendMail({
      from: {
        name: '系统邮件', // 发件人名称
        address: this.configService.get('EMAIL_USER'), // 发件人地址
      },
      to, // 收件人地址
      subject, // 邮件主题
      html, // 邮件内容
    });
  }
}
```

<font style="color:rgb(37, 41, 51);"></font>

<font style="color:rgb(37, 41, 51);">EmailController 处理发送验证码请求：</font>

```typescript

```

<font style="color:rgb(37, 41, 51);"></font>



<font style="color:rgb(37, 41, 51);"></font>

<font style="color:rgb(37, 41, 51);">然后添加一个 controller 方法：</font>

```typescript
import { Controller, Get, Query } from '@nestjs/common';
import { EmailService } from './email.service';

@Controller('email')
export class EmailController {
  constructor(private readonly emailService: EmailService) {}

  @Get('code')
  async sendEmailCode(@Query('address') address) {
    await this.emailService.sendMail({
      to: address,
      subject: '登录验证码',
      html: '<p>你的登录验证码是 123456</p>',
    });
    return '发送成功';
  }
}
```

<font style="color:rgb(37, 41, 51);">我们调用下试试：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690020439342-14c33bf3-cfac-4681-9a83-588a93011713.png)

<font style="color:rgb(37, 41, 51);">发送成功，邮箱里确实也收到了这封邮件：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690020548894-4f8c8c25-ffd9-4e17-99da-54add5e60365.png)

<font style="color:rgb(37, 41, 51);">回过头来看一下，现在邮箱有关信息直接写在 service 代码里了。</font>

<font style="color:rgb(37, 41, 51);">实际上这些应该从配置读取。</font>

<font style="color:rgb(37, 41, 51);">我们安装下配置模块：</font>

```typescript
npm install --save @nestjs/config
```

<font style="color:rgb(37, 41, 51);">在 AppModule 里引入，并且把它声明为全局的：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690020678861-2857fcbc-7385-49b7-8d07-8a749cbb65a7.png)

```typescript
ConfigModule.forRoot({
  isGlobal: true,
  envFilePath: 'src/.env',
}),
```

<font style="color:rgb(37, 41, 51);">在 src 下添加这个 .env 文件：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690020776431-ace476b9-e0ef-4c75-8206-4d021d44057d.png)

<font style="color:rgb(37, 41, 51);">然后在 EmailService 里注入 ConfigService，从中读取配置：</font>

```typescript
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { createTransport, Transporter } from 'nodemailer';

@Injectable()
export class EmailService {
  transporter: Transporter;

  constructor(private configService: ConfigService) {
    this.transporter = createTransport({
      host: 'smtp.qq.com',
      port: 587,
      secure: false,
      auth: {
        user: this.configService.get('email_user'),
        pass: this.configService.get('email_password'),
      },
    });
  }

  async sendMail({ to, subject, html }) {
    await this.transporter.sendMail({
      from: {
        name: '系统邮件',
        address: this.configService.get('email_user'),
      },
      to,
      subject,
      html,
    });
  }
}
```

<font style="color:rgb(37, 41, 51);">再调用下接口，这时依然能成功收发邮件。</font>

<font style="color:rgb(37, 41, 51);">说明配置正确读取出来了。</font>

<font style="color:rgb(37, 41, 51);">不过用了 .env 配置文件之后有个问题：</font>

+ <font style="color:rgb(37, 41, 51);">dist 目录下没有这个文件。env 需要配置下 assets 才会复制过去。</font>

<font style="color:rgb(37, 41, 51);">改下 nest-cli.json：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690020997767-9d7b1f83-d9fe-4861-b617-1ce5985e6b44.png)

<font style="color:rgb(37, 41, 51);">添加 assets 为 *.env 这样就会在编译的时候把 src 下的 .env 文件复制到 dist 下。</font>

<font style="color:rgb(37, 41, 51);">注意，</font>**<font style="color:rgb(37, 41, 51);">assets 只支持 src 下的文件复制</font>**<font style="color:rgb(37, 41, 51);">。如果是放在根目录，那就要自己复制了。</font>

改了编译配置需要重新跑服务：

```plain
npm run start:dev
```

此时 dist 目录下就有 env 文件了。

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690021074391-24606979-f5c0-43f7-b473-5a84d0e0def7.png)

<font style="color:rgb(37, 41, 51);">但现在改了 src 下的 .env 之后，dist 下的 .env 不会跟着改，需要重新跑服务才可以。</font>

<font style="color:rgb(37, 41, 51);">这时候可以加一个 watchAssets：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690021188657-a3e6e208-6090-4541-90b2-9f168532bcfa.png)

<font style="color:rgb(37, 41, 51);">这时候两边就同步了。</font>

<font style="color:rgb(37, 41, 51);">也就是说，</font>**<font style="color:rgb(37, 41, 51);">如果用到了 .env 文件或者 yaml 等文件来配置，需要在 nest-cli.json 里配置下 assets 和 watchAssets。</font>**

<font style="color:rgb(37, 41, 51);">回过头来继续搞验证码的事情。</font>

<font style="color:rgb(37, 41, 51);">首先，验证码要随机，我们通过 Math.random 来生成：</font>

```typescript
const code = Math.random().toString().slice(2,8);
```

<font style="color:rgb(37, 41, 51);">然后在前端项目里调用下看看：</font>

```tsx
import React from 'react'
import { Button, Form, Input } from 'antd'
import axios from 'axios'

const login = values => {
  console.log('login:', values)
}

const App = () => {
  const [form] = Form.useForm()

  const sendEmailCode = async () => {
    const res = await axios.get('http://localhost:3001')

    console.log(form.getFieldsValue())

    console.log('send email code', res)
  }

  return (
    <div style={{ width: '500px', margin: '100px auto' }}>
      <Form form={form} onFinish={login}>
        <Form.Item
          label="邮箱"
          name="email"
          rules={[
            {
              required: true,
              message: '请输入邮箱地址',
            },
          ]}
          >
          <Input />
        </Form.Item>

        <Form.Item
          label="验证码"
          name="code"
          rules={[
            {
              required: true,
              message: '请输入验证码',
            },
          ]}
          >
          <Input />
        </Form.Item>

        <Form.Item>
          <Button onClick={sendEmailCode}>发送验证码</Button>
        </Form.Item>

        <Form.Item>
          <Button type="primary" htmlType="submit">
            登录
          </Button>
        </Form.Item>
      </Form>
    </div>
  )
}
export default App
```

<font style="color:rgb(37, 41, 51);">通过 useForm 创建 form 实例，然后点击发送验证码，就可以通过 form.getFieldsValue 拿到表单值了：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690021519903-f019905e-d649-4f9b-92c1-3b667fdf8f31.png)

<font style="color:rgb(37, 41, 51);">在点击发送验证码的时候，验证下邮箱是否为空，不为空就调用后端接口来发送验证码：</font>

```tsx
const [form] = Form.useForm()

const sendEmailCode = async () => {
  const email = form.getFieldValue('email')

  if (!email) {
    message.error('邮箱不能为空')
    return
  }

  const res = await axios.get('http://localhost:3001/email/code', {
    params: {
      address: email,
    },
  })
  message.info(res.data)
}
```

<font style="color:rgb(37, 41, 51);">这时候点击页面发送验证码，这个邮箱就会收到一封验证码的邮件。</font>

<font style="color:rgb(37, 41, 51);">然后我们来实现下登录。</font>

<font style="color:rgb(37, 41, 51);">登录就是根据用户填的信息去数据库匹配，如果匹配到了就查询出该用户的信息，放入 session 或者 jwt 里。</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690022095775-5b7f1487-a55a-49e3-be1b-4fe43e127f6d.png)

<font style="color:rgb(37, 41, 51);">验证用户身份的信息，可以是用户名 + 密码，也可以是邮箱 + 验证码。</font>

<font style="color:rgb(37, 41, 51);">用邮箱验证码验证用户身份的流程是这样的：</font>

![画板](https://cdn.nlark.com/yuque/0/2023/jpeg/21596389/1690025247864-af5f86cc-577c-4ac0-aa4d-7b4f97098de4.jpeg)

<font style="color:rgb(37, 41, 51);">用户填入邮箱地址，点击发送验证码，后端会生成验证码，发送邮件。并且还要把这个验证码存入 redis，以用户邮箱地址为 key。</font>

<font style="color:rgb(37, 41, 51);">之后用户输入验证码，点击登录。</font>

<font style="color:rgb(37, 41, 51);">后端根据邮箱地址去 redis 中查询下验证码，和用户传过来的验证码比对下，如果一致，就从 mysql 数据库中查询该用户的信息，放入 jwt 中返回。</font>

<font style="color:rgb(37, 41, 51);">我们来实现下，创建个 redis 模块：</font>

```tsx
nest g resource redis  --no-spec
```

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690022305909-0c39ccda-857d-4693-a4ba-5ce73cde6af1.png)

<font style="color:rgb(37, 41, 51);">安装 redis 的包：</font>

```tsx
npm install redis --save
```

<font style="color:rgb(37, 41, 51);">把 RedisModule 声明为全局模块，并导出 RedisService。</font>

<font style="color:rgb(37, 41, 51);">然后在 RedisModule 添加一个 provider：</font>

```typescript
import { Global, Module } from '@nestjs/common';
import { RedisService } from './redis.service';
import { RedisController } from './redis.controller';
import { createClient } from 'redis';

@Global()
@Module({
  controllers: [RedisController],
  providers: [
    RedisService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
          socket: {
            host: 'localhost',
            port: 6379,
          },
        });
        await client.connect();
        return client;
      },
    },
  ],
  exports: [RedisService],
})
export class RedisModule {}
```

<font style="color:rgb(37, 41, 51);">在 RedisService 里封装 redis 的 get、set 方法：</font>

```typescript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {
  @Inject('REDIS_CLIENT')
  private redisClient: RedisClientType;

  async get(key: string) {
    return await this.redisClient.get(key);
  }

  async set(key: string, value: string | number, ttl?: number) {
    await this.redisClient.set(key, value);

    if (ttl) {
      await this.redisClient.expire(key, ttl);
    }
  }
}
```

<font style="color:rgb(37, 41, 51);">然后修改下发送邮箱验证码的逻辑：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690022614576-b8f5b0c0-ba03-4b89-93ae-ced484776e80.png)

<font style="color:rgb(37, 41, 51);">注入 RedisService，并且发送验证码之前把它存入 redis，key 为 captcha_邮箱地址，value 为对应的验证码。过期时间为 5 分钟。</font>

<font style="color:rgb(37, 41, 51);">我们试试看：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690022846631-2eee0af8-565f-4e81-98cf-9b847d21155b.png)

<font style="color:rgb(37, 41, 51);">redis 里也保存了一份：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690022930015-fed9bad5-a3a2-4940-aaef-d86bcc24a461.png)

<font style="color:rgb(37, 41, 51);">接下来只要在前端填入这个验证码，点击登录就可以了。</font>

<font style="color:rgb(37, 41, 51);">我们再来实现下登录接口：</font>

<font style="color:rgb(37, 41, 51);">在 UserController 里添加一个路由：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023057879-f8092615-424c-49a3-9418-ab9f9b30c1b4.png)

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023073686-2b70ca3c-c69e-467c-ac84-09fdcfcf27d8.png)

<font style="color:rgb(37, 41, 51);">然后需要对它做校验，我们引入 class-validator 和 class-transformer：</font>

```tsx
npm install --save class-validator class-transformer
```

<font style="color:rgb(37, 41, 51);">在 main.ts 里全局启用 ValidationPipe：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023137229-a4274bb5-0fc6-4e34-95f2-a6fa68f3bb8a.png)

<font style="color:rgb(37, 41, 51);">然后给 LoginUserDto 添加一些约束：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023174934-ee2e0038-082b-4de8-9ab3-4bded86cc38f.png)

<font style="color:rgb(37, 41, 51);">在 postman 里测试下：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023338965-6fab0790-c902-4161-9c58-0c8b6a5f5b35.png)

已经生效，我们<font style="color:rgb(37, 41, 51);">来实现下具体的验证逻辑：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023622610-7493e3b6-28c3-420f-90d6-47906adc97d8.png)

<font style="color:rgb(37, 41, 51);">从 redis 中查找这个邮箱对应的验证码。</font>

<font style="color:rgb(37, 41, 51);">如果没查找，就返回验证码已失效。</font>

<font style="color:rgb(37, 41, 51);">查到的话和用户传过来的验证码对比，如果不一致，就返回验证码不正确。</font>

<font style="color:rgb(37, 41, 51);">验证码通过之后，从数据库中查询这个用户的信息。</font>

<font style="color:rgb(37, 41, 51);">我们在 UserService 里实现下这个通过邮箱查找用户的方法：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023741090-420060c4-6220-474a-ac81-e59f14179f32.png)

<font style="color:rgb(37, 41, 51);">然后在前端代码里调用下：</font>

```typescript
const login = async values => {
	const res = await axios.post('http://localhost:3001/user/login', {
		email: values.email,
		code: values.code,
	})
	if (res.data === 'success') {
		message.success('登录成功')
	} else {
		message.error(res.data.message)
	}
}
```

<font style="color:rgb(37, 41, 51);">我们整体试一下：</font>

<font style="color:rgb(37, 41, 51);">填写邮箱发送验证码：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023858142-b734c276-0831-47ff-bacb-e8178fafb36f.png)

收到验证码

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023880121-ae4c9138-9a2c-4f52-8570-21ebb43c8f40.png)

redis 存储：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690023933091-ea750fe9-2cfc-40cb-84a5-d48297783558.png)

填写验证码并点击登录成功：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690024002346-5f5728f1-48de-4cfc-a077-9ce240fffc80.png)

<font style="color:rgb(37, 41, 51);">可以看到服务端通过了校验，并且从数据库中查询出了用户信息：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1690024054854-aca60eba-d5e7-47d4-b528-79eba5760769.png)

<font style="color:rgb(37, 41, 51);">接下来只要返回对应的 jwt token 就好了。</font>

<font style="color:rgb(37, 41, 51);">这部分可以参考前面 jwt 登录章节的内容，就不展开了。</font>

<font style="color:rgb(37, 41, 51);"></font>

## <font style="color:rgb(37, 41, 51);">总结</font>
<font style="color:rgb(37, 41, 51);">这节我们实现了基于邮箱验证码的登录。</font>

<font style="color:rgb(37, 41, 51);">流程可以看这张图：</font>

![画板](https://cdn.nlark.com/yuque/0/2023/jpeg/21596389/1690025247864-af5f86cc-577c-4ac0-aa4d-7b4f97098de4.jpeg)

<font style="color:rgb(37, 41, 51);">综合用到了 mysql、redis、typeorm、nodemailer 等技术。</font>

<font style="color:rgb(37, 41, 51);">并且使用 @nestjs/config 包的 ConfigModule 来封装配置。</font>

<font style="color:rgb(37, 41, 51);">要注意的是，如果用了 .env 文件，需要保证它在 src 下，并且要在 nest-cli.json 里配置 assets 和 watchAssets，不然 build 的时候不会复制到 dist 下。</font>

<font style="color:rgb(37, 41, 51);">这节实现的功能，前后端代码都有，算是一个不错的综合练习。</font>


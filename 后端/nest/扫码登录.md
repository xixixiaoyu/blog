扫码登录是常见的功能，基本各种网站都支持。

掘金的登录就支持 APP 扫码的方式：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694263422940-137f38d6-b15d-4020-8005-7c7b7a73f6dd.png)

APP 如果没登录，扫码后会跳到登录页面。

登录之后，会进入确认界面，你可以选择授权登录或者取消。

确认之后，pc 网站就登录了。

为什么一扫二维码，然后确认下，那边就自动登录了呢？

其实原理也很简单。

二维码的内容是一个 url，如果在手机浏览器打开，会让你去下载 app。

而在 APP 里打开，就是登录确认界面了。

二维码这里是有个唯一 id 的，通过这个 id 就知道是哪个二维码。

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264127381-9b8ee5a8-ef0d-4b71-9b0d-1c47e3dfa2fb.png)

这个二维码有 5 个状态：

+ 未扫描
+ 已扫描，等待用户确认
+ 已扫描，用户同意授权
+ 已扫描，用户取消授权
+ 已过期

最开始是未扫描状态：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264064099-4187dae6-c2fe-4de7-9333-4afc9a90a172.png)

扫码后会进入等待用户确认状态：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264081560-71c89040-3ba3-4352-82a9-358e22b577c4.png)

确认后会进入同意授权状态：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264103534-06eaf057-ebde-4a6f-9888-0caf9f88159a.png)

取消的话会进入取消授权状态：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264174338-fd38d225-92a5-4db7-8599-4978814e97af.png)

长时间不操作会进入过期状态：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264199741-f9b146a4-e340-424d-ba13-38736e40bdbf.png)

也就是说，扫码后进行不同的操作就是修改这个 id 对应的二维码的状态。

另一边操作，这边是怎么知道二维码状态变了呢？

websocket ？一般网站都是轮询来做。

比如掘金：

二维码出现后，会有一个每秒一次的轮询请求来查询二维码状态：

最开始是 new：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264691286-8f2b2a69-5578-42b0-9dfa-f0286e79f74f.png)

扫码后会变成 scanned：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264705158-69792a6e-8646-4d28-b69c-38a20e3d95f5.png)

知乎也是一样：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264723907-662fff9c-f58d-4e9c-95ab-6288d7d41037.png)![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694264736589-f13ff287-ad8e-46cd-ac0f-d432b04bf135.png)

这时候，手机会进入登录确认页面。

这边点击确认登录或者取消之后，会发请求修改 id 对应的二维码的状态。

那边一直在轮询，自然就知道了二维码状态的变更。

也就是这样：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694265983071-10d98bf6-3632-44c0-bcd1-47ff6ed1fdcf.png)

服务端有个 qrcode/generate 接口，会生成一个随机的二维码 id，存到 redis 里，并返回二维码。

还有个 qrcode/check 接口，会返回 redis 里的二维码状态，浏览器里可以轮询这个接口拿到二维码状态。

然后手机 APP 扫码之后，如果没登录，会先跳转到登录页面，登录之后会进入登录确认页面。

这个时候就从二维码中拿到了 id，然后调用 qrcode/scan、qrcode/cancel、qrcode/confirm 就是修改二维码为不同的状态。

这时候用户是登录了的，jwt 的登录认证方式会携带 token，服务端只要从 token 中取出用户信息，存入 redis 即可。

然后另一边的轮询接口发现是确认状态，会根据用户信息生成 jwt 返回。

这样，手机 APP 里确认之后，pc 的浏览器就自动登录了该用户账号。



我们来实现一下吧！

创建个 nest 项目：

```javascript
nest new qrcode-login
```

把它跑起来：

```javascript
npm run start:dev
```

安装下用到的包：

```javascript
npm install qrcode @types/qrcode
```

添加一个路由：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694266950741-816c1864-4773-4130-a4e3-45e60bd2b48e.png)

这里用 node 的 crypto 模块生成一个随机的 uuid。

然后用 qrcode 生成二维码，只不过转成 base64 返回。

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694267222189-e43db97c-694e-4caf-b890-b3728d73c4c4.png)

在 html 里把它渲染出来看一下，新建 static/index.html：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>扫码登录</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <img
      src="填写上面接口 img 返回的 base64 参数即可"
    />
  </body>
</html>
```

在 main.ts 里支持这个目录下静态资源的访问，用 pages 作为前缀：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694267061878-c74d4030-5366-45a1-98a8-4f60254c7129.png)  
这样访问 [http://localhost:3000/pages/index.html](https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A3000%2Fpages%2Findex.html) 就可以看到二维码了：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694267594657-fcfa900d-37fc-401d-b65a-0939186008e7.png)

用在线解码工具解码下看看：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694267632777-6881c3a0-a901-4d7f-9d2a-bec05d578ee0.png)

识别出来的内容是个 uuid。

但是这个二维码扫出的应该是个网址。

而且掘金的二维码只能掘金 APP 扫，微信的二维码只能用微信 APP 扫。

如果用手机浏览器扫这个码的话，打开的就是下载 APP 的页面，用掘金 APP 扫码，扫出的就是登录确认页面了。

这个很正常，因为如果随便一个浏览器都能扫码打开登录确认页面，那谁还下载掘金 APP 呢？

这个页面做了检查，判断是 APP 打开的还是其他方式打开的，分别会显示不同的内容。

这里我们也改成一个 url：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694268896801-ac91adfd-1771-4cbc-bfa6-a0a71c77d02c.png)

扫码就会打开这个页面，而这个页面就是登录确认页面。

写一下这个页面，新建 static/confirm.html：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>扫码登录确认</title>
    <style>
      #info {
        height: 400px;
        line-height: 400px;
        font-size: 20px;
        padding: 20px;
      }
      #confirm,
      #cancel {
        display: block;
        width: 80%;
        line-height: 40px;
        font-size: 20px;
        margin-bottom: 20px;
      }
      #confirm {
        background: skyblue;
      }
    </style>
  </head>
  <body>
    <div id="info">是否确认登录 xxx 网站？</div>
    <button id="confirm">确认登录</button>
    <button id="cancel">取消</button>
  </body>
</html>
```

但这里有个问题，开发服务是在电脑上的，手机怎么访问呢？

这里需要 [下载 charles](https://link.juejin.cn/?target=https%3A%2F%2Fwww.charlesproxy.com%2Fdownload%2F) 来做代理：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694269042854-475ac03b-2856-4643-964e-2d7893be799b.png)

让电脑和手机连接同一个 wifi，然后在手机的 wifi 设置那里设置代理：

代理的 ip 是电脑 ip，端口号就是 charles 代理服务的默认端口 8888

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694269333990-5e7c20b9-bdf4-46d1-bbcc-0b748aea8c24.png)

这时候电脑上会收到连接提醒，同意下就好了：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694269318513-8235378a-bee4-4c93-99b9-2aa604cef331.png)

然后手机就可以访问电脑上的 nest 服务。

把二维码的内容改下：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694271575885-cfe6d973-d497-4ebf-a65b-36c1b6c1bc85.png)

修改下展示二维码的页面：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>扫码登录</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://unpkg.com/axios@1.5.0/dist/axios.min.js"></script>
  </head>
  <body>
    <img id="img" src="" alt="" />

    <script>
      axios.get('http://localhost:3000/qrcode/generate').then((res) => {
        document.getElementById('img').src = res.data.img;
      });
    </script>
  </body>
</html>
```

用 axios 请求生成二维码的接口，然后修改图片 src。

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694271633832-be20a167-df52-48be-8e09-002acec01cf9.png)

用手机扫码下：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694271657505-9225ca7c-2808-4100-be6a-eadb4d567cbd.png)

用微信扫码，可以看到，打开了登录确认页面。

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694271759944-0544a24d-67d5-4d9b-b5c8-d4b976382c6a.png)

然后我们来实现剩下的接口：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694265983071-10d98bf6-3632-44c0-bcd1-47ff6ed1fdcf.png)

生成二维码之后，要在 redis 里保存一份，这里我们简化一下，直接用个 map 保存吧。

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694271958561-472085c9-4fbd-4bfd-bf35-ad3ba99427ca.png)  
然后加一个 qrcode/check 接口，用来查询二维码状态：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694272000230-8fb635db-a115-43e5-9b0c-9c28588ba990.png)

测试下：

访问 /qrcode/generate 生成二维码和 id：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694272142013-7d72c036-4edd-4232-8201-9d44ec270aa9.png)

然后访问 /qrcode/check 携带这个 qrcode_id：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694272183626-5bae6e85-07f7-44b1-8966-f45507ddfa3a.png)

再实现 /qrcode/confirm、/qrcode/cancel、/qrcode/scan 这三个接口：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694311564999-da332ad3-8e86-46c4-9a87-1316d4384a17.png)

此时调用 qrcode/scan 修改状态，之后调用 qrcode/check 查询状态的话，状态就会修改。



接下来就在 static/index.html 里加上 qrcode/check 接口来轮询二维码状态了。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>扫码登录</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://unpkg.com/axios@1.5.0/dist/axios.min.js"></script>
  </head>
  <body>
    <img id="img" src="" alt="" />
    <div id="info"></div>
    <script>
      axios.get('http://localhost:3000/qrcode/generate').then((res) => {
        document.getElementById('img').src = res.data.img;

        queryStatus(res.data.qrcode_id);
      });

      function queryStatus(id) {
        axios.get('http://localhost:3000/qrcode/check?id=' + id).then((res) => {
          const status = res.data.status;

          let content = '';
          switch (status) {
            case 'noscan':
              content = '未扫码';
              break;
            case 'scan-wait-confirm':
              content = '已扫码，等待确认';
              break;
            case 'scan-confirm':
              content = '已确认';
              break;
            case 'scan-cancel':
              content = '已取消';
              break;
          }
          document.getElementById('info').textContent = content;

          if (status === 'noscan' || status === 'scan-wait-confirm') {
            setTimeout(() => queryStatus(id), 1000);
          }
        });
      }
    </script>
  </body>
</html>
```

生成二维码之后，就开始轮询状态了。

根据状态分别显示不同的文字，如果不是已确认或者已取消就在一秒后继续下次轮询。



改下 static/confirm.html：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>扫码登录确认</title>
    <script src="https://unpkg.com/axios@1.5.0/dist/axios.min.js"></script>
    <style>
      #info {
        height: 400px;
        line-height: 400px;
        font-size: 20px;
        padding: 20px;
      }
      #confirm,
      #cancel {
        display: block;
        width: 80%;
        line-height: 40px;
        font-size: 20px;
        margin-bottom: 20px;
      }
      #confirm {
        background: skyblue;
      }
    </style>
  </head>
  <body>
    <div id="info">是否确认登录 xxx 网站？</div>
    <button id="confirm">确认登录</button>
    <button id="cancel">取消</button>

    <script>
      const params = new URLSearchParams(window.location.search.slice(1));

      const id = params.get('id');

      axios.get('http://192.168.0.100:3000/qrcode/scan?id=' + id).catch((e) => {
        alert('二维码已过期');
      });

      document.getElementById('confirm').addEventListener('click', () => {
        axios
          .get('http://192.168.0.100:3000/qrcode/confirm?id=' + id)
          .catch((e) => {
            alert('二维码已过期');
          });
      });

      document.getElementById('cancel').addEventListener('click', () => {
        axios
          .get('http://192.168.0.100:3000/qrcode/cancel?id=' + id)
          .catch((e) => {
            alert('二维码已过期');
          });
      });
    </script>
  </body>
</html>
```

进入这个页面，就访问 qrcode/scan 接口，来把 id 对应的二维码改为已扫描状态。

点击确认或者取消按钮也分别修改状态为确认和取消。

注意，这个页面是在手机打开的，需要通过 ip 的方式访问接口。

手机扫描之后：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694312699782-2769ccad-e08d-40dc-adea-668ebb921fc5.png)

点击确认登录：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694312718626-7c0506ef-89a6-4396-8044-1c4f34c09e16.png)

点击取消：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694312779565-5554b38a-6cf4-41da-8527-5c887d5c736a.png)

这就是扫码之后，pc 上的二维码同步改变状态的原理。



接下来我们做登录：

确认之后，就要拿到这边的登录状态，从中取出用户信息。

引入 jwt 的 包：

```html
npm install @nestjs/jwt
```

 AppModule 引入它：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694312902645-1f3a5b42-239f-4999-8103-83feac771199.png)

实现登录接口：

不用数据库，固定 2 个用户，如果信息匹配，就返回 jwt 的 token：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694313029614-4998e088-3fef-440c-825f-9c441a69b9a0.png)

登录成功后，会返回 token：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694313173556-f1eba886-112d-4d56-b05d-3408fea20138.png)

登录成功后，会返回 token。

这个 token 一般都是在访问接口的时候放在 authorization 的 header 里，通过 Bearer xxx 的方式。

我们添加一个 userInfo 的接口来拿到用户信息：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694313249113-f233589f-2c9a-4ef4-9ef1-eee077b707c8.png)

从 header 中取出 token，解析出其中的信息，从而拿到 userId，然后查询 id 对应的用户信息返回。

我们加上 authorization 的 header，访问下 userInfo 接口：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694313324574-6da7bbf5-64c1-4783-a67f-4473390e94d8.png)

可以看到，拿到了用户的信息。

然后我们在登录确认页面加上登录：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>扫码登录确认</title>
    <script src="https://unpkg.com/axios@1.5.0/dist/axios.min.js"></script>
    <style>
      #info {
        height: 400px;
        line-height: 400px;
        font-size: 20px;
        padding: 20px;
      }
      #confirm,
      #cancel {
        display: block;
        width: 80%;
        line-height: 40px;
        font-size: 20px;
        margin-bottom: 20px;
      }
      #confirm {
        background: skyblue;
      }
    </style>
  </head>
  <body>
    <button id="yun">登录云云账号</button>
    <button id="mu">登录牧牧账号</button>

    <div id="info">是否确认登录 xxx 网站？</div>
    <button id="confirm">确认登录</button>
    <button id="cancel">取消</button>

    <script>
      const params = new URLSearchParams(window.location.search.slice(1));

      const id = params.get('id');

      let token = '';
      document.getElementById('mu').addEventListener('click', () => {
        axios
          .get('http://192.168.0.100:3000/login', {
            params: {
              username: 'yun',
              password: '111',
            },
          })
          .then((res) => {
            token = res.data.token;
          });
      });

      document.getElementById('yun').addEventListener('click', () => {
        axios
          .get('http://192.168.0.100:3000/login', {
            params: {
              username: 'mu',
              password: '222',
            },
          })
          .then((res) => {
            token = res.data.token;
          });
      });

      axios.get('http://192.168.0.100:3000/qrcode/scan?id=' + id).catch((e) => {
        alert('二维码已过期');
      });

      document.getElementById('confirm').addEventListener('click', () => {
        axios
          .get('http://192.168.0.100:3000/qrcode/confirm?id=' + id, {
            headers: {
              authorization: 'Bearer ' + token,
            },
          })
          .catch((e) => {
            alert('二维码已过期');
          });
      });

      document.getElementById('cancel').addEventListener('click', () => {
        axios
          .get('http://192.168.0.100:3000/qrcode/cancel?id=' + id)
          .catch((e) => {
            alert('二维码已过期');
          });
      });
    </script>
  </body>
</html>
```

我们在 qrcode/confirm 接口里把 token 取出来，拿到其中的用户信息，保存到 map 里：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694314016660-b43fb3c5-e0fd-434f-9f42-8962a2510bfb.png)

这样，当扫码确认后，那边就能拿到用户信息：



改下 static/index.html，当确认的时候展示下登录用户的信息：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694314268856-5851ece5-8032-472c-b3c7-4a06a0a4561d.png)

手机扫码，点击登录云云的账号，然后确认登录：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694314992645-de70b1b7-ebe3-49ec-a2dd-c1e084bf26c7.png)

这时候 pc 网站就显示了当前登录用户是 yun。

登录状态需要一个 jwt，我们返回下：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694315108275-3143dde3-144d-46ee-b42d-208289885ee9.png)

当手机确认登录之后，这边就拿到了 jwt 的 token，也就完成了登录：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694315875551-9f806f61-3eaa-44f9-886c-be0a45b2e996.png)



## 总结
扫码登录是常用的功能，掘金、知乎、b 站等各大网站都有。

流程是在 pc 选择扫码登录的方式，用 APP 扫码，在 app 上登录之后进入登录确认页面。

可以点击确认登录或者取消，如果确认登录，那 pc 网站就会自动登录该账号。

它的实现原理是这样的：

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1694315924087-cf2956f6-b6cc-4f05-8715-af407dc8b224.png)

pc 端生成二维码，然后不断轮询二维码状态。

APP 里扫码拿到 qrcode_id，然后分别调用 scan、confirm、cancel 来修改二维码状态。

并且登录之后会把 token 带过去。

在 redis 里保存着二维码的状态和用户信息，然后这边确认之后，另一边就可以用 userInfo 生成 jwt 的 token，从而实现登录。

这就是扫码登录的实现原理。


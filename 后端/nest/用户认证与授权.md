## 什么是认证与授权？
简单来说：

+ **认证**：确认“你是谁”。比如，验证用户输入的用户名和密码是否正确。
+ **授权**：决定“你能做什么”。比如，判断用户是否有权限删除一篇文章。

这两者相辅相成：认证是第一步，确认用户身份；授权则是第二步，根据身份决定用户的操作权限。本文将通过一个简单的博客系统示例，展示如何用 NestJS 和 JWT 实现这两部分功能。

---

## 目标：实现什么？
我们将搭建一个完整的认证与授权系统，实现以下功能：

1. 用户通过用户名和密码登录，获取 JWT 令牌。
2. 用户携带 JWT 访问受保护的资源（如查看个人资料）。
3. 根据用户角色（如管理员或普通用户），限制对某些接口的访问。
4. 支持公共路由（无需认证）和全局认证。

最终效果：

+ 用户登录后获得 JWT 令牌。
+ 普通用户可以访问自己的资料，管理员可以访问管理接口。
+ 未登录用户或无权限用户会被拦截。

---

## 第一步：搭建基础认证架构
### 1.1 创建用户服务
我们先创建一个简单的用户服务（`UsersService`），用于管理用户数据。在实际项目中，你会连接数据库（如 MongoDB 或 PostgreSQL），但为了演示，我们用内存数组模拟：

```typescript
// users/users.service.ts
import { Injectable } from '@nestjs/common';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UsersService {
  // 模拟数据库中的用户数据
  private readonly users = [
    {
      userId: 1,
      username: 'admin',
      password: await bcrypt.hash('admin123', 10), // 密码需加密
      roles: ['admin'],
    },
    {
      userId: 2,
      username: 'user',
      password: await bcrypt.hash('user123', 10),
      roles: ['user'],
    },
  ];

  async findOne(username: string) {
    return this.users.find((user) => user.username === username);
  }
}
```

**安全提醒**：密码必须使用 `bcrypt` 等库进行哈希存储，防止明文泄露。以上代码中，我们用 `bcrypt.hash` 加密密码。

### 1.2 配置用户模块
将 `UsersService` 注册到模块中，方便其他模块使用：

```typescript
// users/users.module.ts
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({
  providers: [UsersService],
  exports: [UsersService], // 导出服务，供其他模块使用
})
export class UsersModule {}
```

---

## 第二步：实现登录逻辑
### 2.1 安装并配置 JWT
我们需要安装 JWT 相关依赖并配置密钥：

```bash
npm install @nestjs/jwt
```

在认证模块中配置 JWT：

```typescript
// auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { UsersModule } from '../users/users.module';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';

@Module({
  imports: [
    UsersModule,
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET || 'your-secret-key', // 建议使用环境变量
      signOptions: { expiresIn: '1h' }, // 令牌有效期 1 小时
    }),
  ],
  providers: [AuthService],
  controllers: [AuthController],
})
export class AuthModule {}
```

**安全提醒**：JWT 密钥应通过环境变量（如 `.env` 文件）存储，切勿硬编码在代码中。

### 2.2 实现认证服务
认证服务（`AuthService`）负责验证用户身份并签发 JWT：

```typescript
// auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  async signIn(username: string, password: string) {
    const user = await this.usersService.findOne(username);
    if (!user || !(await bcrypt.compare(password, user.password))) {
      throw new UnauthorizedException('用户名或密码错误');
    }

    // 生成 JWT 令牌
    const payload = { sub: user.userId, username: user.username, roles: user.roles };
    return {
      access_token: await this.jwtService.signAsync(payload),
    };
  }
}
```

这里我们：

1. 查找用户并验证密码。
2. 如果验证通过，生成包含用户 ID、用户名和角色的 JWT 令牌。
3. 如果失败，抛出 `UnauthorizedException`。

### 2.3 创建登录接口
通过控制器提供登录接口：

```typescript
// auth/auth.controller.ts
import { Controller, Post, Body, HttpCode, HttpStatus } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  async signIn(@Body() signInDto: { username: string; password: string }) {
    return this.authService.signIn(signInDto.username, signInDto.password);
  }
}
```

测试登录接口（使用 Postman 或 cURL）：

```bash
POST http://localhost:3000/auth/login
Content-Type: application/json

{
  "username": "admin",
  "password": "admin123"
}
```

成功响应：

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

---

## 第三步：保护路由与授权
### 3.1 创建认证守卫
我们需要一个 `AuthGuard` 来验证请求中的 JWT 令牌：

```typescript
// auth/auth.guard.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Request } from 'express';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest<Request>();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      throw new UnauthorizedException('未提供令牌');
    }

    try {
      const payload = await this.jwtService.verifyAsync(token);
      request['user'] = payload; // 将用户信息附加到请求对象
    } catch {
      throw new UnauthorizedException('令牌无效或已过期');
    }

    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

这个守卫会：

1. 从请求头中提取 `Bearer Token`。
2. 验证 JWT 的有效性。
3. 如果有效，将用户数据附加到 `request.user` 中。

### 3.2 保护路由
在控制器中使用 `AuthGuard` 保护敏感接口：

```typescript
// auth/auth.controller.ts
import { Controller, Get, Post, Body, HttpCode, HttpStatus, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  async signIn(@Body() signInDto: { username: string; password: string }) {
    return this.authService.signIn(signInDto.username, signInDto.password);
  }

  @UseGuards(AuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user; // 返回用户信息
  }
}
```

测试受保护路由：

+ **无令牌访问**：

```bash
GET http://localhost:3000/auth/profile
```

响应：

```json
{
  "statusCode": 401,
  "message": "未提供令牌",
  "error": "Unauthorized"
}
```

+ **携带有效令牌**：

```bash
GET http://localhost:3000/auth/profile
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

响应：

```json
{
  "sub": 1,
  "username": "admin",
  "roles": ["admin"],
  "iat": 1623456789,
  "exp": 1623460389
}
```

---

## 第四步：实现基于角色的授权（RBAC）
### 4.1 定义角色
使用枚举定义系统中的角色：

```typescript
// enums/role.enum.ts
export enum Role {
  Admin = 'admin',
  User = 'user',
}
```

### 4.2 创建 @Roles 装饰器
创建一个装饰器，用于指定接口所需的角色：

```typescript
// decorators/roles.decorator.ts
import { SetMetadata } from '@nestjs/common';
import { Role } from '../enums/role.enum';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);
```

### 4.3 创建 RolesGuard
`RolesGuard` 负责检查用户是否具有所需角色：

```typescript
// guards/roles.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorators/roles.decorator';
import { Role } from '../enums/role.enum';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      return true; // 没有角色要求，直接放行
    }

    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user?.roles?.includes(role));
  }
}
```

### 4.4 应用角色守卫
在控制器中使用 `@Roles` 装饰器：

```typescript
// auth/auth.controller.ts
import { Controller, Get, Post, Body, HttpCode, HttpStatus, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { Roles } from '../decorators/roles.decorator';
import { RolesGuard } from '../guards/roles.guard';
import { Role } from '../enums/role.enumiteral

enum Role {
  Admin = 'admin',
  User = 'user',
}

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  async signIn(@Body() signInDto: { username: string; password: string }) {
    return this.authService.signIn(signInDto.username, signInDto.password);
  }

  @UseGuards(AuthGuard, RolesGuard)
  @Roles(Role.Admin)
  @Get('admin')
  getAdminData(@Request() req) {
    return { message: '欢迎访问管理员面板', user: req.user };
  }

  @UseGuards(AuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}
```

### 4.5 注册全局守卫
将 `AuthGuard` 和 `RolesGuard` 设为全局守卫：

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { AuthGuard } from './auth/auth.guard';
import { RolesGuard } from './guards/roles.guard';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';

@Module({
  imports: [AuthModule, UsersModule],
  providers: [
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
    {
      provide: APP_GUARD,
      useClass: RolesGuard,
    },
  ],
})
export class AppModule {}
```

现在，访问 `/auth/admin` 需要管理员角色，否则返回 403 错误。

---

## 第五步：支持公共路由
有些接口（如登录接口）不需要认证，我们可以用 `@Public` 装饰器标记：

### 5.1 创建 @Public 装饰器
```typescript
// decorators/public.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
```

### 5.2 增强 AuthGuard
修改 `AuthGuard` 以支持公共路由：

```typescript
// auth/auth.guard.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Reflector } from '@nestjs/core';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';
import { Request } from 'express';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true; // 公共路由无需认证
    }

    const request = context.switchToHttp().getRequest<Request>();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      throw new UnauthorizedException('未提供令牌');
    }

    try {
      const payload = await this.jwtService.verifyAsync(token);
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException('令牌无效或已过期');
    }

    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

### 5.3 使用 @Public 装饰器
将登录接口标记为公共路由：

```typescript
// auth/auth.controller.ts
import { Public } from '../decorators/public.decorator';

// ...
@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Public()
  @HttpCode(HttpStatus.OK)
  @Post('login')
  async signIn(@Body() signInDto: { username: string; password: string }) {
    return this.authService.signIn(signInDto.username, signInDto.password);
  }

  // 其他接口保持不变
}
```

现在，`/auth/login` 不需要 JWT 即可访问，而其他接口（如 `/auth/profile` 和 `/auth/admin`）仍受保护。

---

## 安全最佳实践
在生产环境中部署时，务必注意以下几点：

1. **密码安全**：使用 `bcrypt` 或 `argon2` 加密密码，切勿存储明文。
2. **密钥管理**：JWT 密钥通过环境变量或密钥管理服务（如 AWS KMS）存储。
3. **令牌有效期**：设置合理的 JWT 过期时间（如 1 小时），并考虑使用刷新令牌机制。
4. **HTTPS**：所有认证相关通信必须使用 HTTPS 加密。
5. **错误处理**：避免在错误信息中泄露敏感信息（如“用户不存在”）。
6. **日志与监控**：记录认证失败尝试，监控异常行为。
7. **权限粒度**：在复杂系统中，考虑更细粒度的权限控制（如基于资源的权限）。

---

## 总结
通过以上步骤，我们实现了一个基于 NestJS 和 JWT 的完整认证与授权系统：

+ 用户通过用户名和密码登录，获取 JWT 令牌。
+ 受保护路由需要有效 JWT，并通过 `RolesGuard` 限制角色访问。
+ 公共路由（如登录接口）无需认证。
+ 系统遵循安全最佳实践，易于扩展到数据库集成、刷新令牌等高级功能。

这个系统适合中小型项目，简单易用且安全可靠。如果需要更复杂的权限管理，可以扩展 RBAC 或引入外部认证服务（如 Auth0）。


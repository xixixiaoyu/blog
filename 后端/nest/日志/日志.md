日志记录是现代应用的“黑匣子”，不仅帮助开发者调试代码，还为生产环境提供关键的监控和问题追踪能力。

Nest 提供了一套强大而灵活的内置日志系统，兼顾开箱即用的便利性和高度可定制的扩展性。

## 快速上手：基础日志配置
Nest 应用启动时，会打印这些日志：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1748069961376-52cdae12-90e3-41a7-ad7d-5315bfb02e5f.png)

Nest 有内置日志记录器（`ConsoleLogger`）简单易用，支持多种配置方式，让你轻松控制日志行为：

```typescript
// 完全禁用日志
const app = await NestFactory.create(AppModule, { logger: false });

// 仅显示错误和警告
const app = await NestFactory.create(AppModule, { logger: ['error', 'warn'] });
```

Nest 支持以下日志级别，从最详细到最严重：verbose、debug、log、warn、error、fatal。

你可以根据环境需求灵活选择。例如，开发时开启 verbose 保留完整信息，生产环境只保留 error 和 warn 以减少 I/O 开销。



## 美化日志输出
为了提升开发体验，Nest 允许自定义日志格式，满足调试和可读性需求：

```typescript
// 禁用彩色输出（适合生产环境）
const app = await NestFactory.create(AppModule, {
  logger: new ConsoleLogger({ colors: false })
});

// 添加自定义前缀
const app = await NestFactory.create(AppModule, {
  logger: new ConsoleLogger({ prefix: 'MyApp' })
});

// 启用时间戳
const logger = new Logger('MyService', { timestamp: true });
```

输出示例：

```bash
[MyApp] 19096 - 05/24/2025, 9:56:00 AM [MyService] Processing order +5ms
```

时间戳会显示与上一条日志的时间差（如 +5ms），便于性能分析。



## JSON 结构化日志
在生产环境中，JSON 格式的日志因其结构清晰、易于解析，成为与日志分析系统（如 ELK、Splunk）集成的首选：

```typescript
const app = await NestFactory.create(AppModule, {
  logger: new ConsoleLogger({ json: true })
});
```

输出示例：

```json
{
  "level": "error",
  "pid": 19096,
  "timestamp": 1742644560000,
  "message": "Database connection failed",
  "context": "DatabaseService"
}
```

⚠️ 启用 `json: true` 会默认禁用颜色输出以确保合法 JSON 格式。如需在开发环境中保留颜色，可显式设置 `colors: true`，但需注意调试工具的兼容性。



## 在服务中使用日志
业务逻辑中，推荐使用 `Logger` 类并注入上下文以区分日志来源：

```typescript
import { Injectable, Logger } from '@nestjs/common';

@Injectable()
class OrderService {
  private readonly logger = new Logger(OrderService.name, { timestamp: true });

  processOrder(order: Order) {
    this.logger.debug(`Processing order ${order.id}`);
    try {
      // 业务逻辑
      this.logger.log(`Order ${order.id} processed successfully`);
    } catch (error) {
      this.logger.error(`Order ${order.id} failed`, error.stack);
    }
  }
}
```

这种方式确保日志带上 `[OrderService]` 上下文标记，便于追踪来源，且与全局日志配置无缝集成。



## <font style="color:rgb(38, 38, 38);">自定义 Logger 类</font>
### <font style="color:rgb(38, 38, 38);">创建自定义 Logger</font>
对于复杂需求，Nest 支持通过继承 `ConsoleLogger` 或实现 `LoggerService` 接口进行深度定制：

```typescript
// custom-logger.service.ts
import { Injectable, LoggerService } from '@nestjs/common';

@Injectable()
export class CustomLogger implements LoggerService {
  log(message: any, context?: string) {
    console.log(`[LOG] ${new Date().toISOString()} [${context}] ${message}`);
  }

  error(message: any, trace?: string, context?: string) {
    console.error(`[ERROR] ${new Date().toISOString()} [${context}] ${message}`);
    if (trace) {
      console.error(trace);
    }
  }

  warn(message: any, context?: string) {
    console.warn(`[WARN] ${new Date().toISOString()} [${context}] ${message}`);
  }

  debug(message: any, context?: string) {
    console.debug(`[DEBUG] ${new Date().toISOString()} [${context}] ${message}`);
  }

  verbose(message: any, context?: string) {
    console.log(`[VERBOSE] ${new Date().toISOString()} [${context}] ${message}`);
  }
}
```

### <font style="color:rgb(38, 38, 38);">注册自定义 Logger</font>
```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { CustomLogger } from './custom-logger.service';

@Module({
  providers: [CustomLogger],
  exports: [CustomLogger],
})
export class AppModule {}
```

### 在应用启动时启用
```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { CustomLogger } from './custom-logger.service';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // 使用自定义 logger
  app.useLogger(app.get(CustomLogger));
  
  await app.listen(3000);
}
bootstrap();
```

随后就可以愉快的在服务中使用了。

我们还可以把自定义 Logger 封装为全局模块或动态模块，根据情况自行选择即可。



## 生产环境最佳实践
1. **开发环境**：启用彩色日志和 `verbose` 级别，便于调试。
2. **测试环境**：保留 `debug` 和 `verbose` 级别，记录完整执行轨迹。
3. **生产环境**： 
    - 使用 JSON 结构化日志，便于集成 ELK、Splunk 等日志分析系统。
    - 合理设置日志级别（如 `error` 和 `warn`），避免 I/O 性能瓶颈。
    - 集成专业日志库（如 Winston 或 Pino）实现日志轮转和文件分割。



## 常见问题与解决方案
### 如何避免日志丢失？
使用 `bufferLogs: true` 缓存启动日志，确保自定义日志器生效前无遗漏。

### 如何处理敏感信息？
重写日志方法，添加脱敏逻辑：

```typescript
export class SafeLogger extends ConsoleLogger {
  log(message: string) {
    super.log(this.maskSensitiveData(message));
  }

  private maskSensitiveData(message: string): string {
    return message.replace(/\d{16}/g, '****-****-****-****'); // 隐藏信用卡号
  }
}
```

### 如何实现日志文件分割？
集成 Winston 或 Pino，配置 `dailyRotateFile` 或类似 transport 实现按日期或大小分割。



## 总结
NestJS 的日志系统兼具简单性和灵活性，适合从快速开发到企业级应用的各种场景。

通过基础配置，你可以快速启用日志；通过高级定制和 DI 集成，你能打造符合生产需求的日志方案。

结合 JSON 格式、第三方库和最佳实践，NestJS 让你轻松掌控应用的“黑匣子”，为调试和运维提供强大支持。


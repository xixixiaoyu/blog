## 为什么选择拦截器？
拦截器是 NestJS 提供的一种面向切面编程 (AOP) 的机制，它可以在请求到达路由处理函数之前或之后执行特定逻辑。相比在每个路由里手动写日志代码，使用拦截器可以让代码更简洁、复用性更强，维护起来也更轻松。

我们的目标是：

1. 记录请求的 HTTP 方法、路径、客户端 IP、User-Agent 等信息。
2. 解决反向代理场景下获取真实 IP 的问题。
3. 拓展功能，通过 IP 查询地理位置，丰富日志内容。

---

## 第一步：创建基础拦截器
假设你已经有一个 NestJS 项目（如果没有，可以用 `nest new project-name` 创建）。

我们先用 Nest CLI 生成一个拦截器：

```bash
nest g interceptor request-log --no-spec --flat
```

这会在 `src` 目录下生成 `request-log.interceptor.ts` 文件。接下来，我们来实现基础的日志功能：

```typescript
// src/request-log.interceptor.ts
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import { Request, Response } from 'express';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class RequestLogInterceptor implements NestInterceptor {
  private readonly logger = new Logger(RequestLogInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();

    const { method, path, ip } = request;
    const userAgent = request.headers['user-agent'] || '未知';

    // 记录请求信息
    this.logger.debug(
      `[请求] ${method} ${path} - IP: ${ip} - User-Agent: ${userAgent} - ` +
      `${context.getClass().name}.${context.getHandler().name}`,
    );

    const startTime = Date.now();

    // 使用 tap 操作符记录响应信息
    return next.handle().pipe(
      tap((data) => {
        const duration = Date.now() - startTime;
        this.logger.debug(
          `[响应] ${method} ${path} - IP: ${ip} - 状态: ${response.statusCode} - 耗时: ${duration}ms`,
        );
        this.logger.debug(`响应内容: ${JSON.stringify(data)}`);
      }),
    );
  }
}
```

**代码解析：**

+ 我们通过 `ExecutionContext` 获取请求和响应对象，提取方法、路径、IP 和 User-Agent。
+ 使用 `Logger` 类的 `debug` 方法记录日志，方便调试时查看。
+ `tap` 操作符让我们在不干扰响应流的情况下记录响应信息，包括状态码和处理耗时。

---

## 第二步：全局注册拦截器
要让拦截器对所有请求生效，可以在 `AppModule` 中全局注册：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { RequestLogInterceptor } from './request-log.interceptor';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: APP_INTERCEPTOR,
      useClass: RequestLogInterceptor,
    },
  ],
})
export class AppModule {}
```

启动项目（`npm run start:dev`），访问 `http://localhost:3000`，你会在控制台看到类似以下的日志：

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1753024811521-6e59eb90-c31f-4994-831c-50fed890fb1b.png)

---

## 第三步：获取真实客户端 IP
在开发环境中，`request.ip` 通常是 `::1`（本地回环地址）。

但在生产环境中，如果应用部署在 Nginx 或其他反向代理后面，`request.ip` 可能会返回代理服务器的 IP，而不是用户的真实 IP。真实 IP 通常在 `X-Forwarded-For` 头中。

为了准确获取客户端 IP，我们使用 `request-ip` 库：

```bash
npm install --save request-ip
```

更新拦截器代码：

```typescript
// src/request-log.interceptor.ts
import * as requestIp from 'request-ip';
// ... 其他导入保持不变

@Injectable()
export class RequestLogInterceptor implements NestInterceptor {
  private readonly logger = new Logger(RequestLogInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();

    const { method, path } = request;
    const clientIp = requestIp.getClientIp(request); // 获取真实 IP
    const userAgent = request.headers['user-agent'] || '未知';

    this.logger.debug(
      `[请求] ${method} ${path} - IP: ${clientIp} - User-Agent: ${userAgent} - ` +
      `${context.getClass().name}.${context.getHandler().name}`,
    );

    const startTime = Date.now();

    return next.handle().pipe(
      tap((data) => {
        const duration = Date.now() - startTime;
        this.logger.debug(
          `[响应] ${method} ${path} - IP: ${clientIp} - 状态: ${response.statusCode} - 耗时: ${duration}ms`,
        );
        this.logger.debug(`响应内容: ${JSON.stringify(data)}`);
      }),
    );
  }
}
```

`request-ip` 会自动解析 `X-Forwarded-For` 等头信息，处理多种代理场景，确保我们获取到真实的客户端 IP。

显示 ::1 是正常的，这是 IPv6 的 localhost 地址，在本地开发环境中，请求确实来自本地，在生产环境中配置了代理（如 Nginx、Cloudflare、AWS ALB）后，会正确获取真实客户端 IP。

---

## 第四步：拓展功能——查询 IP 地理位置
有时候，日志里加上地理位置信息会更有用，比如记录用户登录时的城市。

我们可以通过调用第三方 IP 查询服务来实现，比如国内常用的 Pacific Network IP 查询接口。

**注意：** 频繁调用外部 API 会影响性能，建议仅在关键场景（如用户登录）使用，或通过缓存优化。

1. **安装依赖**使用 `@nestjs/axios` 发送 HTTP 请求，并用 `iconv-lite` 处理 GBK 编码（国内接口常返回 GBK 编码数据）：

```bash
npm install --save @nestjs/axios axios iconv-lite
```

2. **注册 **`HttpModule`在 `AppModule` 中引入 `HttpModule`：

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { HttpModule } from '@nestjs/axios';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { RequestLogInterceptor } from './request-log.interceptor';

@Module({
  imports: [HttpModule],
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: APP_INTERCEPTOR,
      useClass: RequestLogInterceptor,
    },
  ],
})
export class AppModule {}
```

3. **更新拦截器，添加 IP 查询**修改 `request-log.interceptor.ts`，增加地理位置查询功能：

```typescript
// src/request-log.interceptor.ts
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { Request, Response } from 'express';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import * as requestIp from 'request-ip';
import * as iconv from 'iconv-lite';

@Injectable()
export class RequestLogInterceptor implements NestInterceptor {
  private readonly logger = new Logger(RequestLogInterceptor.name);

  constructor(private readonly httpService: HttpService) {}

  // 查询 IP 地理位置
  private async getCityFromIp(ip: string): Promise<string> {
    if (ip.includes('127.0.0.1') || ip.includes('::1')) {
      return '本地';
    }
    try {
      const url = `https://whois.pconline.com.cn/ipJson.jsp?ip=${ip}&json=true`;
      const response = await this.httpService.axiosRef.get(url, {
        responseType: 'arraybuffer',
      });
      const dataStr = iconv.decode(response.data, 'gbk');
      const data = JSON.parse(dataStr);
      return data.addr?.trim() || '未知';
    } catch (error) {
      this.logger.error(`IP 查询失败: ${ip}`, error.message);
      return '未知';
    }
  }

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();

    const { method, path } = request;
    const clientIp = requestIp.getClientIp(request);
    const userAgent = request.headers['user-agent'] || '未知';
    const city = await this.getCityFromIp(clientIp);

    this.logger.debug(
      `[请求] ${method} ${path} - IP: ${clientIp} (${city}) - User-Agent: ${userAgent} - ` +
      `${context.getClass().name}.${context.getHandler().name}`,
    );

    const startTime = Date.now();

    return next.handle().pipe(
      tap((data) => {
        const duration = Date.now() - startTime;
        this.logger.debug(
          `[响应] ${method} ${path} - IP: ${clientIp} (${city}) - 状态: ${response.statusCode} - 耗时: ${duration}ms`,
        );
        this.logger.debug(`响应内容: ${JSON.stringify(data)}`);
      }),
    );
  }
}
```

**代码解析：**

+ `getCityFromIp` 方法使用 Pacific Network 的免费 IP 查询接口，返回 JSON 数据。
+ 使用 `iconv-lite` 将 GBK 编码的响应解码为 UTF-8，防止乱码。
+ 为避免阻塞，方法标记为 `async`，并在 `intercept` 中使用 `await`。
+ 对本地 IP 和异常情况做了处理，确保代码健壮。

![](https://cdn.nlark.com/yuque/0/2025/png/21596389/1753025992630-42f0eeba-62cf-40fa-b246-dff889e2fcb9.png)

---

## 第五步：优化和注意事项
1. **性能优化**  
每次请求都调用外部 IP 查询 API 会显著增加响应时间。实际生产中，建议：

示例缓存方案（伪代码）：

```typescript
import { Cache } from 'cache-manager';

private async getCityFromIp(ip: string, cache: Cache): Promise<string> {
  const cachedCity = await cache.get(ip);
  if (cachedCity) return cachedCity;
  const city = await this.queryCityFromApi(ip);
  await cache.set(ip, city, { ttl: 3600 }); // 缓存 1 小时
  return city;
}
```

    - 使用 Redis 或内存缓存存储 IP 对应的城市信息，减少重复查询。
    - 只在特定场景（如用户登录、注册）触发 IP 查询，而不是对所有请求都查。
2. **日志存储**  
控制台日志适合开发调试，但生产环境中应将日志写入文件或数据库（如 ELK、Loki）。可以使用 `winston` 或 `@nestjs/terminus` 集成更强大的日志系统。
3. **安全考虑**  
    - 避免在日志中记录敏感信息（如密码、Token）。
    - 对响应内容使用 `JSON.stringify` 时，注意大型响应体的性能影响，必要时截断或跳过。

---

## 总结
通过这个教程，我们实现了一个功能强大的 NestJS 请求日志拦截器，涵盖了：

1. **基础日志**：记录请求方法、路径、IP、User-Agent 和响应状态、耗时。
2. **真实 IP 获取**：使用 `request-ip` 解决反向代理场景的 IP 获取问题。
3. **地理位置查询**：通过第三方 API 添加城市信息，处理了编码问题。
4. **优化建议**：介绍了缓存和日志存储的改进方向。

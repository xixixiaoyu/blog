## 创建数据库
首先，创建一个新的数据库：

```bash
CREATE SCHEMA login_test DEFAULT CHARACTER SET utf8mb4;
```

utf8mb4 字符集可以存储包含表情符号在内的特殊字符。

![](https://cdn.nlark.com/yuque/0/2023/png/21596389/1688052820883-de0c6457-7392-4137-852c-046235427504.png)



## 创建 Nest 项目
使用 Nest CLI 创建一个新的项目：

```bash
nest new login-and-register -p pnpm
```

进入项目，安装 TypeORM 和 MySQL 依赖：

```bash
pnpm install @nestjs/typeorm typeorm mysql2
```

在 AppModule 中引入 TypeOrmModule 并配置数据库连接：

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'xxx',
      database: 'login_test',
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
        authPlugin: 'sha256_password',
      },
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```



## 创建 User 模块
生成 User 模块：

```typescript
nest g resource user
```

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716710321320-60c6244f-ada3-43ad-87e2-f4844f9fa6b4.png)

定义 User 实体类：

```typescript
import {
  Column,
  CreateDateColumn,
  Entity,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    length: 50,
    comment: '用户名',
  })
  username: string;

  @Column({
    length: 50,
    comment: '密码',
  })
  password: string;

  @CreateDateColumn({
    comment: '创建时间',
  })
  createTime: Date;

  @UpdateDateColumn({
    comment: '更新时间',
  })
  updateTime: Date;
}
```

在 AppModule 中引入 User 实体类：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716711005093-9ea5637a-e3ae-45da-8fea-9edf4e642491.png)

运行项目：

```bash
pnpm start:dev
```

查看新建的 user 表： 

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716711061940-4cc73fca-ca3b-474f-b62e-960dac454f4c.png)

在 UserModule 中引入 TypeOrm.forFeature 动态模块：

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UserService } from './user.service';
import { UserController } from './user.controller';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UserController],
  providers: [UserService],
})
export class UserModule {}
```

然后就来实现 User 的增删改查。



## 实现 UserController 和 UserService
在 UserController 中添加登录和注册处理函数：

```typescript
import { Controller, Post, Body } from '@nestjs/common';
import { UserService } from './user.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    return await this.userService.login(loginDto);
  }

  @Post('register')
  async register(@Body() registerDto: RegisterDto) {
    return await this.userService.register(registerDto);
  }
}
```

创建对应的两个 dto：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716711212605-7d5e1579-0794-4310-b6c6-23f093ed5128.png)

可以用 class-validator class-transformer 做具体校验，我们这里简单做：

```typescript
export class LoginDto {
  username: string;
  password: string;
}
```

```typescript
export class RegisterDto {
  username: string;
  password: string;
}
```

在 UserService 中实现登录和注册逻辑：

```typescript
import { Injectable, HttpException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import * as crypto from 'crypto';

@Injectable()
export class UserService {
  private readonly logger = new Logger(UserService.name);

  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  // 使用 MD5 算法对字符串进行加密
  private md5(str: string): string {
    const hash = crypto.createHash('md5');
    hash.update(str);
    return hash.digest('hex');
  }

  async register(registerDto: RegisterDto): Promise<string> {
    // 检查用户名是否已存在
    const existingUser = await this.userRepository.findOne({
      where: { username: registerDto.username },
    });

    if (existingUser) {
      throw new HttpException('用户已存在', 400);
    }

    // 创建新用户并对密码进行加密
    const newUser = this.userRepository.create({
      username: registerDto.username,
      password: this.md5(registerDto.password),
    });

    try {
      // 保存新用户到数据库
      await this.userRepository.save(newUser);
      return '注册成功';
    } catch (error) {
      this.logger.error(error);
      throw new HttpException('注册失败', 500);
    }
  }

  async login(loginDto: LoginDto): Promise<User> {
    // 根据用户名查找用户
    const user = await this.userRepository.findOne({
      where: { username: loginDto.username },
    });

    if (!user) {
      throw new HttpException('用户名不存在', 400);
    }

    if (user.password !== this.md5(loginDto.password)) {
      throw new HttpException('密码错误', 400);
    }

    return user;
  }
}
```



## 测试注册和登录
使用 Postman 测试 /user/register 和 /user/login 接口：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716711556154-4fcc7b9a-5b2b-419e-a8da-67d807516544.png)

继续注册：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716711673934-241a910c-3941-438a-868f-d1a9dfc320d2.png)

我们去登录下：

错误的应户名：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716711813996-4c3958e9-86fb-4c94-bc0e-e810d53836b3.png)

正确用户名，但错误密码：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716712174201-691371b5-e4b8-412c-bf31-9308b8b81597.png)

正确的用户名，正确返回：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716711606768-d98b9cc1-f03b-498f-b89d-d934f62c9992.png)

表中也有数据了：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716711726999-2de3db7d-134c-4192-b68e-f671b95c38ab.png)



## 使用 JWT 实现鉴权
安装 JWT 相关包：

```bash
pnpm install @nestjs/jwt
```

在 AppModule 中配置 JwtModule：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716712859878-9b2031b5-a747-4183-8734-768443195605.png)

在 UserController 中实现登录成功后的 JWT 生成和返回：

```typescript
import { Controller, Post, Body } from '@nestjs/common';
import { UserService } from './user.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { JwtService } from '@nestjs/jwt';

@Controller('user')
export class UserController {
  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
  ) {}

  @Post('login')
  async login(@Body() user: LoginDto) {
    const foundUser = await this.userService.login(user);

    if (foundUser) {
      const token = await this.jwtService.signAsync({
        user: {
          id: foundUser.id,
          username: foundUser.username,
        },
      });
      return {
        token,
      };
    } else {
      return 'login fail';
    }
  }

  @Post('register')
  async register(@Body() registerDto: RegisterDto) {
    return await this.userService.register(registerDto);
  }
}
```



## 保护路由
创建一个 Guard 来验证 JWT：

```bash
nest g guard login --no-spec --flat
```

```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Request } from 'express';

@Injectable()
export class LoginGuard implements CanActivate {
  constructor(private readonly jwtService: JwtService) {}

  canActivate(context: ExecutionContext): boolean {
    const request: Request = context.switchToHttp().getRequest();
    const authHeader = request.headers.authorization;

    if (!authHeader) {
      throw new UnauthorizedException('未提供认证令牌');
    }

    const [bearer, token] = authHeader.split(' ');

    if (bearer !== 'Bearer' || !token) {
      throw new UnauthorizedException('令牌格式无效');
    }

    try {
      const payload = this.jwtService.verify(token);
      (request as any).user = payload;
      return true;
    } catch (e) {
      throw new UnauthorizedException('令牌无效或已过期');
    }
  }
}
```

在需要保护的路由中使用 LoginGuard：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716715006239-39cca7bb-dc15-45f1-9231-8ee1949a0f54.png)

测试下：

不带 token 访问：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716715034294-58e5e865-6aa8-47cc-9ead-2de6947dabad.png)



![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716715380051-2fa47808-8ca3-4cfe-8c72-7359ede20296.png)

带上 token 访问：

![](https://cdn.nlark.com/yuque/0/2024/png/21596389/1716715696837-84e962dc-1d51-4a56-865f-f64de512a50e.png)


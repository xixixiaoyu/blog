我们可以把 Docker 容器想象成一座座独立的房子，而你的宿主机就是它们所在的城市。

网络要解决的问题就是：**如何让这些房子既能保持独立，又能按需与外界（或其他房子）通信呢？**

要理解网络模式，我们得先了解三个 Linux 内核提供的“积木”：

1. **Network Namespace (网络命名空间)**：这是实现网络隔离的关键。每个容器都有自己独立的网络命名空间，就像给每座房子分配了一个独立的、与世隔绝的院子。院子里的网络设备（网卡、路由表、iptables 规则等）都是独立的，看不到其他院子里的情况。
2. **Veth Pair (Virtual Ethernet Pair)**：这是一对虚拟网卡，像一根特殊的管道，一端在容器的命名空间（房子里），另一端在宿主机的根命名空间（街道上）。从一端进入的数据包会原封不动地从另一端出来，它是连接容器与宿主机网络的桥梁。
3. **Bridge (网桥)**：这是一个虚拟的二层交换机，工作在宿主机上。它就像一个小区的物业中心或交换机，可以连接多个 `veth pair` 的一端，让连接在上面的各个容器（房子）之间可以相互通信。

理解了这三点，我们再来看具体的网络模式，就会豁然开朗。

Docker 提供了四种主要的原生网络模式。

#### 1. Bridge 模式（默认模式）

```bash
# 默认就是 bridge 模式
docker run -d --name my-nginx -p 8080:80 nginx
```

这是 Docker 的默认网络模式。当你不指定 `--network` 时，容器就会加入这个模式。

**工作原理**：

1. Docker 在宿主机上创建一个名为 `docker0` 的虚拟网桥。
2. 每次创建新容器时，Docker 会创建一对 `veth pair`。
3. `veth pair` 的一端（如 `eth0`）被放入容器的网络命名空间，并分配一个私有 IP（通常是 `172.17.0.0/16` 网段）。
4. `veth pair` 的另一端（如 `vethxxx`）被连接到宿主机的 `docker0` 网桥上。
5. `docker0` 网桥通过 NAT（网络地址转换）技术，让容器可以访问外网。

**特点**：

- **隔离性好**：每个容器都有独立的网络栈，互不影响。
- **可访问外网**：通过 NAT，容器可以自由访问互联网。
- **端口映射**：外网无法直接访问容器。需要通过 `-p` 参数将宿主机的端口映射到容器的端口，就像给小区的某个房子（容器）分配一个公开的门牌号（宿主机端口）。

**适用场景**：绝大多数单主机应用场景。比如，一个 Web 应用服务器和一个数据库服务器，它们都需要与外网交互，但彼此之间也需要隔离。



#### 2. Host 模式

```bash
# 容器内的 Nginx 将直接监听在宿主机的 80 端口
docker run -d --name my-nginx-host --network host nginx
```

在这种模式下，容器将不会获得独立的网络命名空间，而是与宿主机共享网络栈。

**工作原理**：

- 容器直接使用宿主机的 IP 地址和所有端口。
- 它没有自己的 `eth0`，看到的网络配置和宿主机 `ifconfig` 看到的一模一样。

**特点**：

- **性能最高**：没有 NAT 转换和虚拟网络的开销，网络性能接近原生。
- **无隔离性**：容器与宿主机共享网络，端口不能冲突。如果容器占用了 80 端口，宿主机就不能再使用 80 端口。
- **无需端口映射**：容器中运行的服务直接绑定在宿主机的端口上，外部可以直接访问。

**适用场景**：对网络性能要求极高的场景，或者需要监控宿主机网络的工具（如 `nmap`、`tcpdump`）。



#### 3. None 模式

```bash
# 这个容器将完全无法通过网络访问
docker run -d --name my-batch-job --network none my-batch-image
```

这种模式下，容器拥有自己的网络命名空间，但 Docker 不会为它进行任何网络配置。

**工作原理**：

- 容器创建后，只有一个 `lo`（回环）网卡。
- 没有任何 `veth pair`，没有 IP，无法与外界通信。

**特点**：

- **绝对隔离**：网络上是“孤岛”，最安全。
- **无法通信**：默认情况下，既不能访问外网，也不能被其他容器访问。

**适用场景**：对安全性要求极高，且不需要网络连接的后台任务或批处理任务。也可以用于需要自定义网络配置的场景，由用户手动配置网络。



#### 4. Container 模式

```bash
# 先启动一个容器
docker run -d --name my-app my-app-image

# 再启动一个容器，共享 my-app 的网络
# 在 my-logger 容器里，可以通过 localhost:8080 访问 my-app 的服务
docker run -d --name my-logger --network container:my-app my-logger-image
```

这种模式下，一个新创建的容器将与一个已存在的容器共享网络命名空间。

**工作原理**：

- 两个容器共享同一个 IP 地址、端口范围和网络配置。
- 它们之间的通信就像在同一个机器上的两个进程一样，通过 `localhost` 即可高效通信。

**特点**：

- **高效通信**：共享网络栈的容器间通信效率极高。
- **端口共享**：两个容器不能绑定相同的端口，否则会冲突。
- **紧耦合**：通常用于将紧密相关的服务（如主应用和其日志收集 sidecar）部署在一起。

**适用场景**：Pod 的概念雏形。一个主应用容器和一个辅助容器（如日志代理、监控代理）需要紧密协作。



| 模式          | 隔离性       | 性能                | 适用场景                               |
| :------------ | :----------- | :------------------ | :------------------------------------- |
| **Bridge**    | 良好         | 一般（有 NAT 开销） | 大多数单主机应用，需要隔离与外网访问   |
| **Host**      | 无           | 最高                | 高性能网络需求，或监控宿主机网络       |
| **None**      | 完全隔离     | 无网络              | 离线任务，或需要自定义网络的高安全场景 |
| **Container** | 容器间无隔离 | 高（容器间通信）    | 紧耦合的容器组，如 Pod                 |

选择哪种网络模式，本质上是在**隔离性、性能和易用性**之间做权衡。

现在，请你思考一下：如果你要部署一个包含 **Web 服务器、数据库和 Redis 缓存**的三层应用，你会分别为它们选择哪种网络模式？为什么？